
FreeRTOS_STM32N6570-DK_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000034c0  3400074c  3400074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000001c  34003c0c  34003c0c  00003c0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  34003c28  34003c28  00003c60  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  34003c28  34003c28  00003c60  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  34003c28  34003c60  00003c60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  34003c28  34003c28  00003c28  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  34003c2c  34003c2c  00003c2c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000010  34003c30  34003c30  00003c30  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000000  34003c40  34003c40  00003c60  2**0
                  CONTENTS
 10 .gnu.sgstubs  00000020  34003c40  34003c40  00003c40  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          0000f3a8  34003c60  34003c60  00003c60  2**2
                  ALLOC
 12 ._user_heap_stack 00000a00  34013008  34013008  00003c60  2**0
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  00003c60  2**0
                  CONTENTS, READONLY
 14 .debug_info   0000d947  00000000  00000000  00003c9a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00001f4f  00000000  00000000  000115e1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00000fe8  00000000  00000000  00013530  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00000bf2  00000000  00000000  00014518  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0005468c  00000000  00000000  0001510a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0000faf9  00000000  00000000  00069796  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    00214824  00000000  00000000  0007928f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  0028dab3  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00003fd0  00000000  00000000  0028daf8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000052  00000000  00000000  00291ac8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3400074c <__do_global_dtors_aux>:
3400074c:	b510      	push	{r4, lr}
3400074e:	4c05      	ldr	r4, [pc, #20]	@ (34000764 <__do_global_dtors_aux+0x18>)
34000750:	7823      	ldrb	r3, [r4, #0]
34000752:	b933      	cbnz	r3, 34000762 <__do_global_dtors_aux+0x16>
34000754:	4b04      	ldr	r3, [pc, #16]	@ (34000768 <__do_global_dtors_aux+0x1c>)
34000756:	b113      	cbz	r3, 3400075e <__do_global_dtors_aux+0x12>
34000758:	4804      	ldr	r0, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x20>)
3400075a:	f3af 8000 	nop.w
3400075e:	2301      	movs	r3, #1
34000760:	7023      	strb	r3, [r4, #0]
34000762:	bd10      	pop	{r4, pc}
34000764:	34003c60 	.word	0x34003c60
34000768:	00000000 	.word	0x00000000
3400076c:	34003bf4 	.word	0x34003bf4

34000770 <frame_dummy>:
34000770:	b508      	push	{r3, lr}
34000772:	4b03      	ldr	r3, [pc, #12]	@ (34000780 <frame_dummy+0x10>)
34000774:	b11b      	cbz	r3, 3400077e <frame_dummy+0xe>
34000776:	4903      	ldr	r1, [pc, #12]	@ (34000784 <frame_dummy+0x14>)
34000778:	4803      	ldr	r0, [pc, #12]	@ (34000788 <frame_dummy+0x18>)
3400077a:	f3af 8000 	nop.w
3400077e:	bd08      	pop	{r3, pc}
34000780:	00000000 	.word	0x00000000
34000784:	34003c64 	.word	0x34003c64
34000788:	34003bf4 	.word	0x34003bf4

3400078c <LL_AHB3_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
3400078c:	b480      	push	{r7}
3400078e:	b085      	sub	sp, #20
34000790:	af00      	add	r7, sp, #0
34000792:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34000794:	4a07      	ldr	r2, [pc, #28]	@ (340007b4 <LL_AHB3_GRP1_EnableClock+0x28>)
34000796:	687b      	ldr	r3, [r7, #4]
34000798:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3ENR);
3400079c:	4b05      	ldr	r3, [pc, #20]	@ (340007b4 <LL_AHB3_GRP1_EnableClock+0x28>)
3400079e:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
340007a2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340007a4:	68fb      	ldr	r3, [r7, #12]
}
340007a6:	bf00      	nop
340007a8:	3714      	adds	r7, #20
340007aa:	46bd      	mov	sp, r7
340007ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340007b0:	4770      	bx	lr
340007b2:	bf00      	nop
340007b4:	56028000 	.word	0x56028000

340007b8 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
340007b8:	b480      	push	{r7}
340007ba:	b085      	sub	sp, #20
340007bc:	af00      	add	r7, sp, #0
340007be:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
340007c0:	4a07      	ldr	r2, [pc, #28]	@ (340007e0 <LL_AHB4_GRP1_EnableClock+0x28>)
340007c2:	687b      	ldr	r3, [r7, #4]
340007c4:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
340007c8:	4b05      	ldr	r3, [pc, #20]	@ (340007e0 <LL_AHB4_GRP1_EnableClock+0x28>)
340007ca:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
340007ce:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340007d0:	68fb      	ldr	r3, [r7, #12]
}
340007d2:	bf00      	nop
340007d4:	3714      	adds	r7, #20
340007d6:	46bd      	mov	sp, r7
340007d8:	f85d 7b04 	ldr.w	r7, [sp], #4
340007dc:	4770      	bx	lr
340007de:	bf00      	nop
340007e0:	56028000 	.word	0x56028000

340007e4 <vTaskFunction>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void vTaskFunction(void *pvParameters)
{
340007e4:	b580      	push	{r7, lr}
340007e6:	b082      	sub	sp, #8
340007e8:	af00      	add	r7, sp, #0
340007ea:	6078      	str	r0, [r7, #4]
    while (1)
    {
    	HAL_GPIO_TogglePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin);
340007ec:	2102      	movs	r1, #2
340007ee:	4804      	ldr	r0, [pc, #16]	@ (34000800 <vTaskFunction+0x1c>)
340007f0:	f000 fe32 	bl	34001458 <HAL_GPIO_TogglePin>
        // Task code here
        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for 1000ms
340007f4:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
340007f8:	f001 fe4a 	bl	34002490 <vTaskDelay>
    	HAL_GPIO_TogglePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin);
340007fc:	bf00      	nop
340007fe:	e7f5      	b.n	340007ec <vTaskFunction+0x8>
34000800:	56023800 	.word	0x56023800

34000804 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34000804:	b580      	push	{r7, lr}
34000806:	b082      	sub	sp, #8
34000808:	af02      	add	r7, sp, #8
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Update SystemCoreClock variable according to RCC registers values. */
  SystemCoreClockUpdate();
3400080a:	f000 f929 	bl	34000a60 <SystemCoreClockUpdate>
  HAL_Init();
3400080e:	f000 fb14 	bl	34000e3a <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Update SystemCoreClock variable */
  SystemCoreClockUpdate();
34000812:	f000 f925 	bl	34000a60 <SystemCoreClockUpdate>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  SystemIsolation_Config();
34000816:	f000 f815 	bl	34000844 <SystemIsolation_Config>
  MX_GPIO_Init();
3400081a:	f000 f823 	bl	34000864 <MX_GPIO_Init>
  /* USER CODE BEGIN 2 */
  xTaskCreate(vTaskFunction, "MyTask", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
3400081e:	2300      	movs	r3, #0
34000820:	9301      	str	r3, [sp, #4]
34000822:	2301      	movs	r3, #1
34000824:	9300      	str	r3, [sp, #0]
34000826:	2300      	movs	r3, #0
34000828:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400082c:	4903      	ldr	r1, [pc, #12]	@ (3400083c <main+0x38>)
3400082e:	4804      	ldr	r0, [pc, #16]	@ (34000840 <main+0x3c>)
34000830:	f001 fcf8 	bl	34002224 <xTaskCreate>

  // Start scheduler
  vTaskStartScheduler();
34000834:	f001 fe9e 	bl	34002574 <vTaskStartScheduler>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34000838:	bf00      	nop
3400083a:	e7fd      	b.n	34000838 <main+0x34>
3400083c:	34003c0c 	.word	0x34003c0c
34000840:	340007e5 	.word	0x340007e5

34000844 <SystemIsolation_Config>:
  * @brief RIF Initialization Function
  * @param None
  * @retval None
  */
  static void SystemIsolation_Config(void)
{
34000844:	b580      	push	{r7, lr}
34000846:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RIF_Init 0 */

  /* USER CODE END RIF_Init 0 */

  /* set all required IPs as secure privileged */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34000848:	f44f 7000 	mov.w	r0, #512	@ 0x200
3400084c:	f7ff ff9e 	bl	3400078c <LL_AHB3_GRP1_EnableClock>

  /* RIF-Aware IPs Config */

  /* set up GPIO configuration */
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34000850:	f240 3201 	movw	r2, #769	@ 0x301
34000854:	2102      	movs	r1, #2
34000856:	4802      	ldr	r0, [pc, #8]	@ (34000860 <SystemIsolation_Config+0x1c>)
34000858:	f000 fe18 	bl	3400148c <HAL_GPIO_ConfigPinAttributes>
  /* USER CODE END RIF_Init 1 */
  /* USER CODE BEGIN RIF_Init 2 */

  /* USER CODE END RIF_Init 2 */

}
3400085c:	bf00      	nop
3400085e:	bd80      	pop	{r7, pc}
34000860:	56023800 	.word	0x56023800

34000864 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34000864:	b580      	push	{r7, lr}
34000866:	b086      	sub	sp, #24
34000868:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
3400086a:	1d3b      	adds	r3, r7, #4
3400086c:	2200      	movs	r2, #0
3400086e:	601a      	str	r2, [r3, #0]
34000870:	605a      	str	r2, [r3, #4]
34000872:	609a      	str	r2, [r3, #8]
34000874:	60da      	str	r2, [r3, #12]
34000876:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOO_CLK_ENABLE();
34000878:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3400087c:	f7ff ff9c 	bl	340007b8 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GREEN_LED_GPIO_Port, GREEN_LED_Pin, GPIO_PIN_RESET);
34000880:	2200      	movs	r2, #0
34000882:	2102      	movs	r1, #2
34000884:	4809      	ldr	r0, [pc, #36]	@ (340008ac <MX_GPIO_Init+0x48>)
34000886:	f000 fdcf 	bl	34001428 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : GREEN_LED_Pin */
  GPIO_InitStruct.Pin = GREEN_LED_Pin;
3400088a:	2302      	movs	r3, #2
3400088c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
3400088e:	2301      	movs	r3, #1
34000890:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34000892:	2300      	movs	r3, #0
34000894:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34000896:	2300      	movs	r3, #0
34000898:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GREEN_LED_GPIO_Port, &GPIO_InitStruct);
3400089a:	1d3b      	adds	r3, r7, #4
3400089c:	4619      	mov	r1, r3
3400089e:	4803      	ldr	r0, [pc, #12]	@ (340008ac <MX_GPIO_Init+0x48>)
340008a0:	f000 fc10 	bl	340010c4 <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
340008a4:	bf00      	nop
340008a6:	3718      	adds	r7, #24
340008a8:	46bd      	mov	sp, r7
340008aa:	bd80      	pop	{r7, pc}
340008ac:	56023800 	.word	0x56023800

340008b0 <vApplicationMallocFailedHook>:

/* USER CODE BEGIN 4 */
void vApplicationMallocFailedHook(void)
{
340008b0:	b480      	push	{r7}
340008b2:	af00      	add	r7, sp, #0
	__BKPT(0);
340008b4:	be00      	bkpt	0x0000
}
340008b6:	bf00      	nop
340008b8:	46bd      	mov	sp, r7
340008ba:	f85d 7b04 	ldr.w	r7, [sp], #4
340008be:	4770      	bx	lr

340008c0 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
340008c0:	b2c0      	uxtb	r0, r0
340008c2:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
340008c6:	b480      	push	{r7}
340008c8:	b082      	sub	sp, #8
340008ca:	af00      	add	r7, sp, #0
340008cc:	4603      	mov	r3, r0
340008ce:	6039      	str	r1, [r7, #0]
340008d0:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
340008d2:	683b      	ldr	r3, [r7, #0]
340008d4:	2b00      	cmp	r3, #0
340008d6:	d00d      	beq.n	340008f4 <__acle_se_SECURE_RegisterCallback+0x34>
  {
    switch(CallbackId)
340008d8:	79fb      	ldrb	r3, [r7, #7]
340008da:	2b00      	cmp	r3, #0
340008dc:	d002      	beq.n	340008e4 <__acle_se_SECURE_RegisterCallback+0x24>
340008de:	2b01      	cmp	r3, #1
340008e0:	d004      	beq.n	340008ec <__acle_se_SECURE_RegisterCallback+0x2c>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
340008e2:	e007      	b.n	340008f4 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureFaultCallback = func;
340008e4:	4a09      	ldr	r2, [pc, #36]	@ (3400090c <__acle_se_SECURE_RegisterCallback+0x4c>)
340008e6:	683b      	ldr	r3, [r7, #0]
340008e8:	6013      	str	r3, [r2, #0]
        break;
340008ea:	e003      	b.n	340008f4 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureErrorCallback = func;
340008ec:	4a08      	ldr	r2, [pc, #32]	@ (34000910 <__acle_se_SECURE_RegisterCallback+0x50>)
340008ee:	683b      	ldr	r3, [r7, #0]
340008f0:	6013      	str	r3, [r2, #0]
        break;
340008f2:	bf00      	nop
    }
  }
}
340008f4:	bf00      	nop
340008f6:	3708      	adds	r7, #8
340008f8:	46bd      	mov	sp, r7
340008fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340008fe:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34000902:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
34000906:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
3400090a:	4774      	bxns	lr
3400090c:	34003c7c 	.word	0x34003c7c
34000910:	34003c80 	.word	0x34003c80

34000914 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34000914:	b580      	push	{r7, lr}
34000916:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34000918:	f000 fe00 	bl	3400151c <HAL_PWREx_EnableVddIO2>

  HAL_PWREx_EnableVddIO3();
3400091c:	f000 fe0e 	bl	3400153c <HAL_PWREx_EnableVddIO3>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34000920:	bf00      	nop
34000922:	bd80      	pop	{r7, pc}

34000924 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34000924:	b480      	push	{r7}
34000926:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34000928:	bf00      	nop
3400092a:	e7fd      	b.n	34000928 <NMI_Handler+0x4>

3400092c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
3400092c:	b480      	push	{r7}
3400092e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34000930:	bf00      	nop
34000932:	e7fd      	b.n	34000930 <HardFault_Handler+0x4>

34000934 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34000934:	b480      	push	{r7}
34000936:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34000938:	bf00      	nop
3400093a:	e7fd      	b.n	34000938 <MemManage_Handler+0x4>

3400093c <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
3400093c:	b480      	push	{r7}
3400093e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34000940:	bf00      	nop
34000942:	e7fd      	b.n	34000940 <BusFault_Handler+0x4>

34000944 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34000944:	b480      	push	{r7}
34000946:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34000948:	bf00      	nop
3400094a:	e7fd      	b.n	34000948 <UsageFault_Handler+0x4>

3400094c <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
3400094c:	b480      	push	{r7}
3400094e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34000950:	bf00      	nop
34000952:	e7fd      	b.n	34000950 <SecureFault_Handler+0x4>

34000954 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34000954:	b480      	push	{r7}
34000956:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34000958:	bf00      	nop
3400095a:	46bd      	mov	sp, r7
3400095c:	f85d 7b04 	ldr.w	r7, [sp], #4
34000960:	4770      	bx	lr

34000962 <SysTick_Handler>:
#if defined(SysTick_Handler)
#undef SysTick_Handler
#endif

void SysTick_Handler (void)
{
34000962:	b580      	push	{r7, lr}
34000964:	af00      	add	r7, sp, #0
#if (configUSE_TICKLESS_IDLE != 0 )
  /* Clear overflow flag */
  SysTick->CTRL;
#endif

  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
34000966:	f002 fb21 	bl	34002fac <xTaskGetSchedulerState>
3400096a:	4603      	mov	r3, r0
3400096c:	2b01      	cmp	r3, #1
3400096e:	d001      	beq.n	34000974 <SysTick_Handler+0x12>
    /* Call tick handler */
    xPortSysTickHandler();
34000970:	f000 ff1a 	bl	340017a8 <xPortSysTickHandler>
  }

  HAL_IncTick();
34000974:	f000 faac 	bl	34000ed0 <HAL_IncTick>
}
34000978:	bf00      	nop
3400097a:	bd80      	pop	{r7, pc}

3400097c <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
3400097c:	b480      	push	{r7}
3400097e:	af00      	add	r7, sp, #0
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
34000980:	4b18      	ldr	r3, [pc, #96]	@ (340009e4 <TZ_SAU_Setup+0x68>)
34000982:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34000986:	4a17      	ldr	r2, [pc, #92]	@ (340009e4 <TZ_SAU_Setup+0x68>)
34000988:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
3400098c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34000990:	4b15      	ldr	r3, [pc, #84]	@ (340009e8 <TZ_SAU_Setup+0x6c>)
34000992:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
34000994:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34000998:	4a13      	ldr	r2, [pc, #76]	@ (340009e8 <TZ_SAU_Setup+0x6c>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
3400099a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
3400099e:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
340009a0:	4b12      	ldr	r3, [pc, #72]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009a2:	2200      	movs	r2, #0
340009a4:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
340009a8:	4b10      	ldr	r3, [pc, #64]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009aa:	2200      	movs	r2, #0
340009ac:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
340009b0:	4b0e      	ldr	r3, [pc, #56]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009b2:	2200      	movs	r2, #0
340009b4:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
340009b8:	4b0c      	ldr	r3, [pc, #48]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009ba:	2200      	movs	r2, #0
340009bc:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
340009c0:	4b0a      	ldr	r3, [pc, #40]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009c2:	2200      	movs	r2, #0
340009c4:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
340009c8:	4b08      	ldr	r3, [pc, #32]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009ca:	2200      	movs	r2, #0
340009cc:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
340009d0:	4b06      	ldr	r3, [pc, #24]	@ (340009ec <TZ_SAU_Setup+0x70>)
340009d2:	2200      	movs	r2, #0
340009d4:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
  #endif

}
340009d8:	bf00      	nop
340009da:	46bd      	mov	sp, r7
340009dc:	f85d 7b04 	ldr.w	r7, [sp], #4
340009e0:	4770      	bx	lr
340009e2:	bf00      	nop
340009e4:	e000ed00 	.word	0xe000ed00
340009e8:	e000ef30 	.word	0xe000ef30
340009ec:	e000e100 	.word	0xe000e100

340009f0 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
340009f0:	b580      	push	{r7, lr}
340009f2:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
340009f4:	f7ff ffc2 	bl	3400097c <TZ_SAU_Setup>

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
340009f8:	4b14      	ldr	r3, [pc, #80]	@ (34000a4c <SystemInit+0x5c>)
340009fa:	4a15      	ldr	r2, [pc, #84]	@ (34000a50 <SystemInit+0x60>)
340009fc:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
340009fe:	4b15      	ldr	r3, [pc, #84]	@ (34000a54 <SystemInit+0x64>)
34000a00:	2201      	movs	r2, #1
34000a02:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34000a06:	4b13      	ldr	r3, [pc, #76]	@ (34000a54 <SystemInit+0x64>)
34000a08:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34000a0c:	4b0f      	ldr	r3, [pc, #60]	@ (34000a4c <SystemInit+0x5c>)
34000a0e:	4a12      	ldr	r2, [pc, #72]	@ (34000a58 <SystemInit+0x68>)
34000a10:	689b      	ldr	r3, [r3, #8]
34000a12:	6113      	str	r3, [r2, #16]
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34000a14:	4b10      	ldr	r3, [pc, #64]	@ (34000a58 <SystemInit+0x68>)
34000a16:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34000a18:	4b0e      	ldr	r3, [pc, #56]	@ (34000a54 <SystemInit+0x64>)
34000a1a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34000a1e:	461a      	mov	r2, r3
34000a20:	2301      	movs	r3, #1
34000a22:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34000a26:	4b09      	ldr	r3, [pc, #36]	@ (34000a4c <SystemInit+0x5c>)
34000a28:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34000a2c:	4a07      	ldr	r2, [pc, #28]	@ (34000a4c <SystemInit+0x5c>)
34000a2e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34000a32:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34000a36:	4b09      	ldr	r3, [pc, #36]	@ (34000a5c <SystemInit+0x6c>)
34000a38:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34000a3c:	4a07      	ldr	r2, [pc, #28]	@ (34000a5c <SystemInit+0x6c>)
34000a3e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34000a42:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34000a46:	bf00      	nop
34000a48:	bd80      	pop	{r7, pc}
34000a4a:	bf00      	nop
34000a4c:	e000ed00 	.word	0xe000ed00
34000a50:	34000400 	.word	0x34000400
34000a54:	56028000 	.word	0x56028000
34000a58:	56008000 	.word	0x56008000
34000a5c:	e002ed00 	.word	0xe002ed00

34000a60 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34000a60:	b480      	push	{r7}
34000a62:	b08d      	sub	sp, #52	@ 0x34
34000a64:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34000a66:	2300      	movs	r3, #0
34000a68:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34000a6a:	2300      	movs	r3, #0
34000a6c:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34000a6e:	2300      	movs	r3, #0
34000a70:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34000a72:	2300      	movs	r3, #0
34000a74:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34000a76:	2300      	movs	r3, #0
34000a78:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34000a7a:	2300      	movs	r3, #0
34000a7c:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34000a7e:	4b9b      	ldr	r3, [pc, #620]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000a80:	6a1b      	ldr	r3, [r3, #32]
34000a82:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34000a86:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34000a8a:	d029      	beq.n	34000ae0 <SystemCoreClockUpdate+0x80>
34000a8c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34000a90:	f200 8180 	bhi.w	34000d94 <SystemCoreClockUpdate+0x334>
34000a94:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34000a98:	d01f      	beq.n	34000ada <SystemCoreClockUpdate+0x7a>
34000a9a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34000a9e:	f200 8179 	bhi.w	34000d94 <SystemCoreClockUpdate+0x334>
34000aa2:	2b00      	cmp	r3, #0
34000aa4:	d003      	beq.n	34000aae <SystemCoreClockUpdate+0x4e>
34000aa6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34000aaa:	d00a      	beq.n	34000ac2 <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34000aac:	e172      	b.n	34000d94 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34000aae:	4b8f      	ldr	r3, [pc, #572]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000ab0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34000ab2:	09db      	lsrs	r3, r3, #7
34000ab4:	f003 0303 	and.w	r3, r3, #3
34000ab8:	4a8d      	ldr	r2, [pc, #564]	@ (34000cf0 <SystemCoreClockUpdate+0x290>)
34000aba:	fa22 f303 	lsr.w	r3, r2, r3
34000abe:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34000ac0:	e169      	b.n	34000d96 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34000ac2:	4b8a      	ldr	r3, [pc, #552]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000ac4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34000ac6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34000aca:	2b00      	cmp	r3, #0
34000acc:	d102      	bne.n	34000ad4 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34000ace:	4b89      	ldr	r3, [pc, #548]	@ (34000cf4 <SystemCoreClockUpdate+0x294>)
34000ad0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34000ad2:	e160      	b.n	34000d96 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34000ad4:	4b88      	ldr	r3, [pc, #544]	@ (34000cf8 <SystemCoreClockUpdate+0x298>)
34000ad6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34000ad8:	e15d      	b.n	34000d96 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34000ada:	4b88      	ldr	r3, [pc, #544]	@ (34000cfc <SystemCoreClockUpdate+0x29c>)
34000adc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34000ade:	e15a      	b.n	34000d96 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34000ae0:	4b82      	ldr	r3, [pc, #520]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000ae2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34000ae6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34000aea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34000aee:	d066      	beq.n	34000bbe <SystemCoreClockUpdate+0x15e>
34000af0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34000af4:	f200 8091 	bhi.w	34000c1a <SystemCoreClockUpdate+0x1ba>
34000af8:	2b00      	cmp	r3, #0
34000afa:	d003      	beq.n	34000b04 <SystemCoreClockUpdate+0xa4>
34000afc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34000b00:	d02f      	beq.n	34000b62 <SystemCoreClockUpdate+0x102>
34000b02:	e08a      	b.n	34000c1a <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34000b04:	4b79      	ldr	r3, [pc, #484]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000b06:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34000b0a:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34000b0c:	68fb      	ldr	r3, [r7, #12]
34000b0e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34000b12:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34000b14:	68fb      	ldr	r3, [r7, #12]
34000b16:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34000b1a:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34000b1c:	693b      	ldr	r3, [r7, #16]
34000b1e:	2b00      	cmp	r3, #0
34000b20:	f040 80a9 	bne.w	34000c76 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34000b24:	68fb      	ldr	r3, [r7, #12]
34000b26:	0d1b      	lsrs	r3, r3, #20
34000b28:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34000b2c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34000b2e:	68fb      	ldr	r3, [r7, #12]
34000b30:	0a1b      	lsrs	r3, r3, #8
34000b32:	f3c3 030b 	ubfx	r3, r3, #0, #12
34000b36:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34000b38:	4b6c      	ldr	r3, [pc, #432]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000b3a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34000b3e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34000b42:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34000b44:	4b69      	ldr	r3, [pc, #420]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000b46:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34000b4a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34000b4c:	68fb      	ldr	r3, [r7, #12]
34000b4e:	0edb      	lsrs	r3, r3, #27
34000b50:	f003 0307 	and.w	r3, r3, #7
34000b54:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
34000b56:	68fb      	ldr	r3, [r7, #12]
34000b58:	0e1b      	lsrs	r3, r3, #24
34000b5a:	f003 0307 	and.w	r3, r3, #7
34000b5e:	61bb      	str	r3, [r7, #24]
      break;
34000b60:	e089      	b.n	34000c76 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34000b62:	4b62      	ldr	r3, [pc, #392]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000b64:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34000b68:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34000b6a:	68fb      	ldr	r3, [r7, #12]
34000b6c:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34000b70:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34000b72:	68fb      	ldr	r3, [r7, #12]
34000b74:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34000b78:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34000b7a:	693b      	ldr	r3, [r7, #16]
34000b7c:	2b00      	cmp	r3, #0
34000b7e:	d17c      	bne.n	34000c7a <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34000b80:	68fb      	ldr	r3, [r7, #12]
34000b82:	0d1b      	lsrs	r3, r3, #20
34000b84:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34000b88:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34000b8a:	68fb      	ldr	r3, [r7, #12]
34000b8c:	0a1b      	lsrs	r3, r3, #8
34000b8e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34000b92:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34000b94:	4b55      	ldr	r3, [pc, #340]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000b96:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34000b9a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34000b9e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34000ba0:	4b52      	ldr	r3, [pc, #328]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000ba2:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34000ba6:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34000ba8:	68fb      	ldr	r3, [r7, #12]
34000baa:	0edb      	lsrs	r3, r3, #27
34000bac:	f003 0307 	and.w	r3, r3, #7
34000bb0:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34000bb2:	68fb      	ldr	r3, [r7, #12]
34000bb4:	0e1b      	lsrs	r3, r3, #24
34000bb6:	f003 0307 	and.w	r3, r3, #7
34000bba:	61bb      	str	r3, [r7, #24]
      break;
34000bbc:	e05d      	b.n	34000c7a <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34000bbe:	4b4b      	ldr	r3, [pc, #300]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000bc0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34000bc4:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34000bc6:	68fb      	ldr	r3, [r7, #12]
34000bc8:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34000bcc:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34000bce:	68fb      	ldr	r3, [r7, #12]
34000bd0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34000bd4:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34000bd6:	693b      	ldr	r3, [r7, #16]
34000bd8:	2b00      	cmp	r3, #0
34000bda:	d150      	bne.n	34000c7e <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34000bdc:	68fb      	ldr	r3, [r7, #12]
34000bde:	0d1b      	lsrs	r3, r3, #20
34000be0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34000be4:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34000be6:	68fb      	ldr	r3, [r7, #12]
34000be8:	0a1b      	lsrs	r3, r3, #8
34000bea:	f3c3 030b 	ubfx	r3, r3, #0, #12
34000bee:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34000bf0:	4b3e      	ldr	r3, [pc, #248]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000bf2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34000bf6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34000bfa:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34000bfc:	4b3b      	ldr	r3, [pc, #236]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000bfe:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34000c02:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34000c04:	68fb      	ldr	r3, [r7, #12]
34000c06:	0edb      	lsrs	r3, r3, #27
34000c08:	f003 0307 	and.w	r3, r3, #7
34000c0c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34000c0e:	68fb      	ldr	r3, [r7, #12]
34000c10:	0e1b      	lsrs	r3, r3, #24
34000c12:	f003 0307 	and.w	r3, r3, #7
34000c16:	61bb      	str	r3, [r7, #24]
      break;
34000c18:	e031      	b.n	34000c7e <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34000c1a:	4b34      	ldr	r3, [pc, #208]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000c1c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34000c20:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34000c22:	68fb      	ldr	r3, [r7, #12]
34000c24:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34000c28:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34000c2a:	68fb      	ldr	r3, [r7, #12]
34000c2c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34000c30:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34000c32:	693b      	ldr	r3, [r7, #16]
34000c34:	2b00      	cmp	r3, #0
34000c36:	d124      	bne.n	34000c82 <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34000c38:	68fb      	ldr	r3, [r7, #12]
34000c3a:	0d1b      	lsrs	r3, r3, #20
34000c3c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34000c40:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34000c42:	68fb      	ldr	r3, [r7, #12]
34000c44:	0a1b      	lsrs	r3, r3, #8
34000c46:	f3c3 030b 	ubfx	r3, r3, #0, #12
34000c4a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34000c4c:	4b27      	ldr	r3, [pc, #156]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000c4e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34000c52:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34000c56:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34000c58:	4b24      	ldr	r3, [pc, #144]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000c5a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34000c5e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34000c60:	68fb      	ldr	r3, [r7, #12]
34000c62:	0edb      	lsrs	r3, r3, #27
34000c64:	f003 0307 	and.w	r3, r3, #7
34000c68:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34000c6a:	68fb      	ldr	r3, [r7, #12]
34000c6c:	0e1b      	lsrs	r3, r3, #24
34000c6e:	f003 0307 	and.w	r3, r3, #7
34000c72:	61bb      	str	r3, [r7, #24]
      break;
34000c74:	e005      	b.n	34000c82 <SystemCoreClockUpdate+0x222>
      break;
34000c76:	bf00      	nop
34000c78:	e004      	b.n	34000c84 <SystemCoreClockUpdate+0x224>
      break;
34000c7a:	bf00      	nop
34000c7c:	e002      	b.n	34000c84 <SystemCoreClockUpdate+0x224>
      break;
34000c7e:	bf00      	nop
34000c80:	e000      	b.n	34000c84 <SystemCoreClockUpdate+0x224>
      break;
34000c82:	bf00      	nop
    switch (pllsource)
34000c84:	697b      	ldr	r3, [r7, #20]
34000c86:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34000c8a:	d02c      	beq.n	34000ce6 <SystemCoreClockUpdate+0x286>
34000c8c:	697b      	ldr	r3, [r7, #20]
34000c8e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34000c92:	d839      	bhi.n	34000d08 <SystemCoreClockUpdate+0x2a8>
34000c94:	697b      	ldr	r3, [r7, #20]
34000c96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34000c9a:	d021      	beq.n	34000ce0 <SystemCoreClockUpdate+0x280>
34000c9c:	697b      	ldr	r3, [r7, #20]
34000c9e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34000ca2:	d831      	bhi.n	34000d08 <SystemCoreClockUpdate+0x2a8>
34000ca4:	697b      	ldr	r3, [r7, #20]
34000ca6:	2b00      	cmp	r3, #0
34000ca8:	d004      	beq.n	34000cb4 <SystemCoreClockUpdate+0x254>
34000caa:	697b      	ldr	r3, [r7, #20]
34000cac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34000cb0:	d00a      	beq.n	34000cc8 <SystemCoreClockUpdate+0x268>
      break;
34000cb2:	e029      	b.n	34000d08 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34000cb4:	4b0d      	ldr	r3, [pc, #52]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000cb6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34000cb8:	09db      	lsrs	r3, r3, #7
34000cba:	f003 0303 	and.w	r3, r3, #3
34000cbe:	4a0c      	ldr	r2, [pc, #48]	@ (34000cf0 <SystemCoreClockUpdate+0x290>)
34000cc0:	fa22 f303 	lsr.w	r3, r2, r3
34000cc4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34000cc6:	e020      	b.n	34000d0a <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34000cc8:	4b08      	ldr	r3, [pc, #32]	@ (34000cec <SystemCoreClockUpdate+0x28c>)
34000cca:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34000ccc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34000cd0:	2b00      	cmp	r3, #0
34000cd2:	d102      	bne.n	34000cda <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34000cd4:	4b07      	ldr	r3, [pc, #28]	@ (34000cf4 <SystemCoreClockUpdate+0x294>)
34000cd6:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34000cd8:	e017      	b.n	34000d0a <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34000cda:	4b07      	ldr	r3, [pc, #28]	@ (34000cf8 <SystemCoreClockUpdate+0x298>)
34000cdc:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34000cde:	e014      	b.n	34000d0a <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34000ce0:	4b06      	ldr	r3, [pc, #24]	@ (34000cfc <SystemCoreClockUpdate+0x29c>)
34000ce2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34000ce4:	e011      	b.n	34000d0a <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34000ce6:	4b06      	ldr	r3, [pc, #24]	@ (34000d00 <SystemCoreClockUpdate+0x2a0>)
34000ce8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34000cea:	e00e      	b.n	34000d0a <SystemCoreClockUpdate+0x2aa>
34000cec:	56028000 	.word	0x56028000
34000cf0:	03d09000 	.word	0x03d09000
34000cf4:	003d0900 	.word	0x003d0900
34000cf8:	00f42400 	.word	0x00f42400
34000cfc:	02dc6c00 	.word	0x02dc6c00
34000d00:	00bb8000 	.word	0x00bb8000
34000d04:	4b800000 	.word	0x4b800000
      break;
34000d08:	bf00      	nop
    if (pllbypass == 0U)
34000d0a:	693b      	ldr	r3, [r7, #16]
34000d0c:	2b00      	cmp	r3, #0
34000d0e:	d134      	bne.n	34000d7a <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34000d10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34000d12:	ee07 3a90 	vmov	s15, r3
34000d16:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34000d1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34000d1c:	ee07 3a90 	vmov	s15, r3
34000d20:	eef8 6a67 	vcvt.f32.u32	s13, s15
34000d24:	6a3b      	ldr	r3, [r7, #32]
34000d26:	ee07 3a90 	vmov	s15, r3
34000d2a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34000d2e:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34000d04 <SystemCoreClockUpdate+0x2a4>
34000d32:	eec6 7a25 	vdiv.f32	s15, s12, s11
34000d36:	ee76 7aa7 	vadd.f32	s15, s13, s15
34000d3a:	ee67 6a27 	vmul.f32	s13, s14, s15
34000d3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34000d40:	ee07 3a90 	vmov	s15, r3
34000d44:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34000d48:	eec6 7a87 	vdiv.f32	s15, s13, s14
34000d4c:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34000d50:	69fb      	ldr	r3, [r7, #28]
34000d52:	ee07 3a90 	vmov	s15, r3
34000d56:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34000d5a:	69bb      	ldr	r3, [r7, #24]
34000d5c:	ee07 3a90 	vmov	s15, r3
34000d60:	eef8 7a67 	vcvt.f32.u32	s15, s15
34000d64:	ee27 7a27 	vmul.f32	s14, s14, s15
34000d68:	edd7 6a02 	vldr	s13, [r7, #8]
34000d6c:	eec6 7a87 	vdiv.f32	s15, s13, s14
34000d70:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34000d74:	ee17 3a90 	vmov	r3, s15
34000d78:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34000d7a:	4b0b      	ldr	r3, [pc, #44]	@ (34000da8 <SystemCoreClockUpdate+0x348>)
34000d7c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34000d80:	0c1b      	lsrs	r3, r3, #16
34000d82:	b2db      	uxtb	r3, r3
34000d84:	3301      	adds	r3, #1
34000d86:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34000d88:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34000d8a:	687b      	ldr	r3, [r7, #4]
34000d8c:	fbb2 f3f3 	udiv	r3, r2, r3
34000d90:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34000d92:	e000      	b.n	34000d96 <SystemCoreClockUpdate+0x336>
    break;
34000d94:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34000d96:	4a05      	ldr	r2, [pc, #20]	@ (34000dac <SystemCoreClockUpdate+0x34c>)
34000d98:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34000d9a:	6013      	str	r3, [r2, #0]
}
34000d9c:	bf00      	nop
34000d9e:	3734      	adds	r7, #52	@ 0x34
34000da0:	46bd      	mov	sp, r7
34000da2:	f85d 7b04 	ldr.w	r7, [sp], #4
34000da6:	4770      	bx	lr
34000da8:	56028000 	.word	0x56028000
34000dac:	34003c30 	.word	0x34003c30

34000db0 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34000db0:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34000db4:	b588      	push	{r3, r7, lr}
34000db6:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34000db8:	f7ff fe52 	bl	34000a60 <SystemCoreClockUpdate>

  return SystemCoreClock;
34000dbc:	4b06      	ldr	r3, [pc, #24]	@ (34000dd8 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34000dbe:	681b      	ldr	r3, [r3, #0]
}
34000dc0:	4618      	mov	r0, r3
34000dc2:	46bd      	mov	sp, r7
34000dc4:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34000dc8:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34000dcc:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34000dd0:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34000dd4:	4774      	bxns	lr
34000dd6:	bf00      	nop
34000dd8:	34003c30 	.word	0x34003c30

34000ddc <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34000ddc:	480f      	ldr	r0, [pc, #60]	@ (34000e1c <LoopForever+0x4>)
  msr   MSPLIM, r0
34000dde:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34000de2:	480f      	ldr	r0, [pc, #60]	@ (34000e20 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34000de4:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34000de6:	f7ff fe03 	bl	340009f0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34000dea:	480e      	ldr	r0, [pc, #56]	@ (34000e24 <LoopForever+0xc>)
  ldr r1, =_edata
34000dec:	490e      	ldr	r1, [pc, #56]	@ (34000e28 <LoopForever+0x10>)
  ldr r2, =_sidata
34000dee:	4a0f      	ldr	r2, [pc, #60]	@ (34000e2c <LoopForever+0x14>)
  movs r3, #0
34000df0:	2300      	movs	r3, #0
  b LoopCopyDataInit
34000df2:	e002      	b.n	34000dfa <LoopCopyDataInit>

34000df4 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34000df4:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34000df6:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34000df8:	3304      	adds	r3, #4

34000dfa <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34000dfa:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34000dfc:	428c      	cmp	r4, r1
  bcc CopyDataInit
34000dfe:	d3f9      	bcc.n	34000df4 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34000e00:	4a0b      	ldr	r2, [pc, #44]	@ (34000e30 <LoopForever+0x18>)
  ldr r4, =_ebss
34000e02:	4c0c      	ldr	r4, [pc, #48]	@ (34000e34 <LoopForever+0x1c>)
  movs r3, #0
34000e04:	2300      	movs	r3, #0
  b LoopFillZerobss
34000e06:	e001      	b.n	34000e0c <LoopFillZerobss>

34000e08 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34000e08:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34000e0a:	3204      	adds	r2, #4

34000e0c <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34000e0c:	42a2      	cmp	r2, r4
  bcc FillZerobss
34000e0e:	d3fb      	bcc.n	34000e08 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34000e10:	f002 febe 	bl	34003b90 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34000e14:	f7ff fcf6 	bl	34000804 <main>

34000e18 <LoopForever>:

LoopForever:
  b LoopForever
34000e18:	e7fe      	b.n	34000e18 <LoopForever>
34000e1a:	0000      	.short	0x0000
  ldr   r0, =_sstack
34000e1c:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34000e20:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34000e24:	34003c30 	.word	0x34003c30
  ldr r1, =_edata
34000e28:	34003c40 	.word	0x34003c40
  ldr r2, =_sidata
34000e2c:	34003c30 	.word	0x34003c30
  ldr r2, =_sbss
34000e30:	34003c60 	.word	0x34003c60
  ldr r4, =_ebss
34000e34:	34013008 	.word	0x34013008

34000e38 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34000e38:	e7fe      	b.n	34000e38 <ADC1_2_IRQHandler>

34000e3a <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34000e3a:	b580      	push	{r7, lr}
34000e3c:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34000e3e:	2003      	movs	r0, #3
34000e40:	f000 f90c 	bl	3400105c <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34000e44:	f7ff fe0c 	bl	34000a60 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34000e48:	2000      	movs	r0, #0
34000e4a:	f000 f80b 	bl	34000e64 <HAL_InitTick>
34000e4e:	4603      	mov	r3, r0
34000e50:	2b00      	cmp	r3, #0
34000e52:	d001      	beq.n	34000e58 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34000e54:	2301      	movs	r3, #1
34000e56:	e002      	b.n	34000e5e <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34000e58:	f7ff fd5c 	bl	34000914 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34000e5c:	2300      	movs	r3, #0
}
34000e5e:	4618      	mov	r0, r3
34000e60:	bd80      	pop	{r7, pc}
	...

34000e64 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34000e64:	b580      	push	{r7, lr}
34000e66:	b082      	sub	sp, #8
34000e68:	af00      	add	r7, sp, #0
34000e6a:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
34000e6c:	4b15      	ldr	r3, [pc, #84]	@ (34000ec4 <HAL_InitTick+0x60>)
34000e6e:	781b      	ldrb	r3, [r3, #0]
34000e70:	2b00      	cmp	r3, #0
34000e72:	d101      	bne.n	34000e78 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
34000e74:	2301      	movs	r3, #1
34000e76:	e021      	b.n	34000ebc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34000e78:	4b13      	ldr	r3, [pc, #76]	@ (34000ec8 <HAL_InitTick+0x64>)
34000e7a:	681a      	ldr	r2, [r3, #0]
34000e7c:	4b11      	ldr	r3, [pc, #68]	@ (34000ec4 <HAL_InitTick+0x60>)
34000e7e:	781b      	ldrb	r3, [r3, #0]
34000e80:	4619      	mov	r1, r3
34000e82:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34000e86:	fbb3 f3f1 	udiv	r3, r3, r1
34000e8a:	fbb2 f3f3 	udiv	r3, r2, r3
34000e8e:	4618      	mov	r0, r3
34000e90:	f000 f90c 	bl	340010ac <HAL_SYSTICK_Config>
34000e94:	4603      	mov	r3, r0
34000e96:	2b00      	cmp	r3, #0
34000e98:	d001      	beq.n	34000e9e <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34000e9a:	2301      	movs	r3, #1
34000e9c:	e00e      	b.n	34000ebc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34000e9e:	687b      	ldr	r3, [r7, #4]
34000ea0:	2b0f      	cmp	r3, #15
34000ea2:	d80a      	bhi.n	34000eba <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
34000ea4:	2200      	movs	r2, #0
34000ea6:	6879      	ldr	r1, [r7, #4]
34000ea8:	f04f 30ff 	mov.w	r0, #4294967295
34000eac:	f000 f8e1 	bl	34001072 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34000eb0:	4a06      	ldr	r2, [pc, #24]	@ (34000ecc <HAL_InitTick+0x68>)
34000eb2:	687b      	ldr	r3, [r7, #4]
34000eb4:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
34000eb6:	2300      	movs	r3, #0
34000eb8:	e000      	b.n	34000ebc <HAL_InitTick+0x58>
    return HAL_ERROR;
34000eba:	2301      	movs	r3, #1
}
34000ebc:	4618      	mov	r0, r3
34000ebe:	3708      	adds	r7, #8
34000ec0:	46bd      	mov	sp, r7
34000ec2:	bd80      	pop	{r7, pc}
34000ec4:	34003c38 	.word	0x34003c38
34000ec8:	34003c30 	.word	0x34003c30
34000ecc:	34003c34 	.word	0x34003c34

34000ed0 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34000ed0:	b480      	push	{r7}
34000ed2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
34000ed4:	4b06      	ldr	r3, [pc, #24]	@ (34000ef0 <HAL_IncTick+0x20>)
34000ed6:	781b      	ldrb	r3, [r3, #0]
34000ed8:	461a      	mov	r2, r3
34000eda:	4b06      	ldr	r3, [pc, #24]	@ (34000ef4 <HAL_IncTick+0x24>)
34000edc:	681b      	ldr	r3, [r3, #0]
34000ede:	4413      	add	r3, r2
34000ee0:	4a04      	ldr	r2, [pc, #16]	@ (34000ef4 <HAL_IncTick+0x24>)
34000ee2:	6013      	str	r3, [r2, #0]
}
34000ee4:	bf00      	nop
34000ee6:	46bd      	mov	sp, r7
34000ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
34000eec:	4770      	bx	lr
34000eee:	bf00      	nop
34000ef0:	34003c38 	.word	0x34003c38
34000ef4:	34003c84 	.word	0x34003c84

34000ef8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34000ef8:	b480      	push	{r7}
34000efa:	b085      	sub	sp, #20
34000efc:	af00      	add	r7, sp, #0
34000efe:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34000f00:	687b      	ldr	r3, [r7, #4]
34000f02:	f003 0307 	and.w	r3, r3, #7
34000f06:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
34000f08:	4b0c      	ldr	r3, [pc, #48]	@ (34000f3c <__NVIC_SetPriorityGrouping+0x44>)
34000f0a:	68db      	ldr	r3, [r3, #12]
34000f0c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34000f0e:	68ba      	ldr	r2, [r7, #8]
34000f10:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34000f14:	4013      	ands	r3, r2
34000f16:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
34000f18:	68fb      	ldr	r3, [r7, #12]
34000f1a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34000f1c:	68bb      	ldr	r3, [r7, #8]
34000f1e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34000f20:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34000f24:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34000f28:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34000f2a:	4a04      	ldr	r2, [pc, #16]	@ (34000f3c <__NVIC_SetPriorityGrouping+0x44>)
34000f2c:	68bb      	ldr	r3, [r7, #8]
34000f2e:	60d3      	str	r3, [r2, #12]
}
34000f30:	bf00      	nop
34000f32:	3714      	adds	r7, #20
34000f34:	46bd      	mov	sp, r7
34000f36:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f3a:	4770      	bx	lr
34000f3c:	e000ed00 	.word	0xe000ed00

34000f40 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34000f40:	b480      	push	{r7}
34000f42:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34000f44:	4b04      	ldr	r3, [pc, #16]	@ (34000f58 <__NVIC_GetPriorityGrouping+0x18>)
34000f46:	68db      	ldr	r3, [r3, #12]
34000f48:	0a1b      	lsrs	r3, r3, #8
34000f4a:	f003 0307 	and.w	r3, r3, #7
}
34000f4e:	4618      	mov	r0, r3
34000f50:	46bd      	mov	sp, r7
34000f52:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f56:	4770      	bx	lr
34000f58:	e000ed00 	.word	0xe000ed00

34000f5c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34000f5c:	b480      	push	{r7}
34000f5e:	b083      	sub	sp, #12
34000f60:	af00      	add	r7, sp, #0
34000f62:	4603      	mov	r3, r0
34000f64:	6039      	str	r1, [r7, #0]
34000f66:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34000f68:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34000f6c:	2b00      	cmp	r3, #0
34000f6e:	db0a      	blt.n	34000f86 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34000f70:	683b      	ldr	r3, [r7, #0]
34000f72:	b2da      	uxtb	r2, r3
34000f74:	490c      	ldr	r1, [pc, #48]	@ (34000fa8 <__NVIC_SetPriority+0x4c>)
34000f76:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34000f7a:	0112      	lsls	r2, r2, #4
34000f7c:	b2d2      	uxtb	r2, r2
34000f7e:	440b      	add	r3, r1
34000f80:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34000f84:	e00a      	b.n	34000f9c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34000f86:	683b      	ldr	r3, [r7, #0]
34000f88:	b2da      	uxtb	r2, r3
34000f8a:	4908      	ldr	r1, [pc, #32]	@ (34000fac <__NVIC_SetPriority+0x50>)
34000f8c:	88fb      	ldrh	r3, [r7, #6]
34000f8e:	f003 030f 	and.w	r3, r3, #15
34000f92:	3b04      	subs	r3, #4
34000f94:	0112      	lsls	r2, r2, #4
34000f96:	b2d2      	uxtb	r2, r2
34000f98:	440b      	add	r3, r1
34000f9a:	761a      	strb	r2, [r3, #24]
}
34000f9c:	bf00      	nop
34000f9e:	370c      	adds	r7, #12
34000fa0:	46bd      	mov	sp, r7
34000fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
34000fa6:	4770      	bx	lr
34000fa8:	e000e100 	.word	0xe000e100
34000fac:	e000ed00 	.word	0xe000ed00

34000fb0 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34000fb0:	b480      	push	{r7}
34000fb2:	b089      	sub	sp, #36	@ 0x24
34000fb4:	af00      	add	r7, sp, #0
34000fb6:	60f8      	str	r0, [r7, #12]
34000fb8:	60b9      	str	r1, [r7, #8]
34000fba:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34000fbc:	68fb      	ldr	r3, [r7, #12]
34000fbe:	f003 0307 	and.w	r3, r3, #7
34000fc2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34000fc4:	69fb      	ldr	r3, [r7, #28]
34000fc6:	f1c3 0307 	rsb	r3, r3, #7
34000fca:	2b04      	cmp	r3, #4
34000fcc:	bf28      	it	cs
34000fce:	2304      	movcs	r3, #4
34000fd0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34000fd2:	69fb      	ldr	r3, [r7, #28]
34000fd4:	3304      	adds	r3, #4
34000fd6:	2b06      	cmp	r3, #6
34000fd8:	d902      	bls.n	34000fe0 <NVIC_EncodePriority+0x30>
34000fda:	69fb      	ldr	r3, [r7, #28]
34000fdc:	3b03      	subs	r3, #3
34000fde:	e000      	b.n	34000fe2 <NVIC_EncodePriority+0x32>
34000fe0:	2300      	movs	r3, #0
34000fe2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34000fe4:	f04f 32ff 	mov.w	r2, #4294967295
34000fe8:	69bb      	ldr	r3, [r7, #24]
34000fea:	fa02 f303 	lsl.w	r3, r2, r3
34000fee:	43da      	mvns	r2, r3
34000ff0:	68bb      	ldr	r3, [r7, #8]
34000ff2:	401a      	ands	r2, r3
34000ff4:	697b      	ldr	r3, [r7, #20]
34000ff6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34000ff8:	f04f 31ff 	mov.w	r1, #4294967295
34000ffc:	697b      	ldr	r3, [r7, #20]
34000ffe:	fa01 f303 	lsl.w	r3, r1, r3
34001002:	43d9      	mvns	r1, r3
34001004:	687b      	ldr	r3, [r7, #4]
34001006:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34001008:	4313      	orrs	r3, r2
         );
}
3400100a:	4618      	mov	r0, r3
3400100c:	3724      	adds	r7, #36	@ 0x24
3400100e:	46bd      	mov	sp, r7
34001010:	f85d 7b04 	ldr.w	r7, [sp], #4
34001014:	4770      	bx	lr
	...

34001018 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34001018:	b580      	push	{r7, lr}
3400101a:	b082      	sub	sp, #8
3400101c:	af00      	add	r7, sp, #0
3400101e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34001020:	687b      	ldr	r3, [r7, #4]
34001022:	3b01      	subs	r3, #1
34001024:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34001028:	d301      	bcc.n	3400102e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
3400102a:	2301      	movs	r3, #1
3400102c:	e00f      	b.n	3400104e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
3400102e:	4a0a      	ldr	r2, [pc, #40]	@ (34001058 <SysTick_Config+0x40>)
34001030:	687b      	ldr	r3, [r7, #4]
34001032:	3b01      	subs	r3, #1
34001034:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
34001036:	210f      	movs	r1, #15
34001038:	f04f 30ff 	mov.w	r0, #4294967295
3400103c:	f7ff ff8e 	bl	34000f5c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34001040:	4b05      	ldr	r3, [pc, #20]	@ (34001058 <SysTick_Config+0x40>)
34001042:	2200      	movs	r2, #0
34001044:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34001046:	4b04      	ldr	r3, [pc, #16]	@ (34001058 <SysTick_Config+0x40>)
34001048:	2207      	movs	r2, #7
3400104a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
3400104c:	2300      	movs	r3, #0
}
3400104e:	4618      	mov	r0, r3
34001050:	3708      	adds	r7, #8
34001052:	46bd      	mov	sp, r7
34001054:	bd80      	pop	{r7, pc}
34001056:	bf00      	nop
34001058:	e000e010 	.word	0xe000e010

3400105c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3400105c:	b580      	push	{r7, lr}
3400105e:	b082      	sub	sp, #8
34001060:	af00      	add	r7, sp, #0
34001062:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34001064:	6878      	ldr	r0, [r7, #4]
34001066:	f7ff ff47 	bl	34000ef8 <__NVIC_SetPriorityGrouping>
}
3400106a:	bf00      	nop
3400106c:	3708      	adds	r7, #8
3400106e:	46bd      	mov	sp, r7
34001070:	bd80      	pop	{r7, pc}

34001072 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34001072:	b580      	push	{r7, lr}
34001074:	b086      	sub	sp, #24
34001076:	af00      	add	r7, sp, #0
34001078:	4603      	mov	r3, r0
3400107a:	60b9      	str	r1, [r7, #8]
3400107c:	607a      	str	r2, [r7, #4]
3400107e:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34001080:	f7ff ff5e 	bl	34000f40 <__NVIC_GetPriorityGrouping>
34001084:	4603      	mov	r3, r0
34001086:	f003 0307 	and.w	r3, r3, #7
3400108a:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
3400108c:	687a      	ldr	r2, [r7, #4]
3400108e:	68b9      	ldr	r1, [r7, #8]
34001090:	6978      	ldr	r0, [r7, #20]
34001092:	f7ff ff8d 	bl	34000fb0 <NVIC_EncodePriority>
34001096:	4602      	mov	r2, r0
34001098:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3400109c:	4611      	mov	r1, r2
3400109e:	4618      	mov	r0, r3
340010a0:	f7ff ff5c 	bl	34000f5c <__NVIC_SetPriority>
}
340010a4:	bf00      	nop
340010a6:	3718      	adds	r7, #24
340010a8:	46bd      	mov	sp, r7
340010aa:	bd80      	pop	{r7, pc}

340010ac <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
340010ac:	b580      	push	{r7, lr}
340010ae:	b082      	sub	sp, #8
340010b0:	af00      	add	r7, sp, #0
340010b2:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
340010b4:	6878      	ldr	r0, [r7, #4]
340010b6:	f7ff ffaf 	bl	34001018 <SysTick_Config>
340010ba:	4603      	mov	r3, r0
}
340010bc:	4618      	mov	r0, r3
340010be:	3708      	adds	r7, #8
340010c0:	46bd      	mov	sp, r7
340010c2:	bd80      	pop	{r7, pc}

340010c4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
340010c4:	b480      	push	{r7}
340010c6:	b087      	sub	sp, #28
340010c8:	af00      	add	r7, sp, #0
340010ca:	6078      	str	r0, [r7, #4]
340010cc:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
340010ce:	2300      	movs	r3, #0
340010d0:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
340010d2:	e180      	b.n	340013d6 <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
340010d4:	683b      	ldr	r3, [r7, #0]
340010d6:	681a      	ldr	r2, [r3, #0]
340010d8:	2101      	movs	r1, #1
340010da:	697b      	ldr	r3, [r7, #20]
340010dc:	fa01 f303 	lsl.w	r3, r1, r3
340010e0:	4013      	ands	r3, r2
340010e2:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
340010e4:	68fb      	ldr	r3, [r7, #12]
340010e6:	2b00      	cmp	r3, #0
340010e8:	f000 8172 	beq.w	340013d0 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
340010ec:	683b      	ldr	r3, [r7, #0]
340010ee:	685b      	ldr	r3, [r3, #4]
340010f0:	f003 0303 	and.w	r3, r3, #3
340010f4:	2b01      	cmp	r3, #1
340010f6:	d005      	beq.n	34001104 <HAL_GPIO_Init+0x40>
340010f8:	683b      	ldr	r3, [r7, #0]
340010fa:	685b      	ldr	r3, [r3, #4]
340010fc:	f003 0303 	and.w	r3, r3, #3
34001100:	2b02      	cmp	r3, #2
34001102:	d130      	bne.n	34001166 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34001104:	687b      	ldr	r3, [r7, #4]
34001106:	689b      	ldr	r3, [r3, #8]
34001108:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400110a:	697b      	ldr	r3, [r7, #20]
3400110c:	005b      	lsls	r3, r3, #1
3400110e:	2203      	movs	r2, #3
34001110:	fa02 f303 	lsl.w	r3, r2, r3
34001114:	43db      	mvns	r3, r3
34001116:	693a      	ldr	r2, [r7, #16]
34001118:	4013      	ands	r3, r2
3400111a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400111c:	683b      	ldr	r3, [r7, #0]
3400111e:	68da      	ldr	r2, [r3, #12]
34001120:	697b      	ldr	r3, [r7, #20]
34001122:	005b      	lsls	r3, r3, #1
34001124:	fa02 f303 	lsl.w	r3, r2, r3
34001128:	693a      	ldr	r2, [r7, #16]
3400112a:	4313      	orrs	r3, r2
3400112c:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
3400112e:	687b      	ldr	r3, [r7, #4]
34001130:	693a      	ldr	r2, [r7, #16]
34001132:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34001134:	687b      	ldr	r3, [r7, #4]
34001136:	685b      	ldr	r3, [r3, #4]
34001138:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
3400113a:	2201      	movs	r2, #1
3400113c:	697b      	ldr	r3, [r7, #20]
3400113e:	fa02 f303 	lsl.w	r3, r2, r3
34001142:	43db      	mvns	r3, r3
34001144:	693a      	ldr	r2, [r7, #16]
34001146:	4013      	ands	r3, r2
34001148:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
3400114a:	683b      	ldr	r3, [r7, #0]
3400114c:	685b      	ldr	r3, [r3, #4]
3400114e:	091b      	lsrs	r3, r3, #4
34001150:	f003 0201 	and.w	r2, r3, #1
34001154:	697b      	ldr	r3, [r7, #20]
34001156:	fa02 f303 	lsl.w	r3, r2, r3
3400115a:	693a      	ldr	r2, [r7, #16]
3400115c:	4313      	orrs	r3, r2
3400115e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34001160:	687b      	ldr	r3, [r7, #4]
34001162:	693a      	ldr	r2, [r7, #16]
34001164:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34001166:	683b      	ldr	r3, [r7, #0]
34001168:	685b      	ldr	r3, [r3, #4]
3400116a:	f003 0303 	and.w	r3, r3, #3
3400116e:	2b03      	cmp	r3, #3
34001170:	d109      	bne.n	34001186 <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34001172:	683b      	ldr	r3, [r7, #0]
34001174:	685b      	ldr	r3, [r3, #4]
34001176:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400117a:	2b03      	cmp	r3, #3
3400117c:	d11b      	bne.n	340011b6 <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3400117e:	683b      	ldr	r3, [r7, #0]
34001180:	689b      	ldr	r3, [r3, #8]
34001182:	2b01      	cmp	r3, #1
34001184:	d017      	beq.n	340011b6 <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
34001186:	687b      	ldr	r3, [r7, #4]
34001188:	68db      	ldr	r3, [r3, #12]
3400118a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
3400118c:	697b      	ldr	r3, [r7, #20]
3400118e:	005b      	lsls	r3, r3, #1
34001190:	2203      	movs	r2, #3
34001192:	fa02 f303 	lsl.w	r3, r2, r3
34001196:	43db      	mvns	r3, r3
34001198:	693a      	ldr	r2, [r7, #16]
3400119a:	4013      	ands	r3, r2
3400119c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
3400119e:	683b      	ldr	r3, [r7, #0]
340011a0:	689a      	ldr	r2, [r3, #8]
340011a2:	697b      	ldr	r3, [r7, #20]
340011a4:	005b      	lsls	r3, r3, #1
340011a6:	fa02 f303 	lsl.w	r3, r2, r3
340011aa:	693a      	ldr	r2, [r7, #16]
340011ac:	4313      	orrs	r3, r2
340011ae:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
340011b0:	687b      	ldr	r3, [r7, #4]
340011b2:	693a      	ldr	r2, [r7, #16]
340011b4:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
340011b6:	683b      	ldr	r3, [r7, #0]
340011b8:	685b      	ldr	r3, [r3, #4]
340011ba:	f003 0303 	and.w	r3, r3, #3
340011be:	2b02      	cmp	r3, #2
340011c0:	d123      	bne.n	3400120a <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
340011c2:	697b      	ldr	r3, [r7, #20]
340011c4:	08da      	lsrs	r2, r3, #3
340011c6:	687b      	ldr	r3, [r7, #4]
340011c8:	3208      	adds	r2, #8
340011ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
340011ce:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340011d0:	697b      	ldr	r3, [r7, #20]
340011d2:	f003 0307 	and.w	r3, r3, #7
340011d6:	009b      	lsls	r3, r3, #2
340011d8:	220f      	movs	r2, #15
340011da:	fa02 f303 	lsl.w	r3, r2, r3
340011de:	43db      	mvns	r3, r3
340011e0:	693a      	ldr	r2, [r7, #16]
340011e2:	4013      	ands	r3, r2
340011e4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
340011e6:	683b      	ldr	r3, [r7, #0]
340011e8:	691a      	ldr	r2, [r3, #16]
340011ea:	697b      	ldr	r3, [r7, #20]
340011ec:	f003 0307 	and.w	r3, r3, #7
340011f0:	009b      	lsls	r3, r3, #2
340011f2:	fa02 f303 	lsl.w	r3, r2, r3
340011f6:	693a      	ldr	r2, [r7, #16]
340011f8:	4313      	orrs	r3, r2
340011fa:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
340011fc:	697b      	ldr	r3, [r7, #20]
340011fe:	08da      	lsrs	r2, r3, #3
34001200:	687b      	ldr	r3, [r7, #4]
34001202:	3208      	adds	r2, #8
34001204:	6939      	ldr	r1, [r7, #16]
34001206:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
3400120a:	687b      	ldr	r3, [r7, #4]
3400120c:	681b      	ldr	r3, [r3, #0]
3400120e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34001210:	697b      	ldr	r3, [r7, #20]
34001212:	005b      	lsls	r3, r3, #1
34001214:	2203      	movs	r2, #3
34001216:	fa02 f303 	lsl.w	r3, r2, r3
3400121a:	43db      	mvns	r3, r3
3400121c:	693a      	ldr	r2, [r7, #16]
3400121e:	4013      	ands	r3, r2
34001220:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34001222:	683b      	ldr	r3, [r7, #0]
34001224:	685b      	ldr	r3, [r3, #4]
34001226:	f003 0203 	and.w	r2, r3, #3
3400122a:	697b      	ldr	r3, [r7, #20]
3400122c:	005b      	lsls	r3, r3, #1
3400122e:	fa02 f303 	lsl.w	r3, r2, r3
34001232:	693a      	ldr	r2, [r7, #16]
34001234:	4313      	orrs	r3, r2
34001236:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34001238:	687b      	ldr	r3, [r7, #4]
3400123a:	693a      	ldr	r2, [r7, #16]
3400123c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
3400123e:	683b      	ldr	r3, [r7, #0]
34001240:	685b      	ldr	r3, [r3, #4]
34001242:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34001246:	2b00      	cmp	r3, #0
34001248:	f000 80c2 	beq.w	340013d0 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
3400124c:	4a69      	ldr	r2, [pc, #420]	@ (340013f4 <HAL_GPIO_Init+0x330>)
3400124e:	697b      	ldr	r3, [r7, #20]
34001250:	089b      	lsrs	r3, r3, #2
34001252:	3318      	adds	r3, #24
34001254:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34001258:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400125a:	697b      	ldr	r3, [r7, #20]
3400125c:	f003 0303 	and.w	r3, r3, #3
34001260:	00db      	lsls	r3, r3, #3
34001262:	220f      	movs	r2, #15
34001264:	fa02 f303 	lsl.w	r3, r2, r3
34001268:	43db      	mvns	r3, r3
3400126a:	693a      	ldr	r2, [r7, #16]
3400126c:	4013      	ands	r3, r2
3400126e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34001270:	687b      	ldr	r3, [r7, #4]
34001272:	4a61      	ldr	r2, [pc, #388]	@ (340013f8 <HAL_GPIO_Init+0x334>)
34001274:	4293      	cmp	r3, r2
34001276:	d043      	beq.n	34001300 <HAL_GPIO_Init+0x23c>
34001278:	687b      	ldr	r3, [r7, #4]
3400127a:	4a60      	ldr	r2, [pc, #384]	@ (340013fc <HAL_GPIO_Init+0x338>)
3400127c:	4293      	cmp	r3, r2
3400127e:	d03d      	beq.n	340012fc <HAL_GPIO_Init+0x238>
34001280:	687b      	ldr	r3, [r7, #4]
34001282:	4a5f      	ldr	r2, [pc, #380]	@ (34001400 <HAL_GPIO_Init+0x33c>)
34001284:	4293      	cmp	r3, r2
34001286:	d037      	beq.n	340012f8 <HAL_GPIO_Init+0x234>
34001288:	687b      	ldr	r3, [r7, #4]
3400128a:	4a5e      	ldr	r2, [pc, #376]	@ (34001404 <HAL_GPIO_Init+0x340>)
3400128c:	4293      	cmp	r3, r2
3400128e:	d031      	beq.n	340012f4 <HAL_GPIO_Init+0x230>
34001290:	687b      	ldr	r3, [r7, #4]
34001292:	4a5d      	ldr	r2, [pc, #372]	@ (34001408 <HAL_GPIO_Init+0x344>)
34001294:	4293      	cmp	r3, r2
34001296:	d02b      	beq.n	340012f0 <HAL_GPIO_Init+0x22c>
34001298:	687b      	ldr	r3, [r7, #4]
3400129a:	4a5c      	ldr	r2, [pc, #368]	@ (3400140c <HAL_GPIO_Init+0x348>)
3400129c:	4293      	cmp	r3, r2
3400129e:	d025      	beq.n	340012ec <HAL_GPIO_Init+0x228>
340012a0:	687b      	ldr	r3, [r7, #4]
340012a2:	4a5b      	ldr	r2, [pc, #364]	@ (34001410 <HAL_GPIO_Init+0x34c>)
340012a4:	4293      	cmp	r3, r2
340012a6:	d01f      	beq.n	340012e8 <HAL_GPIO_Init+0x224>
340012a8:	687b      	ldr	r3, [r7, #4]
340012aa:	4a5a      	ldr	r2, [pc, #360]	@ (34001414 <HAL_GPIO_Init+0x350>)
340012ac:	4293      	cmp	r3, r2
340012ae:	d019      	beq.n	340012e4 <HAL_GPIO_Init+0x220>
340012b0:	687b      	ldr	r3, [r7, #4]
340012b2:	4a59      	ldr	r2, [pc, #356]	@ (34001418 <HAL_GPIO_Init+0x354>)
340012b4:	4293      	cmp	r3, r2
340012b6:	d013      	beq.n	340012e0 <HAL_GPIO_Init+0x21c>
340012b8:	687b      	ldr	r3, [r7, #4]
340012ba:	4a58      	ldr	r2, [pc, #352]	@ (3400141c <HAL_GPIO_Init+0x358>)
340012bc:	4293      	cmp	r3, r2
340012be:	d00d      	beq.n	340012dc <HAL_GPIO_Init+0x218>
340012c0:	687b      	ldr	r3, [r7, #4]
340012c2:	4a57      	ldr	r2, [pc, #348]	@ (34001420 <HAL_GPIO_Init+0x35c>)
340012c4:	4293      	cmp	r3, r2
340012c6:	d007      	beq.n	340012d8 <HAL_GPIO_Init+0x214>
340012c8:	687b      	ldr	r3, [r7, #4]
340012ca:	4a56      	ldr	r2, [pc, #344]	@ (34001424 <HAL_GPIO_Init+0x360>)
340012cc:	4293      	cmp	r3, r2
340012ce:	d101      	bne.n	340012d4 <HAL_GPIO_Init+0x210>
340012d0:	230b      	movs	r3, #11
340012d2:	e016      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012d4:	2310      	movs	r3, #16
340012d6:	e014      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012d8:	230a      	movs	r3, #10
340012da:	e012      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012dc:	2309      	movs	r3, #9
340012de:	e010      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012e0:	2308      	movs	r3, #8
340012e2:	e00e      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012e4:	2307      	movs	r3, #7
340012e6:	e00c      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012e8:	2306      	movs	r3, #6
340012ea:	e00a      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012ec:	2305      	movs	r3, #5
340012ee:	e008      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012f0:	2304      	movs	r3, #4
340012f2:	e006      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012f4:	2303      	movs	r3, #3
340012f6:	e004      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012f8:	2302      	movs	r3, #2
340012fa:	e002      	b.n	34001302 <HAL_GPIO_Init+0x23e>
340012fc:	2301      	movs	r3, #1
340012fe:	e000      	b.n	34001302 <HAL_GPIO_Init+0x23e>
34001300:	2300      	movs	r3, #0
34001302:	697a      	ldr	r2, [r7, #20]
34001304:	f002 0203 	and.w	r2, r2, #3
34001308:	00d2      	lsls	r2, r2, #3
3400130a:	4093      	lsls	r3, r2
3400130c:	693a      	ldr	r2, [r7, #16]
3400130e:	4313      	orrs	r3, r2
34001310:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34001312:	4938      	ldr	r1, [pc, #224]	@ (340013f4 <HAL_GPIO_Init+0x330>)
34001314:	697b      	ldr	r3, [r7, #20]
34001316:	089b      	lsrs	r3, r3, #2
34001318:	3318      	adds	r3, #24
3400131a:	693a      	ldr	r2, [r7, #16]
3400131c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34001320:	4b34      	ldr	r3, [pc, #208]	@ (340013f4 <HAL_GPIO_Init+0x330>)
34001322:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34001326:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34001328:	68fb      	ldr	r3, [r7, #12]
3400132a:	43db      	mvns	r3, r3
3400132c:	693a      	ldr	r2, [r7, #16]
3400132e:	4013      	ands	r3, r2
34001330:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
34001332:	683b      	ldr	r3, [r7, #0]
34001334:	685b      	ldr	r3, [r3, #4]
34001336:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400133a:	2b00      	cmp	r3, #0
3400133c:	d003      	beq.n	34001346 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
3400133e:	693a      	ldr	r2, [r7, #16]
34001340:	68fb      	ldr	r3, [r7, #12]
34001342:	4313      	orrs	r3, r2
34001344:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34001346:	4a2b      	ldr	r2, [pc, #172]	@ (340013f4 <HAL_GPIO_Init+0x330>)
34001348:	693b      	ldr	r3, [r7, #16]
3400134a:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
3400134e:	4b29      	ldr	r3, [pc, #164]	@ (340013f4 <HAL_GPIO_Init+0x330>)
34001350:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34001354:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34001356:	68fb      	ldr	r3, [r7, #12]
34001358:	43db      	mvns	r3, r3
3400135a:	693a      	ldr	r2, [r7, #16]
3400135c:	4013      	ands	r3, r2
3400135e:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34001360:	683b      	ldr	r3, [r7, #0]
34001362:	685b      	ldr	r3, [r3, #4]
34001364:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34001368:	2b00      	cmp	r3, #0
3400136a:	d003      	beq.n	34001374 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
3400136c:	693a      	ldr	r2, [r7, #16]
3400136e:	68fb      	ldr	r3, [r7, #12]
34001370:	4313      	orrs	r3, r2
34001372:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
34001374:	4a1f      	ldr	r2, [pc, #124]	@ (340013f4 <HAL_GPIO_Init+0x330>)
34001376:	693b      	ldr	r3, [r7, #16]
34001378:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
3400137c:	4b1d      	ldr	r3, [pc, #116]	@ (340013f4 <HAL_GPIO_Init+0x330>)
3400137e:	681b      	ldr	r3, [r3, #0]
34001380:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34001382:	68fb      	ldr	r3, [r7, #12]
34001384:	43db      	mvns	r3, r3
34001386:	693a      	ldr	r2, [r7, #16]
34001388:	4013      	ands	r3, r2
3400138a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
3400138c:	683b      	ldr	r3, [r7, #0]
3400138e:	685b      	ldr	r3, [r3, #4]
34001390:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34001394:	2b00      	cmp	r3, #0
34001396:	d003      	beq.n	340013a0 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34001398:	693a      	ldr	r2, [r7, #16]
3400139a:	68fb      	ldr	r3, [r7, #12]
3400139c:	4313      	orrs	r3, r2
3400139e:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
340013a0:	4a14      	ldr	r2, [pc, #80]	@ (340013f4 <HAL_GPIO_Init+0x330>)
340013a2:	693b      	ldr	r3, [r7, #16]
340013a4:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
340013a6:	4b13      	ldr	r3, [pc, #76]	@ (340013f4 <HAL_GPIO_Init+0x330>)
340013a8:	685b      	ldr	r3, [r3, #4]
340013aa:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340013ac:	68fb      	ldr	r3, [r7, #12]
340013ae:	43db      	mvns	r3, r3
340013b0:	693a      	ldr	r2, [r7, #16]
340013b2:	4013      	ands	r3, r2
340013b4:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
340013b6:	683b      	ldr	r3, [r7, #0]
340013b8:	685b      	ldr	r3, [r3, #4]
340013ba:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
340013be:	2b00      	cmp	r3, #0
340013c0:	d003      	beq.n	340013ca <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
340013c2:	693a      	ldr	r2, [r7, #16]
340013c4:	68fb      	ldr	r3, [r7, #12]
340013c6:	4313      	orrs	r3, r2
340013c8:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
340013ca:	4a0a      	ldr	r2, [pc, #40]	@ (340013f4 <HAL_GPIO_Init+0x330>)
340013cc:	693b      	ldr	r3, [r7, #16]
340013ce:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
340013d0:	697b      	ldr	r3, [r7, #20]
340013d2:	3301      	adds	r3, #1
340013d4:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
340013d6:	683b      	ldr	r3, [r7, #0]
340013d8:	681a      	ldr	r2, [r3, #0]
340013da:	697b      	ldr	r3, [r7, #20]
340013dc:	fa22 f303 	lsr.w	r3, r2, r3
340013e0:	2b00      	cmp	r3, #0
340013e2:	f47f ae77 	bne.w	340010d4 <HAL_GPIO_Init+0x10>
  }
}
340013e6:	bf00      	nop
340013e8:	bf00      	nop
340013ea:	371c      	adds	r7, #28
340013ec:	46bd      	mov	sp, r7
340013ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340013f2:	4770      	bx	lr
340013f4:	56025000 	.word	0x56025000
340013f8:	56020000 	.word	0x56020000
340013fc:	56020400 	.word	0x56020400
34001400:	56020800 	.word	0x56020800
34001404:	56020c00 	.word	0x56020c00
34001408:	56021000 	.word	0x56021000
3400140c:	56021400 	.word	0x56021400
34001410:	56021800 	.word	0x56021800
34001414:	56021c00 	.word	0x56021c00
34001418:	56023400 	.word	0x56023400
3400141c:	56023800 	.word	0x56023800
34001420:	56023c00 	.word	0x56023c00
34001424:	56024000 	.word	0x56024000

34001428 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34001428:	b480      	push	{r7}
3400142a:	b083      	sub	sp, #12
3400142c:	af00      	add	r7, sp, #0
3400142e:	6078      	str	r0, [r7, #4]
34001430:	460b      	mov	r3, r1
34001432:	807b      	strh	r3, [r7, #2]
34001434:	4613      	mov	r3, r2
34001436:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34001438:	787b      	ldrb	r3, [r7, #1]
3400143a:	2b00      	cmp	r3, #0
3400143c:	d003      	beq.n	34001446 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
3400143e:	887a      	ldrh	r2, [r7, #2]
34001440:	687b      	ldr	r3, [r7, #4]
34001442:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34001444:	e002      	b.n	3400144c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34001446:	887a      	ldrh	r2, [r7, #2]
34001448:	687b      	ldr	r3, [r7, #4]
3400144a:	629a      	str	r2, [r3, #40]	@ 0x28
}
3400144c:	bf00      	nop
3400144e:	370c      	adds	r7, #12
34001450:	46bd      	mov	sp, r7
34001452:	f85d 7b04 	ldr.w	r7, [sp], #4
34001456:	4770      	bx	lr

34001458 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
34001458:	b480      	push	{r7}
3400145a:	b085      	sub	sp, #20
3400145c:	af00      	add	r7, sp, #0
3400145e:	6078      	str	r0, [r7, #4]
34001460:	460b      	mov	r3, r1
34001462:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
34001464:	687b      	ldr	r3, [r7, #4]
34001466:	695b      	ldr	r3, [r3, #20]
34001468:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
3400146a:	887a      	ldrh	r2, [r7, #2]
3400146c:	68fb      	ldr	r3, [r7, #12]
3400146e:	4013      	ands	r3, r2
34001470:	041a      	lsls	r2, r3, #16
34001472:	68fb      	ldr	r3, [r7, #12]
34001474:	43d9      	mvns	r1, r3
34001476:	887b      	ldrh	r3, [r7, #2]
34001478:	400b      	ands	r3, r1
3400147a:	431a      	orrs	r2, r3
3400147c:	687b      	ldr	r3, [r7, #4]
3400147e:	619a      	str	r2, [r3, #24]
}
34001480:	bf00      	nop
34001482:	3714      	adds	r7, #20
34001484:	46bd      	mov	sp, r7
34001486:	f85d 7b04 	ldr.w	r7, [sp], #4
3400148a:	4770      	bx	lr

3400148c <HAL_GPIO_ConfigPinAttributes>:
  *            @arg @ref GPIO_PIN_SEC          Secure-only access
  *            @arg @ref GPIO_PIN_NSEC         Secure/Non-secure access
  * @retval None.
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
3400148c:	b480      	push	{r7}
3400148e:	b087      	sub	sp, #28
34001490:	af00      	add	r7, sp, #0
34001492:	60f8      	str	r0, [r7, #12]
34001494:	460b      	mov	r3, r1
34001496:	607a      	str	r2, [r7, #4]
34001498:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

#if defined CPU_IN_SECURE_STATE
  /* Configure the port pins */
  sec = GPIOx->SECCFGR;
3400149a:	68fb      	ldr	r3, [r7, #12]
3400149c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400149e:	617b      	str	r3, [r7, #20]
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
340014a0:	687a      	ldr	r2, [r7, #4]
340014a2:	f240 1301 	movw	r3, #257	@ 0x101
340014a6:	4013      	ands	r3, r2
340014a8:	f240 1201 	movw	r2, #257	@ 0x101
340014ac:	4293      	cmp	r3, r2
340014ae:	d104      	bne.n	340014ba <HAL_GPIO_ConfigPinAttributes+0x2e>
  {
    sec |= (uint32_t)GPIO_Pin;
340014b0:	897b      	ldrh	r3, [r7, #10]
340014b2:	697a      	ldr	r2, [r7, #20]
340014b4:	4313      	orrs	r3, r2
340014b6:	617b      	str	r3, [r7, #20]
340014b8:	e009      	b.n	340014ce <HAL_GPIO_ConfigPinAttributes+0x42>
  }
  else if ((PinAttributes & GPIO_PIN_NSEC) == GPIO_PIN_NSEC)
340014ba:	687b      	ldr	r3, [r7, #4]
340014bc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340014c0:	2b00      	cmp	r3, #0
340014c2:	d004      	beq.n	340014ce <HAL_GPIO_ConfigPinAttributes+0x42>
  {
    sec &= ~((uint32_t)GPIO_Pin);
340014c4:	897b      	ldrh	r3, [r7, #10]
340014c6:	43db      	mvns	r3, r3
340014c8:	697a      	ldr	r2, [r7, #20]
340014ca:	4013      	ands	r3, r2
340014cc:	617b      	str	r3, [r7, #20]
  }
  else
  {
    /* do nothing */
  }
  GPIOx->SECCFGR = sec;
340014ce:	68fb      	ldr	r3, [r7, #12]
340014d0:	697a      	ldr	r2, [r7, #20]
340014d2:	631a      	str	r2, [r3, #48]	@ 0x30
#endif /* CPU_IN_SECURE_STATE */

  priv = GPIOx->PRIVCFGR;
340014d4:	68fb      	ldr	r3, [r7, #12]
340014d6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340014d8:	613b      	str	r3, [r7, #16]
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
340014da:	687a      	ldr	r2, [r7, #4]
340014dc:	f240 2302 	movw	r3, #514	@ 0x202
340014e0:	4013      	ands	r3, r2
340014e2:	f240 2202 	movw	r2, #514	@ 0x202
340014e6:	4293      	cmp	r3, r2
340014e8:	d104      	bne.n	340014f4 <HAL_GPIO_ConfigPinAttributes+0x68>
  {
    priv |= (uint32_t)GPIO_Pin;
340014ea:	897b      	ldrh	r3, [r7, #10]
340014ec:	693a      	ldr	r2, [r7, #16]
340014ee:	4313      	orrs	r3, r2
340014f0:	613b      	str	r3, [r7, #16]
340014f2:	e009      	b.n	34001508 <HAL_GPIO_ConfigPinAttributes+0x7c>
  }
  else if ((PinAttributes & GPIO_PIN_NPRIV) == GPIO_PIN_NPRIV)
340014f4:	687b      	ldr	r3, [r7, #4]
340014f6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340014fa:	2b00      	cmp	r3, #0
340014fc:	d004      	beq.n	34001508 <HAL_GPIO_ConfigPinAttributes+0x7c>
  {
    priv &= ~((uint32_t)GPIO_Pin);
340014fe:	897b      	ldrh	r3, [r7, #10]
34001500:	43db      	mvns	r3, r3
34001502:	693a      	ldr	r2, [r7, #16]
34001504:	4013      	ands	r3, r2
34001506:	613b      	str	r3, [r7, #16]
  else
  {
    /* do nothing */
  }

  GPIOx->PRIVCFGR = priv;
34001508:	68fb      	ldr	r3, [r7, #12]
3400150a:	693a      	ldr	r2, [r7, #16]
3400150c:	635a      	str	r2, [r3, #52]	@ 0x34
}
3400150e:	bf00      	nop
34001510:	371c      	adds	r7, #28
34001512:	46bd      	mov	sp, r7
34001514:	f85d 7b04 	ldr.w	r7, [sp], #4
34001518:	4770      	bx	lr
	...

3400151c <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
3400151c:	b480      	push	{r7}
3400151e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34001520:	4b05      	ldr	r3, [pc, #20]	@ (34001538 <HAL_PWREx_EnableVddIO2+0x1c>)
34001522:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34001524:	4a04      	ldr	r2, [pc, #16]	@ (34001538 <HAL_PWREx_EnableVddIO2+0x1c>)
34001526:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400152a:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400152c:	bf00      	nop
3400152e:	46bd      	mov	sp, r7
34001530:	f85d 7b04 	ldr.w	r7, [sp], #4
34001534:	4770      	bx	lr
34001536:	bf00      	nop
34001538:	56024800 	.word	0x56024800

3400153c <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
3400153c:	b480      	push	{r7}
3400153e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34001540:	4b05      	ldr	r3, [pc, #20]	@ (34001558 <HAL_PWREx_EnableVddIO3+0x1c>)
34001542:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34001544:	4a04      	ldr	r2, [pc, #16]	@ (34001558 <HAL_PWREx_EnableVddIO3+0x1c>)
34001546:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400154a:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400154c:	bf00      	nop
3400154e:	46bd      	mov	sp, r7
34001550:	f85d 7b04 	ldr.w	r7, [sp], #4
34001554:	4770      	bx	lr
34001556:	bf00      	nop
34001558:	56024800 	.word	0x56024800

3400155c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
3400155c:	b480      	push	{r7}
3400155e:	b083      	sub	sp, #12
34001560:	af00      	add	r7, sp, #0
34001562:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialise( pxList );

    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
34001564:	687b      	ldr	r3, [r7, #4]
34001566:	f103 0208 	add.w	r2, r3, #8
3400156a:	687b      	ldr	r3, [r7, #4]
3400156c:	605a      	str	r2, [r3, #4]

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
3400156e:	687b      	ldr	r3, [r7, #4]
34001570:	f04f 32ff 	mov.w	r2, #4294967295
34001574:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
34001576:	687b      	ldr	r3, [r7, #4]
34001578:	f103 0208 	add.w	r2, r3, #8
3400157c:	687b      	ldr	r3, [r7, #4]
3400157e:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
34001580:	687b      	ldr	r3, [r7, #4]
34001582:	f103 0208 	add.w	r2, r3, #8
34001586:	687b      	ldr	r3, [r7, #4]
34001588:	611a      	str	r2, [r3, #16]
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
3400158a:	687b      	ldr	r3, [r7, #4]
3400158c:	2200      	movs	r2, #0
3400158e:	601a      	str	r2, [r3, #0]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );

    traceRETURN_vListInitialise();
}
34001590:	bf00      	nop
34001592:	370c      	adds	r7, #12
34001594:	46bd      	mov	sp, r7
34001596:	f85d 7b04 	ldr.w	r7, [sp], #4
3400159a:	4770      	bx	lr

3400159c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
3400159c:	b480      	push	{r7}
3400159e:	b083      	sub	sp, #12
340015a0:	af00      	add	r7, sp, #0
340015a2:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialiseItem( pxItem );

    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
340015a4:	687b      	ldr	r3, [r7, #4]
340015a6:	2200      	movs	r2, #0
340015a8:	611a      	str	r2, [r3, #16]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );

    traceRETURN_vListInitialiseItem();
}
340015aa:	bf00      	nop
340015ac:	370c      	adds	r7, #12
340015ae:	46bd      	mov	sp, r7
340015b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340015b4:	4770      	bx	lr

340015b6 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
340015b6:	b480      	push	{r7}
340015b8:	b085      	sub	sp, #20
340015ba:	af00      	add	r7, sp, #0
340015bc:	6078      	str	r0, [r7, #4]
340015be:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
340015c0:	683b      	ldr	r3, [r7, #0]
340015c2:	681b      	ldr	r3, [r3, #0]
340015c4:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
340015c6:	68bb      	ldr	r3, [r7, #8]
340015c8:	f1b3 3fff 	cmp.w	r3, #4294967295
340015cc:	d103      	bne.n	340015d6 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
340015ce:	687b      	ldr	r3, [r7, #4]
340015d0:	691b      	ldr	r3, [r3, #16]
340015d2:	60fb      	str	r3, [r7, #12]
340015d4:	e00c      	b.n	340015f0 <vListInsert+0x3a>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
340015d6:	687b      	ldr	r3, [r7, #4]
340015d8:	3308      	adds	r3, #8
340015da:	60fb      	str	r3, [r7, #12]
340015dc:	e002      	b.n	340015e4 <vListInsert+0x2e>
340015de:	68fb      	ldr	r3, [r7, #12]
340015e0:	685b      	ldr	r3, [r3, #4]
340015e2:	60fb      	str	r3, [r7, #12]
340015e4:	68fb      	ldr	r3, [r7, #12]
340015e6:	685b      	ldr	r3, [r3, #4]
340015e8:	681b      	ldr	r3, [r3, #0]
340015ea:	68ba      	ldr	r2, [r7, #8]
340015ec:	429a      	cmp	r2, r3
340015ee:	d2f6      	bcs.n	340015de <vListInsert+0x28>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
340015f0:	68fb      	ldr	r3, [r7, #12]
340015f2:	685a      	ldr	r2, [r3, #4]
340015f4:	683b      	ldr	r3, [r7, #0]
340015f6:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
340015f8:	683b      	ldr	r3, [r7, #0]
340015fa:	685b      	ldr	r3, [r3, #4]
340015fc:	683a      	ldr	r2, [r7, #0]
340015fe:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
34001600:	683b      	ldr	r3, [r7, #0]
34001602:	68fa      	ldr	r2, [r7, #12]
34001604:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
34001606:	68fb      	ldr	r3, [r7, #12]
34001608:	683a      	ldr	r2, [r7, #0]
3400160a:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
3400160c:	683b      	ldr	r3, [r7, #0]
3400160e:	687a      	ldr	r2, [r7, #4]
34001610:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
34001612:	687b      	ldr	r3, [r7, #4]
34001614:	681b      	ldr	r3, [r3, #0]
34001616:	1c5a      	adds	r2, r3, #1
34001618:	687b      	ldr	r3, [r7, #4]
3400161a:	601a      	str	r2, [r3, #0]

    traceRETURN_vListInsert();
}
3400161c:	bf00      	nop
3400161e:	3714      	adds	r7, #20
34001620:	46bd      	mov	sp, r7
34001622:	f85d 7b04 	ldr.w	r7, [sp], #4
34001626:	4770      	bx	lr

34001628 <uxListRemove>:
/*-----------------------------------------------------------*/


UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
34001628:	b480      	push	{r7}
3400162a:	b085      	sub	sp, #20
3400162c:	af00      	add	r7, sp, #0
3400162e:	6078      	str	r0, [r7, #4]
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
34001630:	687b      	ldr	r3, [r7, #4]
34001632:	691b      	ldr	r3, [r3, #16]
34001634:	60fb      	str	r3, [r7, #12]

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
34001636:	687b      	ldr	r3, [r7, #4]
34001638:	685b      	ldr	r3, [r3, #4]
3400163a:	687a      	ldr	r2, [r7, #4]
3400163c:	6892      	ldr	r2, [r2, #8]
3400163e:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
34001640:	687b      	ldr	r3, [r7, #4]
34001642:	689b      	ldr	r3, [r3, #8]
34001644:	687a      	ldr	r2, [r7, #4]
34001646:	6852      	ldr	r2, [r2, #4]
34001648:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
3400164a:	68fb      	ldr	r3, [r7, #12]
3400164c:	685b      	ldr	r3, [r3, #4]
3400164e:	687a      	ldr	r2, [r7, #4]
34001650:	429a      	cmp	r2, r3
34001652:	d103      	bne.n	3400165c <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
34001654:	687b      	ldr	r3, [r7, #4]
34001656:	689a      	ldr	r2, [r3, #8]
34001658:	68fb      	ldr	r3, [r7, #12]
3400165a:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
3400165c:	687b      	ldr	r3, [r7, #4]
3400165e:	2200      	movs	r2, #0
34001660:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
34001662:	68fb      	ldr	r3, [r7, #12]
34001664:	681b      	ldr	r3, [r3, #0]
34001666:	1e5a      	subs	r2, r3, #1
34001668:	68fb      	ldr	r3, [r7, #12]
3400166a:	601a      	str	r2, [r3, #0]

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
3400166c:	68fb      	ldr	r3, [r7, #12]
3400166e:	681b      	ldr	r3, [r3, #0]
}
34001670:	4618      	mov	r0, r3
34001672:	3714      	adds	r7, #20
34001674:	46bd      	mov	sp, r7
34001676:	f85d 7b04 	ldr.w	r7, [sp], #4
3400167a:	4770      	bx	lr

3400167c <vPortSetupTimerInterrupt>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
{
3400167c:	b480      	push	{r7}
3400167e:	af00      	add	r7, sp, #0
     * enable SysTick without first selecting a valid clock source. We trigger
     * the bug if we change clock sources from a clock with a zero clock period
     * to one with a nonzero clock period and enable Systick at the same time.
     * So we configure the CLKSOURCE bit here, prior to setting the ENABLE bit.
     * This workaround avoids the bug in QEMU versions older than 7.0.0. */
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG;
34001680:	4b0b      	ldr	r3, [pc, #44]	@ (340016b0 <vPortSetupTimerInterrupt+0x34>)
34001682:	2204      	movs	r2, #4
34001684:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
34001686:	4b0b      	ldr	r3, [pc, #44]	@ (340016b4 <vPortSetupTimerInterrupt+0x38>)
34001688:	2200      	movs	r2, #0
3400168a:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
3400168c:	4b0a      	ldr	r3, [pc, #40]	@ (340016b8 <vPortSetupTimerInterrupt+0x3c>)
3400168e:	681b      	ldr	r3, [r3, #0]
34001690:	4a0a      	ldr	r2, [pc, #40]	@ (340016bc <vPortSetupTimerInterrupt+0x40>)
34001692:	fba2 2303 	umull	r2, r3, r2, r3
34001696:	099b      	lsrs	r3, r3, #6
34001698:	4a09      	ldr	r2, [pc, #36]	@ (340016c0 <vPortSetupTimerInterrupt+0x44>)
3400169a:	3b01      	subs	r3, #1
3400169c:	6013      	str	r3, [r2, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
3400169e:	4b04      	ldr	r3, [pc, #16]	@ (340016b0 <vPortSetupTimerInterrupt+0x34>)
340016a0:	2207      	movs	r2, #7
340016a2:	601a      	str	r2, [r3, #0]
}
340016a4:	bf00      	nop
340016a6:	46bd      	mov	sp, r7
340016a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340016ac:	4770      	bx	lr
340016ae:	bf00      	nop
340016b0:	e000e010 	.word	0xe000e010
340016b4:	e000e018 	.word	0xe000e018
340016b8:	34003c30 	.word	0x34003c30
340016bc:	10624dd3 	.word	0x10624dd3
340016c0:	e000e014 	.word	0xe000e014

340016c4 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
340016c4:	b580      	push	{r7, lr}
340016c6:	b082      	sub	sp, #8
340016c8:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
340016ca:	2300      	movs	r3, #0
340016cc:	607b      	str	r3, [r7, #4]
    /* A function that implements a task must not exit or attempt to return to
     * its caller as there is nothing to return to. If a task wants to exit it
     * should instead call vTaskDelete( NULL ). Artificially force an assert()
     * to be triggered if configASSERT() is defined, then stop here so
     * application writers can catch the error. */
    configASSERT( ulCriticalNesting == ~0UL );
340016ce:	4b0a      	ldr	r3, [pc, #40]	@ (340016f8 <prvTaskExitError+0x34>)
340016d0:	681b      	ldr	r3, [r3, #0]
340016d2:	f1b3 3fff 	cmp.w	r3, #4294967295
340016d6:	d003      	beq.n	340016e0 <prvTaskExitError+0x1c>
340016d8:	f000 f9e0 	bl	34001a9c <ulSetInterruptMask>
340016dc:	bf00      	nop
340016de:	e7fd      	b.n	340016dc <prvTaskExitError+0x18>
    portDISABLE_INTERRUPTS();
340016e0:	f000 f9dc 	bl	34001a9c <ulSetInterruptMask>

    while( ulDummy == 0 )
340016e4:	bf00      	nop
340016e6:	687b      	ldr	r3, [r7, #4]
340016e8:	2b00      	cmp	r3, #0
340016ea:	d0fc      	beq.n	340016e6 <prvTaskExitError+0x22>
         * warnings about code appearing after this function is called - making
         * ulDummy volatile makes the compiler think the function could return
         * and therefore not output an 'unreachable code' warning for code that
         * appears after it. */
    }
}
340016ec:	bf00      	nop
340016ee:	bf00      	nop
340016f0:	3708      	adds	r7, #8
340016f2:	46bd      	mov	sp, r7
340016f4:	bd80      	pop	{r7, pc}
340016f6:	bf00      	nop
340016f8:	34003c3c 	.word	0x34003c3c

340016fc <prvSetupFPU>:
/*-----------------------------------------------------------*/

#if ( configENABLE_FPU == 1 )

    static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
    {
340016fc:	b480      	push	{r7}
340016fe:	af00      	add	r7, sp, #0
        #endif /* configENABLE_TRUSTZONE */

        /* CP10 = 11 ==> Full access to FPU i.e. both privileged and
         * unprivileged code should be able to access FPU. CP11 should be
         * programmed to the same value as CP10. */
        *( portCPACR ) |= ( ( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
34001700:	4b08      	ldr	r3, [pc, #32]	@ (34001724 <prvSetupFPU+0x28>)
34001702:	681b      	ldr	r3, [r3, #0]
34001704:	4a07      	ldr	r2, [pc, #28]	@ (34001724 <prvSetupFPU+0x28>)
34001706:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
3400170a:	6013      	str	r3, [r2, #0]
                            );

        /* ASPEN = 1 ==> Hardware should automatically preserve floating point
         * context on exception entry and restore on exception return.
         * LSPEN = 1 ==> Enable lazy context save of FP state. */
        *( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
3400170c:	4b06      	ldr	r3, [pc, #24]	@ (34001728 <prvSetupFPU+0x2c>)
3400170e:	681b      	ldr	r3, [r3, #0]
34001710:	4a05      	ldr	r2, [pc, #20]	@ (34001728 <prvSetupFPU+0x2c>)
34001712:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
34001716:	6013      	str	r3, [r2, #0]
    }
34001718:	bf00      	nop
3400171a:	46bd      	mov	sp, r7
3400171c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001720:	4770      	bx	lr
34001722:	bf00      	nop
34001724:	e000ed88 	.word	0xe000ed88
34001728:	e000ef34 	.word	0xe000ef34

3400172c <vPortYield>:

#endif /* configENABLE_FPU */
/*-----------------------------------------------------------*/

void vPortYield( void ) /* PRIVILEGED_FUNCTION */
{
3400172c:	b480      	push	{r7}
3400172e:	af00      	add	r7, sp, #0
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
34001730:	4b06      	ldr	r3, [pc, #24]	@ (3400174c <vPortYield+0x20>)
34001732:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34001736:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is
     * completely within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
34001738:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
3400173c:	f3bf 8f6f 	isb	sy
}
34001740:	bf00      	nop
34001742:	46bd      	mov	sp, r7
34001744:	f85d 7b04 	ldr.w	r7, [sp], #4
34001748:	4770      	bx	lr
3400174a:	bf00      	nop
3400174c:	e000ed04 	.word	0xe000ed04

34001750 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
{
34001750:	b580      	push	{r7, lr}
34001752:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
34001754:	f000 f9a2 	bl	34001a9c <ulSetInterruptMask>
    ulCriticalNesting++;
34001758:	4b05      	ldr	r3, [pc, #20]	@ (34001770 <vPortEnterCritical+0x20>)
3400175a:	681b      	ldr	r3, [r3, #0]
3400175c:	3301      	adds	r3, #1
3400175e:	4a04      	ldr	r2, [pc, #16]	@ (34001770 <vPortEnterCritical+0x20>)
34001760:	6013      	str	r3, [r2, #0]

    /* Barriers are normally not required but do ensure the code is
     * completely within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
34001762:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
34001766:	f3bf 8f6f 	isb	sy
}
3400176a:	bf00      	nop
3400176c:	bd80      	pop	{r7, pc}
3400176e:	bf00      	nop
34001770:	34003c3c 	.word	0x34003c3c

34001774 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
{
34001774:	b580      	push	{r7, lr}
34001776:	af00      	add	r7, sp, #0
    configASSERT( ulCriticalNesting );
34001778:	4b0a      	ldr	r3, [pc, #40]	@ (340017a4 <vPortExitCritical+0x30>)
3400177a:	681b      	ldr	r3, [r3, #0]
3400177c:	2b00      	cmp	r3, #0
3400177e:	d103      	bne.n	34001788 <vPortExitCritical+0x14>
34001780:	f000 f98c 	bl	34001a9c <ulSetInterruptMask>
34001784:	bf00      	nop
34001786:	e7fd      	b.n	34001784 <vPortExitCritical+0x10>
    ulCriticalNesting--;
34001788:	4b06      	ldr	r3, [pc, #24]	@ (340017a4 <vPortExitCritical+0x30>)
3400178a:	681b      	ldr	r3, [r3, #0]
3400178c:	3b01      	subs	r3, #1
3400178e:	4a05      	ldr	r2, [pc, #20]	@ (340017a4 <vPortExitCritical+0x30>)
34001790:	6013      	str	r3, [r2, #0]

    if( ulCriticalNesting == 0 )
34001792:	4b04      	ldr	r3, [pc, #16]	@ (340017a4 <vPortExitCritical+0x30>)
34001794:	681b      	ldr	r3, [r3, #0]
34001796:	2b00      	cmp	r3, #0
34001798:	d102      	bne.n	340017a0 <vPortExitCritical+0x2c>
    {
        portENABLE_INTERRUPTS();
3400179a:	2000      	movs	r0, #0
3400179c:	f000 f98b 	bl	34001ab6 <vClearInterruptMask>
    }
}
340017a0:	bf00      	nop
340017a2:	bd80      	pop	{r7, pc}
340017a4:	34003c3c 	.word	0x34003c3c

340017a8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
{
340017a8:	b580      	push	{r7, lr}
340017aa:	b082      	sub	sp, #8
340017ac:	af00      	add	r7, sp, #0
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
340017ae:	f000 f975 	bl	34001a9c <ulSetInterruptMask>
340017b2:	6078      	str	r0, [r7, #4]
    traceISR_ENTER();
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
340017b4:	f001 f834 	bl	34002820 <xTaskIncrementTick>
340017b8:	4603      	mov	r3, r0
340017ba:	2b00      	cmp	r3, #0
340017bc:	d003      	beq.n	340017c6 <xPortSysTickHandler+0x1e>
        {
            traceISR_EXIT_TO_SCHEDULER();
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
340017be:	4b05      	ldr	r3, [pc, #20]	@ (340017d4 <xPortSysTickHandler+0x2c>)
340017c0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
340017c4:	601a      	str	r2, [r3, #0]
        else
        {
            traceISR_EXIT();
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
340017c6:	6878      	ldr	r0, [r7, #4]
340017c8:	f000 f975 	bl	34001ab6 <vClearInterruptMask>
}
340017cc:	bf00      	nop
340017ce:	3708      	adds	r7, #8
340017d0:	46bd      	mov	sp, r7
340017d2:	bd80      	pop	{r7, pc}
340017d4:	e000ed04 	.word	0xe000ed04

340017d8 <vPortSVCHandler_C>:
/*-----------------------------------------------------------*/

void vPortSVCHandler_C( uint32_t * pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
{
340017d8:	b580      	push	{r7, lr}
340017da:	b084      	sub	sp, #16
340017dc:	af00      	add	r7, sp, #0
340017de:	6078      	str	r0, [r7, #4]
    #endif /* configENABLE_TRUSTZONE */
    uint8_t ucSVCNumber;

    /* Register are stored on the stack in the following order - R0, R1, R2, R3,
     * R12, LR, PC, xPSR. */
    ulPC = pulCallerStackAddress[ portOFFSET_TO_PC ];
340017e0:	687b      	ldr	r3, [r7, #4]
340017e2:	699b      	ldr	r3, [r3, #24]
340017e4:	60fb      	str	r3, [r7, #12]
    ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
340017e6:	68fb      	ldr	r3, [r7, #12]
340017e8:	3b02      	subs	r3, #2
340017ea:	781b      	ldrb	r3, [r3, #0]
340017ec:	72fb      	strb	r3, [r7, #11]

    switch( ucSVCNumber )
340017ee:	7afb      	ldrb	r3, [r7, #11]
340017f0:	2b66      	cmp	r3, #102	@ 0x66
340017f2:	d104      	bne.n	340017fe <vPortSVCHandler_C+0x26>
            #endif /* configENABLE_TRUSTZONE */

            #if ( configENABLE_FPU == 1 )
            {
                /* Setup the Floating Point Unit (FPU). */
                prvSetupFPU();
340017f4:	f7ff ff82 	bl	340016fc <prvSetupFPU>
            }
            #endif /* configENABLE_FPU */

            /* Setup the context of the first task so that the first task starts
             * executing. */
            vRestoreContextOfFirstTask();
340017f8:	f000 f92a 	bl	34001a50 <vRestoreContextOfFirstTask>
            break;
340017fc:	e003      	b.n	34001806 <vPortSVCHandler_C+0x2e>
                    break;
            #endif /* configENABLE_MPU == 1 */

        default:
            /* Incorrect SVC call. */
            configASSERT( pdFALSE );
340017fe:	f000 f94d 	bl	34001a9c <ulSetInterruptMask>
34001802:	bf00      	nop
34001804:	e7fd      	b.n	34001802 <vPortSVCHandler_C+0x2a>
    }
}
34001806:	bf00      	nop
34001808:	3710      	adds	r7, #16
3400180a:	46bd      	mov	sp, r7
3400180c:	bd80      	pop	{r7, pc}
	...

34001810 <pxPortInitialiseStack>:

    StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                         StackType_t * pxEndOfStack,
                                         TaskFunction_t pxCode,
                                         void * pvParameters ) /* PRIVILEGED_FUNCTION */
    {
34001810:	b480      	push	{r7}
34001812:	b085      	sub	sp, #20
34001814:	af00      	add	r7, sp, #0
34001816:	60f8      	str	r0, [r7, #12]
34001818:	60b9      	str	r1, [r7, #8]
3400181a:	607a      	str	r2, [r7, #4]
3400181c:	603b      	str	r3, [r7, #0]
            }
            #endif /* configENABLE_TRUSTZONE */
        }
        #else /* portPRELOAD_REGISTERS */
        {
            pxTopOfStack--;                                          /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
3400181e:	68fb      	ldr	r3, [r7, #12]
34001820:	3b04      	subs	r3, #4
34001822:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR. */
34001824:	68fb      	ldr	r3, [r7, #12]
34001826:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400182a:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
3400182c:	68fb      	ldr	r3, [r7, #12]
3400182e:	3b04      	subs	r3, #4
34001830:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC. */
34001832:	687a      	ldr	r2, [r7, #4]
34001834:	68fb      	ldr	r3, [r7, #12]
34001836:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001838:	68fb      	ldr	r3, [r7, #12]
3400183a:	3b04      	subs	r3, #4
3400183c:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
3400183e:	4a38      	ldr	r2, [pc, #224]	@ (34001920 <pxPortInitialiseStack+0x110>)
34001840:	68fb      	ldr	r3, [r7, #12]
34001842:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001844:	68fb      	ldr	r3, [r7, #12]
34001846:	3b04      	subs	r3, #4
34001848:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x12121212UL;            /* R12. */
3400184a:	68fb      	ldr	r3, [r7, #12]
3400184c:	f04f 3212 	mov.w	r2, #303174162	@ 0x12121212
34001850:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001852:	68fb      	ldr	r3, [r7, #12]
34001854:	3b04      	subs	r3, #4
34001856:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x03030303UL;            /* R3. */
34001858:	68fb      	ldr	r3, [r7, #12]
3400185a:	f04f 3203 	mov.w	r2, #50529027	@ 0x3030303
3400185e:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001860:	68fb      	ldr	r3, [r7, #12]
34001862:	3b04      	subs	r3, #4
34001864:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x02020202UL;            /* R2. */
34001866:	68fb      	ldr	r3, [r7, #12]
34001868:	f04f 3202 	mov.w	r2, #33686018	@ 0x2020202
3400186c:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
3400186e:	68fb      	ldr	r3, [r7, #12]
34001870:	3b04      	subs	r3, #4
34001872:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x01010101UL;            /* R1. */
34001874:	68fb      	ldr	r3, [r7, #12]
34001876:	f04f 3201 	mov.w	r2, #16843009	@ 0x1010101
3400187a:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
3400187c:	68fb      	ldr	r3, [r7, #12]
3400187e:	3b04      	subs	r3, #4
34001880:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0. */
34001882:	683a      	ldr	r2, [r7, #0]
34001884:	68fb      	ldr	r3, [r7, #12]
34001886:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001888:	68fb      	ldr	r3, [r7, #12]
3400188a:	3b04      	subs	r3, #4
3400188c:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x11111111UL;            /* R11. */
3400188e:	68fb      	ldr	r3, [r7, #12]
34001890:	f04f 3211 	mov.w	r2, #286331153	@ 0x11111111
34001894:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001896:	68fb      	ldr	r3, [r7, #12]
34001898:	3b04      	subs	r3, #4
3400189a:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x10101010UL;            /* R10. */
3400189c:	68fb      	ldr	r3, [r7, #12]
3400189e:	f04f 3210 	mov.w	r2, #269488144	@ 0x10101010
340018a2:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018a4:	68fb      	ldr	r3, [r7, #12]
340018a6:	3b04      	subs	r3, #4
340018a8:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x09090909UL;            /* R09. */
340018aa:	68fb      	ldr	r3, [r7, #12]
340018ac:	f04f 3209 	mov.w	r2, #151587081	@ 0x9090909
340018b0:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018b2:	68fb      	ldr	r3, [r7, #12]
340018b4:	3b04      	subs	r3, #4
340018b6:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x08080808UL;            /* R08. */
340018b8:	68fb      	ldr	r3, [r7, #12]
340018ba:	f04f 3208 	mov.w	r2, #134744072	@ 0x8080808
340018be:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018c0:	68fb      	ldr	r3, [r7, #12]
340018c2:	3b04      	subs	r3, #4
340018c4:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x07070707UL;            /* R07. */
340018c6:	68fb      	ldr	r3, [r7, #12]
340018c8:	f04f 3207 	mov.w	r2, #117901063	@ 0x7070707
340018cc:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018ce:	68fb      	ldr	r3, [r7, #12]
340018d0:	3b04      	subs	r3, #4
340018d2:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x06060606UL;            /* R06. */
340018d4:	68fb      	ldr	r3, [r7, #12]
340018d6:	f04f 3206 	mov.w	r2, #101058054	@ 0x6060606
340018da:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018dc:	68fb      	ldr	r3, [r7, #12]
340018de:	3b04      	subs	r3, #4
340018e0:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x05050505UL;            /* R05. */
340018e2:	68fb      	ldr	r3, [r7, #12]
340018e4:	f04f 3205 	mov.w	r2, #84215045	@ 0x5050505
340018e8:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018ea:	68fb      	ldr	r3, [r7, #12]
340018ec:	3b04      	subs	r3, #4
340018ee:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) 0x04040404UL;            /* R04. */
340018f0:	68fb      	ldr	r3, [r7, #12]
340018f2:	f04f 3204 	mov.w	r2, #67372036	@ 0x4040404
340018f6:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
340018f8:	68fb      	ldr	r3, [r7, #12]
340018fa:	3b04      	subs	r3, #4
340018fc:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = portINITIAL_EXC_RETURN;                  /* EXC_RETURN. */
340018fe:	68fb      	ldr	r3, [r7, #12]
34001900:	f06f 0202 	mvn.w	r2, #2
34001904:	601a      	str	r2, [r3, #0]
            pxTopOfStack--;
34001906:	68fb      	ldr	r3, [r7, #12]
34001908:	3b04      	subs	r3, #4
3400190a:	60fb      	str	r3, [r7, #12]
            *pxTopOfStack = ( StackType_t ) pxEndOfStack;            /* Slot used to hold this task's PSPLIM value. */
3400190c:	68ba      	ldr	r2, [r7, #8]
3400190e:	68fb      	ldr	r3, [r7, #12]
34001910:	601a      	str	r2, [r3, #0]
            }
            #endif /* configENABLE_TRUSTZONE */
        }
        #endif /* portPRELOAD_REGISTERS */

        return pxTopOfStack;
34001912:	68fb      	ldr	r3, [r7, #12]
    }
34001914:	4618      	mov	r0, r3
34001916:	3714      	adds	r7, #20
34001918:	46bd      	mov	sp, r7
3400191a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400191e:	4770      	bx	lr
34001920:	340016c5 	.word	0x340016c5

34001924 <xPortStartScheduler>:

#endif /* configENABLE_MPU */
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
{
34001924:	b580      	push	{r7, lr}
34001926:	b084      	sub	sp, #16
34001928:	af00      	add	r7, sp, #0
     * configCHECK_HANDLER_INSTALLATION to 0 in their FreeRTOSConfig.h. Direct
     * routing, which is validated here when configCHECK_HANDLER_INSTALLATION
     * is 1, should be preferred when possible. */
    #if ( configCHECK_HANDLER_INSTALLATION == 1 )
    {
        const portISR_t * const pxVectorTable = portSCB_VTOR_REG;
3400192a:	4b41      	ldr	r3, [pc, #260]	@ (34001a30 <xPortStartScheduler+0x10c>)
3400192c:	681b      	ldr	r3, [r3, #0]
3400192e:	60fb      	str	r3, [r7, #12]
         * https://www.FreeRTOS.org/FAQHelp.html.
         *
         * Systems with a configurable address for the interrupt vector table
         * can also encounter assertion failures or even system faults here if
         * VTOR is not set correctly to point to the application's vector table. */
        configASSERT( pxVectorTable[ portVECTOR_INDEX_SVC ] == SVC_Handler );
34001930:	68fb      	ldr	r3, [r7, #12]
34001932:	332c      	adds	r3, #44	@ 0x2c
34001934:	681b      	ldr	r3, [r3, #0]
34001936:	4a3f      	ldr	r2, [pc, #252]	@ (34001a34 <xPortStartScheduler+0x110>)
34001938:	4293      	cmp	r3, r2
3400193a:	d003      	beq.n	34001944 <xPortStartScheduler+0x20>
3400193c:	f000 f8ae 	bl	34001a9c <ulSetInterruptMask>
34001940:	bf00      	nop
34001942:	e7fd      	b.n	34001940 <xPortStartScheduler+0x1c>
        configASSERT( pxVectorTable[ portVECTOR_INDEX_PENDSV ] == PendSV_Handler );
34001944:	68fb      	ldr	r3, [r7, #12]
34001946:	3338      	adds	r3, #56	@ 0x38
34001948:	681b      	ldr	r3, [r3, #0]
3400194a:	4a3b      	ldr	r2, [pc, #236]	@ (34001a38 <xPortStartScheduler+0x114>)
3400194c:	4293      	cmp	r3, r2
3400194e:	d003      	beq.n	34001958 <xPortStartScheduler+0x34>
34001950:	f000 f8a4 	bl	34001a9c <ulSetInterruptMask>
34001954:	bf00      	nop
34001956:	e7fd      	b.n	34001954 <xPortStartScheduler+0x30>
    }
    #endif /* configCHECK_HANDLER_INSTALLATION */

    #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_ARMV8M_MAIN_EXTENSION == 1 ) )
    {
        volatile uint32_t ulImplementedPrioBits = 0;
34001958:	2300      	movs	r3, #0
3400195a:	60bb      	str	r3, [r7, #8]
         * "FromISR". FreeRTOS maintains separate thread and ISR API functions to
         * ensure interrupt entry is as fast and simple as possible.
         *
         * First, determine the number of priority bits available. Write to all
         * possible bits in the priority setting for SVCall. */
        portNVIC_SHPR2_REG = 0xFF000000;
3400195c:	4b37      	ldr	r3, [pc, #220]	@ (34001a3c <xPortStartScheduler+0x118>)
3400195e:	f04f 427f 	mov.w	r2, #4278190080	@ 0xff000000
34001962:	601a      	str	r2, [r3, #0]

        /* Read the value back to see how many bits stuck. */
        ucMaxPriorityValue = ( uint8_t ) ( ( portNVIC_SHPR2_REG & 0xFF000000 ) >> 24 );
34001964:	4b35      	ldr	r3, [pc, #212]	@ (34001a3c <xPortStartScheduler+0x118>)
34001966:	681b      	ldr	r3, [r3, #0]
34001968:	0e1b      	lsrs	r3, r3, #24
3400196a:	b2db      	uxtb	r3, r3
3400196c:	71fb      	strb	r3, [r7, #7]

        /* Use the same mask on the maximum system call priority. */
        ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
3400196e:	79fb      	ldrb	r3, [r7, #7]
34001970:	b2db      	uxtb	r3, r3
34001972:	f003 0350 	and.w	r3, r3, #80	@ 0x50
34001976:	b2da      	uxtb	r2, r3
34001978:	4b31      	ldr	r3, [pc, #196]	@ (34001a40 <xPortStartScheduler+0x11c>)
3400197a:	701a      	strb	r2, [r3, #0]
         * accounting for the number of priority bits supported by the
         * hardware. A priority of 0 is invalid because setting the BASEPRI
         * register to 0 unmasks all interrupts, and interrupts with priority 0
         * cannot be masked using BASEPRI.
         * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        configASSERT( ucMaxSysCallPriority );
3400197c:	4b30      	ldr	r3, [pc, #192]	@ (34001a40 <xPortStartScheduler+0x11c>)
3400197e:	781b      	ldrb	r3, [r3, #0]
34001980:	2b00      	cmp	r3, #0
34001982:	d103      	bne.n	3400198c <xPortStartScheduler+0x68>
34001984:	f000 f88a 	bl	34001a9c <ulSetInterruptMask>
34001988:	bf00      	nop
3400198a:	e7fd      	b.n	34001988 <xPortStartScheduler+0x64>

        /* Check that the bits not implemented in hardware are zero in
         * configMAX_SYSCALL_INTERRUPT_PRIORITY. */
        configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & ( uint8_t ) ( ~( uint32_t ) ucMaxPriorityValue ) ) == 0U );
3400198c:	79fb      	ldrb	r3, [r7, #7]
3400198e:	b2db      	uxtb	r3, r3
34001990:	43db      	mvns	r3, r3
34001992:	b2db      	uxtb	r3, r3
34001994:	f003 0350 	and.w	r3, r3, #80	@ 0x50
34001998:	b2db      	uxtb	r3, r3
3400199a:	2b00      	cmp	r3, #0
3400199c:	d00b      	beq.n	340019b6 <xPortStartScheduler+0x92>
3400199e:	f000 f87d 	bl	34001a9c <ulSetInterruptMask>
340019a2:	bf00      	nop
340019a4:	e7fd      	b.n	340019a2 <xPortStartScheduler+0x7e>

        /* Calculate the maximum acceptable priority group value for the number
         * of bits read back. */
        while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
        {
            ulImplementedPrioBits++;
340019a6:	68bb      	ldr	r3, [r7, #8]
340019a8:	3301      	adds	r3, #1
340019aa:	60bb      	str	r3, [r7, #8]
            ucMaxPriorityValue <<= ( uint8_t ) 0x01;
340019ac:	79fb      	ldrb	r3, [r7, #7]
340019ae:	b2db      	uxtb	r3, r3
340019b0:	005b      	lsls	r3, r3, #1
340019b2:	b2db      	uxtb	r3, r3
340019b4:	71fb      	strb	r3, [r7, #7]
        while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
340019b6:	79fb      	ldrb	r3, [r7, #7]
340019b8:	b2db      	uxtb	r3, r3
340019ba:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340019be:	2b80      	cmp	r3, #128	@ 0x80
340019c0:	d0f1      	beq.n	340019a6 <xPortStartScheduler+0x82>
        }

        if( ulImplementedPrioBits == 8 )
340019c2:	68bb      	ldr	r3, [r7, #8]
340019c4:	2b08      	cmp	r3, #8
340019c6:	d103      	bne.n	340019d0 <xPortStartScheduler+0xac>
             *
             * The following assert ensures that the sub-priority bit in the
             * configMAX_SYSCALL_INTERRUPT_PRIORITY is clear to avoid the above mentioned
             * confusion. */
            configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & 0x1U ) == 0U );
            ulMaxPRIGROUPValue = 0;
340019c8:	4b1e      	ldr	r3, [pc, #120]	@ (34001a44 <xPortStartScheduler+0x120>)
340019ca:	2200      	movs	r2, #0
340019cc:	601a      	str	r2, [r3, #0]
340019ce:	e004      	b.n	340019da <xPortStartScheduler+0xb6>
        }
        else
        {
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS - ulImplementedPrioBits;
340019d0:	68bb      	ldr	r3, [r7, #8]
340019d2:	f1c3 0307 	rsb	r3, r3, #7
340019d6:	4a1b      	ldr	r2, [pc, #108]	@ (34001a44 <xPortStartScheduler+0x120>)
340019d8:	6013      	str	r3, [r2, #0]
        }

        /* Shift the priority group value back to its position within the AIRCR
         * register. */
        ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
340019da:	4b1a      	ldr	r3, [pc, #104]	@ (34001a44 <xPortStartScheduler+0x120>)
340019dc:	681b      	ldr	r3, [r3, #0]
340019de:	021b      	lsls	r3, r3, #8
340019e0:	4a18      	ldr	r2, [pc, #96]	@ (34001a44 <xPortStartScheduler+0x120>)
340019e2:	6013      	str	r3, [r2, #0]
        ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
340019e4:	4b17      	ldr	r3, [pc, #92]	@ (34001a44 <xPortStartScheduler+0x120>)
340019e6:	681b      	ldr	r3, [r3, #0]
340019e8:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
340019ec:	4a15      	ldr	r2, [pc, #84]	@ (34001a44 <xPortStartScheduler+0x120>)
340019ee:	6013      	str	r3, [r2, #0]
    }
    #endif /* #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_ARMV8M_MAIN_EXTENSION == 1 ) ) */

    /* Make PendSV and SysTick the lowest priority interrupts, and make SVCall
     * the highest priority. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
340019f0:	4b15      	ldr	r3, [pc, #84]	@ (34001a48 <xPortStartScheduler+0x124>)
340019f2:	681b      	ldr	r3, [r3, #0]
340019f4:	4a14      	ldr	r2, [pc, #80]	@ (34001a48 <xPortStartScheduler+0x124>)
340019f6:	f443 037f 	orr.w	r3, r3, #16711680	@ 0xff0000
340019fa:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
340019fc:	4b12      	ldr	r3, [pc, #72]	@ (34001a48 <xPortStartScheduler+0x124>)
340019fe:	681b      	ldr	r3, [r3, #0]
34001a00:	4a11      	ldr	r2, [pc, #68]	@ (34001a48 <xPortStartScheduler+0x124>)
34001a02:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34001a06:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR2_REG = 0;
34001a08:	4b0c      	ldr	r3, [pc, #48]	@ (34001a3c <xPortStartScheduler+0x118>)
34001a0a:	2200      	movs	r2, #0
34001a0c:	601a      	str	r2, [r3, #0]
    }
    #endif /* configENABLE_MPU */

    /* Start the timer that generates the tick ISR. Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
34001a0e:	f7ff fe35 	bl	3400167c <vPortSetupTimerInterrupt>

    /* Initialize the critical nesting count ready for the first task. */
    ulCriticalNesting = 0;
34001a12:	4b0e      	ldr	r3, [pc, #56]	@ (34001a4c <xPortStartScheduler+0x128>)
34001a14:	2200      	movs	r2, #0
34001a16:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
    }
    #endif /* ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) ) */

    /* Start the first task. */
    vStartFirstTask();
34001a18:	f000 f830 	bl	34001a7c <vStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS. Call
     * vTaskSwitchContext() so link time optimization does not remove the
     * symbol. */
    vTaskSwitchContext();
34001a1c:	f001 f812 	bl	34002a44 <vTaskSwitchContext>
    prvTaskExitError();
34001a20:	f7ff fe50 	bl	340016c4 <prvTaskExitError>

    /* Should not get here. */
    return 0;
34001a24:	2300      	movs	r3, #0
}
34001a26:	4618      	mov	r0, r3
34001a28:	3710      	adds	r7, #16
34001a2a:	46bd      	mov	sp, r7
34001a2c:	bd80      	pop	{r7, pc}
34001a2e:	bf00      	nop
34001a30:	e000ed08 	.word	0xe000ed08
34001a34:	34001b29 	.word	0x34001b29
34001a38:	34001ac9 	.word	0x34001ac9
34001a3c:	e000ed1c 	.word	0xe000ed1c
34001a40:	34003c88 	.word	0x34003c88
34001a44:	34003c8c 	.word	0x34003c8c
34001a48:	e000ed20 	.word	0xe000ed20
34001a4c:	34003c3c 	.word	0x34003c3c

34001a50 <vRestoreContextOfFirstTask>:

#else /* configENABLE_MPU */

    void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
    {
        __asm volatile
34001a50:	4a09      	ldr	r2, [pc, #36]	@ (34001a78 <vRestoreContextOfFirstTask+0x28>)
34001a52:	6811      	ldr	r1, [r2, #0]
34001a54:	6808      	ldr	r0, [r1, #0]
34001a56:	c806      	ldmia	r0!, {r1, r2}
34001a58:	f381 880b 	msr	PSPLIM, r1
34001a5c:	2102      	movs	r1, #2
34001a5e:	f381 8814 	msr	CONTROL, r1
34001a62:	3020      	adds	r0, #32
34001a64:	f380 8809 	msr	PSP, r0
34001a68:	f3bf 8f6f 	isb	sy
34001a6c:	f04f 0000 	mov.w	r0, #0
34001a70:	f380 8811 	msr	BASEPRI, r0
34001a74:	4710      	bx	r2
            "   isb                                             \n"
            "   mov  r0, #0                                     \n"
            "   msr  basepri, r0                                \n" /* Ensure that interrupts are enabled when the first task starts. */
            "   bx   r2                                         \n" /* Finally, branch to EXC_RETURN. */
        );
    }
34001a76:	bf00      	nop
34001a78:	34003c90 	.word	0x34003c90

34001a7c <vStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
    __asm volatile
34001a7c:	4806      	ldr	r0, [pc, #24]	@ (34001a98 <vStartFirstTask+0x1c>)
34001a7e:	6800      	ldr	r0, [r0, #0]
34001a80:	6800      	ldr	r0, [r0, #0]
34001a82:	f380 8808 	msr	MSP, r0
34001a86:	b662      	cpsie	i
34001a88:	b661      	cpsie	f
34001a8a:	f3bf 8f4f 	dsb	sy
34001a8e:	f3bf 8f6f 	isb	sy
34001a92:	df66      	svc	102	@ 0x66
34001a94:	bf00      	nop
        "   isb                                             \n"
        "   svc %0                                          \n" /* System call to start the first task. */
        "   nop                                             \n"
        ::"i" ( portSVC_START_SCHEDULER ) : "memory"
    );
}
34001a96:	bf00      	nop
34001a98:	e000ed08 	.word	0xe000ed08

34001a9c <ulSetInterruptMask>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
{
    __asm volatile
34001a9c:	f3ef 8011 	mrs	r0, BASEPRI
34001aa0:	f04f 0150 	mov.w	r1, #80	@ 0x50
34001aa4:	f381 8811 	msr	BASEPRI, r1
34001aa8:	f3bf 8f4f 	dsb	sy
34001aac:	f3bf 8f6f 	isb	sy
34001ab0:	4770      	bx	lr
        "   dsb                                             \n"
        "   isb                                             \n"
        "   bx lr                                           \n" /* Return. */
        ::"i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
    );
}
34001ab2:	bf00      	nop
34001ab4:	4618      	mov	r0, r3

34001ab6 <vClearInterruptMask>:
/*-----------------------------------------------------------*/

void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
{
    __asm volatile
34001ab6:	f380 8811 	msr	BASEPRI, r0
34001aba:	f3bf 8f4f 	dsb	sy
34001abe:	f3bf 8f6f 	isb	sy
34001ac2:	4770      	bx	lr
        "   dsb                                             \n"
        "   isb                                             \n"
        "   bx lr                                           \n" /* Return. */
        ::: "memory"
    );
}
34001ac4:	bf00      	nop
	...

34001ac8 <PendSV_Handler>:

#else /* configENABLE_MPU */

    void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
    {
        __asm volatile
34001ac8:	f3ef 8009 	mrs	r0, PSP
34001acc:	f01e 0f10 	tst.w	lr, #16
34001ad0:	bf08      	it	eq
34001ad2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
34001ad6:	f3ef 820b 	mrs	r2, PSPLIM
34001ada:	4673      	mov	r3, lr
34001adc:	e920 0ffc 	stmdb	r0!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
34001ae0:	4a10      	ldr	r2, [pc, #64]	@ (34001b24 <PendSV_Handler+0x5c>)
34001ae2:	6811      	ldr	r1, [r2, #0]
34001ae4:	6008      	str	r0, [r1, #0]
34001ae6:	f04f 0050 	mov.w	r0, #80	@ 0x50
34001aea:	f380 8811 	msr	BASEPRI, r0
34001aee:	f3bf 8f4f 	dsb	sy
34001af2:	f3bf 8f6f 	isb	sy
34001af6:	f000 ffa5 	bl	34002a44 <vTaskSwitchContext>
34001afa:	f04f 0000 	mov.w	r0, #0
34001afe:	f380 8811 	msr	BASEPRI, r0
34001b02:	4a08      	ldr	r2, [pc, #32]	@ (34001b24 <PendSV_Handler+0x5c>)
34001b04:	6811      	ldr	r1, [r2, #0]
34001b06:	6808      	ldr	r0, [r1, #0]
34001b08:	e8b0 0ffc 	ldmia.w	r0!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
34001b0c:	f013 0f10 	tst.w	r3, #16
34001b10:	bf08      	it	eq
34001b12:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
34001b16:	f382 880b 	msr	PSPLIM, r2
34001b1a:	f380 8809 	msr	PSP, r0
34001b1e:	4718      	bx	r3
            "   msr psplim, r2                                  \n" /* Restore the PSPLIM register value for the task. */
            "   msr psp, r0                                     \n" /* Remember the new top of stack for the task. */
            "   bx r3                                           \n"
            ::"i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
        );
    }
34001b20:	bf00      	nop
34001b22:	0000      	.short	0x0000
34001b24:	34003c90 	.word	0x34003c90

34001b28 <SVC_Handler>:

#else /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */

    void SVC_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
    {
        __asm volatile
34001b28:	f01e 0f04 	tst.w	lr, #4
34001b2c:	bf0c      	ite	eq
34001b2e:	f3ef 8008 	mrseq	r0, MSP
34001b32:	f3ef 8009 	mrsne	r0, PSP
34001b36:	4901      	ldr	r1, [pc, #4]	@ (34001b3c <SVC_Handler+0x14>)
34001b38:	4708      	bx	r1
            "   mrseq r0, msp                                   \n"
            "   mrsne r0, psp                                   \n"
            "   ldr r1, =vPortSVCHandler_C                      \n"
            "   bx r1                                           \n"
        );
    }
34001b3a:	bf00      	nop
34001b3c:	340017d9 	.word	0x340017d9

34001b40 <xQueueGenericReset>:
    } while( 0 )
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
34001b40:	b580      	push	{r7, lr}
34001b42:	b084      	sub	sp, #16
34001b44:	af00      	add	r7, sp, #0
34001b46:	6078      	str	r0, [r7, #4]
34001b48:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn = pdPASS;
34001b4a:	2301      	movs	r3, #1
34001b4c:	60fb      	str	r3, [r7, #12]
    Queue_t * const pxQueue = xQueue;
34001b4e:	687b      	ldr	r3, [r7, #4]
34001b50:	60bb      	str	r3, [r7, #8]

    traceENTER_xQueueGenericReset( xQueue, xNewQueue );

    configASSERT( pxQueue );
34001b52:	68bb      	ldr	r3, [r7, #8]
34001b54:	2b00      	cmp	r3, #0
34001b56:	d103      	bne.n	34001b60 <xQueueGenericReset+0x20>
34001b58:	f7ff ffa0 	bl	34001a9c <ulSetInterruptMask>
34001b5c:	bf00      	nop
34001b5e:	e7fd      	b.n	34001b5c <xQueueGenericReset+0x1c>

    if( ( pxQueue != NULL ) &&
34001b60:	68bb      	ldr	r3, [r7, #8]
34001b62:	2b00      	cmp	r3, #0
34001b64:	d057      	beq.n	34001c16 <xQueueGenericReset+0xd6>
        ( pxQueue->uxLength >= 1U ) &&
34001b66:	68bb      	ldr	r3, [r7, #8]
34001b68:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
    if( ( pxQueue != NULL ) &&
34001b6a:	2b00      	cmp	r3, #0
34001b6c:	d053      	beq.n	34001c16 <xQueueGenericReset+0xd6>
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
34001b6e:	68bb      	ldr	r3, [r7, #8]
34001b70:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34001b72:	68bb      	ldr	r3, [r7, #8]
34001b74:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34001b76:	2100      	movs	r1, #0
34001b78:	fba3 2302 	umull	r2, r3, r3, r2
34001b7c:	2b00      	cmp	r3, #0
34001b7e:	d000      	beq.n	34001b82 <xQueueGenericReset+0x42>
34001b80:	2101      	movs	r1, #1
34001b82:	460b      	mov	r3, r1
        ( pxQueue->uxLength >= 1U ) &&
34001b84:	2b00      	cmp	r3, #0
34001b86:	d146      	bne.n	34001c16 <xQueueGenericReset+0xd6>
    {
        taskENTER_CRITICAL();
34001b88:	f7ff fde2 	bl	34001750 <vPortEnterCritical>
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
34001b8c:	68bb      	ldr	r3, [r7, #8]
34001b8e:	681a      	ldr	r2, [r3, #0]
34001b90:	68bb      	ldr	r3, [r7, #8]
34001b92:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34001b94:	68b9      	ldr	r1, [r7, #8]
34001b96:	6c09      	ldr	r1, [r1, #64]	@ 0x40
34001b98:	fb01 f303 	mul.w	r3, r1, r3
34001b9c:	441a      	add	r2, r3
34001b9e:	68bb      	ldr	r3, [r7, #8]
34001ba0:	609a      	str	r2, [r3, #8]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
34001ba2:	68bb      	ldr	r3, [r7, #8]
34001ba4:	2200      	movs	r2, #0
34001ba6:	639a      	str	r2, [r3, #56]	@ 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
34001ba8:	68bb      	ldr	r3, [r7, #8]
34001baa:	681a      	ldr	r2, [r3, #0]
34001bac:	68bb      	ldr	r3, [r7, #8]
34001bae:	605a      	str	r2, [r3, #4]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );
34001bb0:	68bb      	ldr	r3, [r7, #8]
34001bb2:	681a      	ldr	r2, [r3, #0]
34001bb4:	68bb      	ldr	r3, [r7, #8]
34001bb6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34001bb8:	3b01      	subs	r3, #1
34001bba:	68b9      	ldr	r1, [r7, #8]
34001bbc:	6c09      	ldr	r1, [r1, #64]	@ 0x40
34001bbe:	fb01 f303 	mul.w	r3, r1, r3
34001bc2:	441a      	add	r2, r3
34001bc4:	68bb      	ldr	r3, [r7, #8]
34001bc6:	60da      	str	r2, [r3, #12]
            pxQueue->cRxLock = queueUNLOCKED;
34001bc8:	68bb      	ldr	r3, [r7, #8]
34001bca:	22ff      	movs	r2, #255	@ 0xff
34001bcc:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
            pxQueue->cTxLock = queueUNLOCKED;
34001bd0:	68bb      	ldr	r3, [r7, #8]
34001bd2:	22ff      	movs	r2, #255	@ 0xff
34001bd4:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45

            if( xNewQueue == pdFALSE )
34001bd8:	683b      	ldr	r3, [r7, #0]
34001bda:	2b00      	cmp	r3, #0
34001bdc:	d10e      	bne.n	34001bfc <xQueueGenericReset+0xbc>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
34001bde:	68bb      	ldr	r3, [r7, #8]
34001be0:	691b      	ldr	r3, [r3, #16]
34001be2:	2b00      	cmp	r3, #0
34001be4:	d014      	beq.n	34001c10 <xQueueGenericReset+0xd0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
34001be6:	68bb      	ldr	r3, [r7, #8]
34001be8:	3310      	adds	r3, #16
34001bea:	4618      	mov	r0, r3
34001bec:	f000 ffda 	bl	34002ba4 <xTaskRemoveFromEventList>
34001bf0:	4603      	mov	r3, r0
34001bf2:	2b00      	cmp	r3, #0
34001bf4:	d00c      	beq.n	34001c10 <xQueueGenericReset+0xd0>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
34001bf6:	f7ff fd99 	bl	3400172c <vPortYield>
34001bfa:	e009      	b.n	34001c10 <xQueueGenericReset+0xd0>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
34001bfc:	68bb      	ldr	r3, [r7, #8]
34001bfe:	3310      	adds	r3, #16
34001c00:	4618      	mov	r0, r3
34001c02:	f7ff fcab 	bl	3400155c <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
34001c06:	68bb      	ldr	r3, [r7, #8]
34001c08:	3324      	adds	r3, #36	@ 0x24
34001c0a:	4618      	mov	r0, r3
34001c0c:	f7ff fca6 	bl	3400155c <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
34001c10:	f7ff fdb0 	bl	34001774 <vPortExitCritical>
34001c14:	e001      	b.n	34001c1a <xQueueGenericReset+0xda>
    }
    else
    {
        xReturn = pdFAIL;
34001c16:	2300      	movs	r3, #0
34001c18:	60fb      	str	r3, [r7, #12]
    }

    configASSERT( xReturn != pdFAIL );
34001c1a:	68fb      	ldr	r3, [r7, #12]
34001c1c:	2b00      	cmp	r3, #0
34001c1e:	d103      	bne.n	34001c28 <xQueueGenericReset+0xe8>
34001c20:	f7ff ff3c 	bl	34001a9c <ulSetInterruptMask>
34001c24:	bf00      	nop
34001c26:	e7fd      	b.n	34001c24 <xQueueGenericReset+0xe4>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    traceRETURN_xQueueGenericReset( xReturn );

    return xReturn;
34001c28:	68fb      	ldr	r3, [r7, #12]
}
34001c2a:	4618      	mov	r0, r3
34001c2c:	3710      	adds	r7, #16
34001c2e:	46bd      	mov	sp, r7
34001c30:	bd80      	pop	{r7, pc}

34001c32 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
34001c32:	b580      	push	{r7, lr}
34001c34:	b08a      	sub	sp, #40	@ 0x28
34001c36:	af02      	add	r7, sp, #8
34001c38:	60f8      	str	r0, [r7, #12]
34001c3a:	60b9      	str	r1, [r7, #8]
34001c3c:	4613      	mov	r3, r2
34001c3e:	71fb      	strb	r3, [r7, #7]
        Queue_t * pxNewQueue = NULL;
34001c40:	2300      	movs	r3, #0
34001c42:	61fb      	str	r3, [r7, #28]
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        traceENTER_xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
34001c44:	68fb      	ldr	r3, [r7, #12]
34001c46:	2b00      	cmp	r3, #0
34001c48:	d02e      	beq.n	34001ca8 <xQueueGenericCreate+0x76>
            /* Check for multiplication overflow. */
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
34001c4a:	2100      	movs	r1, #0
34001c4c:	68ba      	ldr	r2, [r7, #8]
34001c4e:	68fb      	ldr	r3, [r7, #12]
34001c50:	fba3 2302 	umull	r2, r3, r3, r2
34001c54:	2b00      	cmp	r3, #0
34001c56:	d000      	beq.n	34001c5a <xQueueGenericCreate+0x28>
34001c58:	2101      	movs	r1, #1
34001c5a:	460b      	mov	r3, r1
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
34001c5c:	2b00      	cmp	r3, #0
34001c5e:	d123      	bne.n	34001ca8 <xQueueGenericCreate+0x76>
            /* Check for addition overflow. */
            ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
34001c60:	68fb      	ldr	r3, [r7, #12]
34001c62:	68ba      	ldr	r2, [r7, #8]
34001c64:	fb02 f303 	mul.w	r3, r2, r3
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
34001c68:	f113 0f55 	cmn.w	r3, #85	@ 0x55
34001c6c:	d81c      	bhi.n	34001ca8 <xQueueGenericCreate+0x76>
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( ( size_t ) uxQueueLength * ( size_t ) uxItemSize );
34001c6e:	68fb      	ldr	r3, [r7, #12]
34001c70:	68ba      	ldr	r2, [r7, #8]
34001c72:	fb02 f303 	mul.w	r3, r2, r3
34001c76:	61bb      	str	r3, [r7, #24]

            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
34001c78:	69bb      	ldr	r3, [r7, #24]
34001c7a:	3354      	adds	r3, #84	@ 0x54
34001c7c:	4618      	mov	r0, r3
34001c7e:	f001 facf 	bl	34003220 <pvPortMalloc>
34001c82:	61f8      	str	r0, [r7, #28]

            if( pxNewQueue != NULL )
34001c84:	69fb      	ldr	r3, [r7, #28]
34001c86:	2b00      	cmp	r3, #0
34001c88:	d015      	beq.n	34001cb6 <xQueueGenericCreate+0x84>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
34001c8a:	69fb      	ldr	r3, [r7, #28]
34001c8c:	617b      	str	r3, [r7, #20]
                pucQueueStorage += sizeof( Queue_t );
34001c8e:	697b      	ldr	r3, [r7, #20]
34001c90:	3354      	adds	r3, #84	@ 0x54
34001c92:	617b      	str	r3, [r7, #20]
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
34001c94:	79fa      	ldrb	r2, [r7, #7]
34001c96:	69fb      	ldr	r3, [r7, #28]
34001c98:	9300      	str	r3, [sp, #0]
34001c9a:	4613      	mov	r3, r2
34001c9c:	697a      	ldr	r2, [r7, #20]
34001c9e:	68b9      	ldr	r1, [r7, #8]
34001ca0:	68f8      	ldr	r0, [r7, #12]
34001ca2:	f000 f80d 	bl	34001cc0 <prvInitialiseNewQueue>
            if( pxNewQueue != NULL )
34001ca6:	e006      	b.n	34001cb6 <xQueueGenericCreate+0x84>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            configASSERT( pxNewQueue );
34001ca8:	69fb      	ldr	r3, [r7, #28]
34001caa:	2b00      	cmp	r3, #0
34001cac:	d103      	bne.n	34001cb6 <xQueueGenericCreate+0x84>
34001cae:	f7ff fef5 	bl	34001a9c <ulSetInterruptMask>
34001cb2:	bf00      	nop
34001cb4:	e7fd      	b.n	34001cb2 <xQueueGenericCreate+0x80>
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xQueueGenericCreate( pxNewQueue );

        return pxNewQueue;
34001cb6:	69fb      	ldr	r3, [r7, #28]
    }
34001cb8:	4618      	mov	r0, r3
34001cba:	3720      	adds	r7, #32
34001cbc:	46bd      	mov	sp, r7
34001cbe:	bd80      	pop	{r7, pc}

34001cc0 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
34001cc0:	b580      	push	{r7, lr}
34001cc2:	b084      	sub	sp, #16
34001cc4:	af00      	add	r7, sp, #0
34001cc6:	60f8      	str	r0, [r7, #12]
34001cc8:	60b9      	str	r1, [r7, #8]
34001cca:	607a      	str	r2, [r7, #4]
34001ccc:	70fb      	strb	r3, [r7, #3]
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
34001cce:	68bb      	ldr	r3, [r7, #8]
34001cd0:	2b00      	cmp	r3, #0
34001cd2:	d103      	bne.n	34001cdc <prvInitialiseNewQueue+0x1c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
34001cd4:	69bb      	ldr	r3, [r7, #24]
34001cd6:	69ba      	ldr	r2, [r7, #24]
34001cd8:	601a      	str	r2, [r3, #0]
34001cda:	e002      	b.n	34001ce2 <prvInitialiseNewQueue+0x22>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
34001cdc:	69bb      	ldr	r3, [r7, #24]
34001cde:	687a      	ldr	r2, [r7, #4]
34001ce0:	601a      	str	r2, [r3, #0]
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
34001ce2:	69bb      	ldr	r3, [r7, #24]
34001ce4:	68fa      	ldr	r2, [r7, #12]
34001ce6:	63da      	str	r2, [r3, #60]	@ 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
34001ce8:	69bb      	ldr	r3, [r7, #24]
34001cea:	68ba      	ldr	r2, [r7, #8]
34001cec:	641a      	str	r2, [r3, #64]	@ 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
34001cee:	2101      	movs	r1, #1
34001cf0:	69b8      	ldr	r0, [r7, #24]
34001cf2:	f7ff ff25 	bl	34001b40 <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
    {
        pxNewQueue->ucQueueType = ucQueueType;
34001cf6:	69bb      	ldr	r3, [r7, #24]
34001cf8:	78fa      	ldrb	r2, [r7, #3]
34001cfa:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
    }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
    {
        pxNewQueue->pxQueueSetContainer = NULL;
34001cfe:	69bb      	ldr	r3, [r7, #24]
34001d00:	2200      	movs	r2, #0
34001d02:	649a      	str	r2, [r3, #72]	@ 0x48
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
34001d04:	bf00      	nop
34001d06:	3710      	adds	r7, #16
34001d08:	46bd      	mov	sp, r7
34001d0a:	bd80      	pop	{r7, pc}

34001d0c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
34001d0c:	b580      	push	{r7, lr}
34001d0e:	b08a      	sub	sp, #40	@ 0x28
34001d10:	af00      	add	r7, sp, #0
34001d12:	60f8      	str	r0, [r7, #12]
34001d14:	60b9      	str	r1, [r7, #8]
34001d16:	607a      	str	r2, [r7, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
34001d18:	2300      	movs	r3, #0
34001d1a:	627b      	str	r3, [r7, #36]	@ 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
34001d1c:	68fb      	ldr	r3, [r7, #12]
34001d1e:	623b      	str	r3, [r7, #32]

    traceENTER_xQueueReceive( xQueue, pvBuffer, xTicksToWait );

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
34001d20:	6a3b      	ldr	r3, [r7, #32]
34001d22:	2b00      	cmp	r3, #0
34001d24:	d103      	bne.n	34001d2e <xQueueReceive+0x22>
34001d26:	f7ff feb9 	bl	34001a9c <ulSetInterruptMask>
34001d2a:	bf00      	nop
34001d2c:	e7fd      	b.n	34001d2a <xQueueReceive+0x1e>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
34001d2e:	68bb      	ldr	r3, [r7, #8]
34001d30:	2b00      	cmp	r3, #0
34001d32:	d103      	bne.n	34001d3c <xQueueReceive+0x30>
34001d34:	6a3b      	ldr	r3, [r7, #32]
34001d36:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001d38:	2b00      	cmp	r3, #0
34001d3a:	d101      	bne.n	34001d40 <xQueueReceive+0x34>
34001d3c:	2301      	movs	r3, #1
34001d3e:	e000      	b.n	34001d42 <xQueueReceive+0x36>
34001d40:	2300      	movs	r3, #0
34001d42:	2b00      	cmp	r3, #0
34001d44:	d103      	bne.n	34001d4e <xQueueReceive+0x42>
34001d46:	f7ff fea9 	bl	34001a9c <ulSetInterruptMask>
34001d4a:	bf00      	nop
34001d4c:	e7fd      	b.n	34001d4a <xQueueReceive+0x3e>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
34001d4e:	f001 f92d 	bl	34002fac <xTaskGetSchedulerState>
34001d52:	4603      	mov	r3, r0
34001d54:	2b00      	cmp	r3, #0
34001d56:	d102      	bne.n	34001d5e <xQueueReceive+0x52>
34001d58:	687b      	ldr	r3, [r7, #4]
34001d5a:	2b00      	cmp	r3, #0
34001d5c:	d101      	bne.n	34001d62 <xQueueReceive+0x56>
34001d5e:	2301      	movs	r3, #1
34001d60:	e000      	b.n	34001d64 <xQueueReceive+0x58>
34001d62:	2300      	movs	r3, #0
34001d64:	2b00      	cmp	r3, #0
34001d66:	d103      	bne.n	34001d70 <xQueueReceive+0x64>
34001d68:	f7ff fe98 	bl	34001a9c <ulSetInterruptMask>
34001d6c:	bf00      	nop
34001d6e:	e7fd      	b.n	34001d6c <xQueueReceive+0x60>
    }
    #endif

    for( ; ; )
    {
        taskENTER_CRITICAL();
34001d70:	f7ff fcee 	bl	34001750 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
34001d74:	6a3b      	ldr	r3, [r7, #32]
34001d76:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34001d78:	61fb      	str	r3, [r7, #28]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
34001d7a:	69fb      	ldr	r3, [r7, #28]
34001d7c:	2b00      	cmp	r3, #0
34001d7e:	d019      	beq.n	34001db4 <xQueueReceive+0xa8>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
34001d80:	68b9      	ldr	r1, [r7, #8]
34001d82:	6a38      	ldr	r0, [r7, #32]
34001d84:	f000 f8e8 	bl	34001f58 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
34001d88:	69fb      	ldr	r3, [r7, #28]
34001d8a:	1e5a      	subs	r2, r3, #1
34001d8c:	6a3b      	ldr	r3, [r7, #32]
34001d8e:	639a      	str	r2, [r3, #56]	@ 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
34001d90:	6a3b      	ldr	r3, [r7, #32]
34001d92:	691b      	ldr	r3, [r3, #16]
34001d94:	2b00      	cmp	r3, #0
34001d96:	d009      	beq.n	34001dac <xQueueReceive+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
34001d98:	6a3b      	ldr	r3, [r7, #32]
34001d9a:	3310      	adds	r3, #16
34001d9c:	4618      	mov	r0, r3
34001d9e:	f000 ff01 	bl	34002ba4 <xTaskRemoveFromEventList>
34001da2:	4603      	mov	r3, r0
34001da4:	2b00      	cmp	r3, #0
34001da6:	d001      	beq.n	34001dac <xQueueReceive+0xa0>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
34001da8:	f7ff fcc0 	bl	3400172c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
34001dac:	f7ff fce2 	bl	34001774 <vPortExitCritical>

                traceRETURN_xQueueReceive( pdPASS );

                return pdPASS;
34001db0:	2301      	movs	r3, #1
34001db2:	e063      	b.n	34001e7c <xQueueReceive+0x170>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
34001db4:	687b      	ldr	r3, [r7, #4]
34001db6:	2b00      	cmp	r3, #0
34001db8:	d103      	bne.n	34001dc2 <xQueueReceive+0xb6>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
34001dba:	f7ff fcdb 	bl	34001774 <vPortExitCritical>

                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    traceRETURN_xQueueReceive( errQUEUE_EMPTY );

                    return errQUEUE_EMPTY;
34001dbe:	2300      	movs	r3, #0
34001dc0:	e05c      	b.n	34001e7c <xQueueReceive+0x170>
                }
                else if( xEntryTimeSet == pdFALSE )
34001dc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34001dc4:	2b00      	cmp	r3, #0
34001dc6:	d106      	bne.n	34001dd6 <xQueueReceive+0xca>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
34001dc8:	f107 0314 	add.w	r3, r7, #20
34001dcc:	4618      	mov	r0, r3
34001dce:	f000 ffb9 	bl	34002d44 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
34001dd2:	2301      	movs	r3, #1
34001dd4:	627b      	str	r3, [r7, #36]	@ 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
34001dd6:	f7ff fccd 	bl	34001774 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
34001dda:	f000 fbff 	bl	340025dc <vTaskSuspendAll>
        prvLockQueue( pxQueue );
34001dde:	f7ff fcb7 	bl	34001750 <vPortEnterCritical>
34001de2:	6a3b      	ldr	r3, [r7, #32]
34001de4:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
34001de8:	b25b      	sxtb	r3, r3
34001dea:	f1b3 3fff 	cmp.w	r3, #4294967295
34001dee:	d103      	bne.n	34001df8 <xQueueReceive+0xec>
34001df0:	6a3b      	ldr	r3, [r7, #32]
34001df2:	2200      	movs	r2, #0
34001df4:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
34001df8:	6a3b      	ldr	r3, [r7, #32]
34001dfa:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
34001dfe:	b25b      	sxtb	r3, r3
34001e00:	f1b3 3fff 	cmp.w	r3, #4294967295
34001e04:	d103      	bne.n	34001e0e <xQueueReceive+0x102>
34001e06:	6a3b      	ldr	r3, [r7, #32]
34001e08:	2200      	movs	r2, #0
34001e0a:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
34001e0e:	f7ff fcb1 	bl	34001774 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
34001e12:	1d3a      	adds	r2, r7, #4
34001e14:	f107 0314 	add.w	r3, r7, #20
34001e18:	4611      	mov	r1, r2
34001e1a:	4618      	mov	r0, r3
34001e1c:	f000 ffa8 	bl	34002d70 <xTaskCheckForTimeOut>
34001e20:	4603      	mov	r3, r0
34001e22:	2b00      	cmp	r3, #0
34001e24:	d11d      	bne.n	34001e62 <xQueueReceive+0x156>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
34001e26:	6a38      	ldr	r0, [r7, #32]
34001e28:	f000 f91b 	bl	34002062 <prvIsQueueEmpty>
34001e2c:	4603      	mov	r3, r0
34001e2e:	2b00      	cmp	r3, #0
34001e30:	d011      	beq.n	34001e56 <xQueueReceive+0x14a>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
34001e32:	6a3b      	ldr	r3, [r7, #32]
34001e34:	3324      	adds	r3, #36	@ 0x24
34001e36:	687a      	ldr	r2, [r7, #4]
34001e38:	4611      	mov	r1, r2
34001e3a:	4618      	mov	r0, r3
34001e3c:	f000 fe56 	bl	34002aec <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
34001e40:	6a38      	ldr	r0, [r7, #32]
34001e42:	f000 f8af 	bl	34001fa4 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
34001e46:	f000 fbd7 	bl	340025f8 <xTaskResumeAll>
34001e4a:	4603      	mov	r3, r0
34001e4c:	2b00      	cmp	r3, #0
34001e4e:	d18f      	bne.n	34001d70 <xQueueReceive+0x64>
                {
                    taskYIELD_WITHIN_API();
34001e50:	f7ff fc6c 	bl	3400172c <vPortYield>
34001e54:	e78c      	b.n	34001d70 <xQueueReceive+0x64>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
34001e56:	6a38      	ldr	r0, [r7, #32]
34001e58:	f000 f8a4 	bl	34001fa4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
34001e5c:	f000 fbcc 	bl	340025f8 <xTaskResumeAll>
34001e60:	e786      	b.n	34001d70 <xQueueReceive+0x64>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
34001e62:	6a38      	ldr	r0, [r7, #32]
34001e64:	f000 f89e 	bl	34001fa4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
34001e68:	f000 fbc6 	bl	340025f8 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
34001e6c:	6a38      	ldr	r0, [r7, #32]
34001e6e:	f000 f8f8 	bl	34002062 <prvIsQueueEmpty>
34001e72:	4603      	mov	r3, r0
34001e74:	2b00      	cmp	r3, #0
34001e76:	f43f af7b 	beq.w	34001d70 <xQueueReceive+0x64>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                traceRETURN_xQueueReceive( errQUEUE_EMPTY );

                return errQUEUE_EMPTY;
34001e7a:	2300      	movs	r3, #0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
}
34001e7c:	4618      	mov	r0, r3
34001e7e:	3728      	adds	r7, #40	@ 0x28
34001e80:	46bd      	mov	sp, r7
34001e82:	bd80      	pop	{r7, pc}

34001e84 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
34001e84:	b580      	push	{r7, lr}
34001e86:	b086      	sub	sp, #24
34001e88:	af00      	add	r7, sp, #0
34001e8a:	60f8      	str	r0, [r7, #12]
34001e8c:	60b9      	str	r1, [r7, #8]
34001e8e:	607a      	str	r2, [r7, #4]
    BaseType_t xReturn = pdFALSE;
34001e90:	2300      	movs	r3, #0
34001e92:	617b      	str	r3, [r7, #20]
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
34001e94:	68fb      	ldr	r3, [r7, #12]
34001e96:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34001e98:	613b      	str	r3, [r7, #16]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
34001e9a:	68fb      	ldr	r3, [r7, #12]
34001e9c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001e9e:	2b00      	cmp	r3, #0
34001ea0:	d10d      	bne.n	34001ebe <prvCopyDataToQueue+0x3a>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
34001ea2:	68fb      	ldr	r3, [r7, #12]
34001ea4:	681b      	ldr	r3, [r3, #0]
34001ea6:	2b00      	cmp	r3, #0
34001ea8:	d14d      	bne.n	34001f46 <prvCopyDataToQueue+0xc2>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
34001eaa:	68fb      	ldr	r3, [r7, #12]
34001eac:	689b      	ldr	r3, [r3, #8]
34001eae:	4618      	mov	r0, r3
34001eb0:	f001 f89a 	bl	34002fe8 <xTaskPriorityDisinherit>
34001eb4:	6178      	str	r0, [r7, #20]
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
34001eb6:	68fb      	ldr	r3, [r7, #12]
34001eb8:	2200      	movs	r2, #0
34001eba:	609a      	str	r2, [r3, #8]
34001ebc:	e043      	b.n	34001f46 <prvCopyDataToQueue+0xc2>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
34001ebe:	687b      	ldr	r3, [r7, #4]
34001ec0:	2b00      	cmp	r3, #0
34001ec2:	d119      	bne.n	34001ef8 <prvCopyDataToQueue+0x74>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
34001ec4:	68fb      	ldr	r3, [r7, #12]
34001ec6:	6858      	ldr	r0, [r3, #4]
34001ec8:	68fb      	ldr	r3, [r7, #12]
34001eca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001ecc:	461a      	mov	r2, r3
34001ece:	68b9      	ldr	r1, [r7, #8]
34001ed0:	f001 fe82 	bl	34003bd8 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;
34001ed4:	68fb      	ldr	r3, [r7, #12]
34001ed6:	685a      	ldr	r2, [r3, #4]
34001ed8:	68fb      	ldr	r3, [r7, #12]
34001eda:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001edc:	441a      	add	r2, r3
34001ede:	68fb      	ldr	r3, [r7, #12]
34001ee0:	605a      	str	r2, [r3, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )
34001ee2:	68fb      	ldr	r3, [r7, #12]
34001ee4:	685a      	ldr	r2, [r3, #4]
34001ee6:	68fb      	ldr	r3, [r7, #12]
34001ee8:	689b      	ldr	r3, [r3, #8]
34001eea:	429a      	cmp	r2, r3
34001eec:	d32b      	bcc.n	34001f46 <prvCopyDataToQueue+0xc2>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
34001eee:	68fb      	ldr	r3, [r7, #12]
34001ef0:	681a      	ldr	r2, [r3, #0]
34001ef2:	68fb      	ldr	r3, [r7, #12]
34001ef4:	605a      	str	r2, [r3, #4]
34001ef6:	e026      	b.n	34001f46 <prvCopyDataToQueue+0xc2>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
34001ef8:	68fb      	ldr	r3, [r7, #12]
34001efa:	68d8      	ldr	r0, [r3, #12]
34001efc:	68fb      	ldr	r3, [r7, #12]
34001efe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f00:	461a      	mov	r2, r3
34001f02:	68b9      	ldr	r1, [r7, #8]
34001f04:	f001 fe68 	bl	34003bd8 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
34001f08:	68fb      	ldr	r3, [r7, #12]
34001f0a:	68da      	ldr	r2, [r3, #12]
34001f0c:	68fb      	ldr	r3, [r7, #12]
34001f0e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f10:	425b      	negs	r3, r3
34001f12:	441a      	add	r2, r3
34001f14:	68fb      	ldr	r3, [r7, #12]
34001f16:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )
34001f18:	68fb      	ldr	r3, [r7, #12]
34001f1a:	68da      	ldr	r2, [r3, #12]
34001f1c:	68fb      	ldr	r3, [r7, #12]
34001f1e:	681b      	ldr	r3, [r3, #0]
34001f20:	429a      	cmp	r2, r3
34001f22:	d207      	bcs.n	34001f34 <prvCopyDataToQueue+0xb0>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
34001f24:	68fb      	ldr	r3, [r7, #12]
34001f26:	689a      	ldr	r2, [r3, #8]
34001f28:	68fb      	ldr	r3, [r7, #12]
34001f2a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f2c:	425b      	negs	r3, r3
34001f2e:	441a      	add	r2, r3
34001f30:	68fb      	ldr	r3, [r7, #12]
34001f32:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
34001f34:	687b      	ldr	r3, [r7, #4]
34001f36:	2b02      	cmp	r3, #2
34001f38:	d105      	bne.n	34001f46 <prvCopyDataToQueue+0xc2>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
34001f3a:	693b      	ldr	r3, [r7, #16]
34001f3c:	2b00      	cmp	r3, #0
34001f3e:	d002      	beq.n	34001f46 <prvCopyDataToQueue+0xc2>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
34001f40:	693b      	ldr	r3, [r7, #16]
34001f42:	3b01      	subs	r3, #1
34001f44:	613b      	str	r3, [r7, #16]
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
34001f46:	693b      	ldr	r3, [r7, #16]
34001f48:	1c5a      	adds	r2, r3, #1
34001f4a:	68fb      	ldr	r3, [r7, #12]
34001f4c:	639a      	str	r2, [r3, #56]	@ 0x38

    return xReturn;
34001f4e:	697b      	ldr	r3, [r7, #20]
}
34001f50:	4618      	mov	r0, r3
34001f52:	3718      	adds	r7, #24
34001f54:	46bd      	mov	sp, r7
34001f56:	bd80      	pop	{r7, pc}

34001f58 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
34001f58:	b580      	push	{r7, lr}
34001f5a:	b082      	sub	sp, #8
34001f5c:	af00      	add	r7, sp, #0
34001f5e:	6078      	str	r0, [r7, #4]
34001f60:	6039      	str	r1, [r7, #0]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
34001f62:	687b      	ldr	r3, [r7, #4]
34001f64:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f66:	2b00      	cmp	r3, #0
34001f68:	d018      	beq.n	34001f9c <prvCopyDataFromQueue+0x44>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
34001f6a:	687b      	ldr	r3, [r7, #4]
34001f6c:	68da      	ldr	r2, [r3, #12]
34001f6e:	687b      	ldr	r3, [r7, #4]
34001f70:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f72:	441a      	add	r2, r3
34001f74:	687b      	ldr	r3, [r7, #4]
34001f76:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
34001f78:	687b      	ldr	r3, [r7, #4]
34001f7a:	68da      	ldr	r2, [r3, #12]
34001f7c:	687b      	ldr	r3, [r7, #4]
34001f7e:	689b      	ldr	r3, [r3, #8]
34001f80:	429a      	cmp	r2, r3
34001f82:	d303      	bcc.n	34001f8c <prvCopyDataFromQueue+0x34>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
34001f84:	687b      	ldr	r3, [r7, #4]
34001f86:	681a      	ldr	r2, [r3, #0]
34001f88:	687b      	ldr	r3, [r7, #4]
34001f8a:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
34001f8c:	687b      	ldr	r3, [r7, #4]
34001f8e:	68d9      	ldr	r1, [r3, #12]
34001f90:	687b      	ldr	r3, [r7, #4]
34001f92:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34001f94:	461a      	mov	r2, r3
34001f96:	6838      	ldr	r0, [r7, #0]
34001f98:	f001 fe1e 	bl	34003bd8 <memcpy>
    }
}
34001f9c:	bf00      	nop
34001f9e:	3708      	adds	r7, #8
34001fa0:	46bd      	mov	sp, r7
34001fa2:	bd80      	pop	{r7, pc}

34001fa4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
34001fa4:	b580      	push	{r7, lr}
34001fa6:	b084      	sub	sp, #16
34001fa8:	af00      	add	r7, sp, #0
34001faa:	6078      	str	r0, [r7, #4]

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
34001fac:	f7ff fbd0 	bl	34001750 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
34001fb0:	687b      	ldr	r3, [r7, #4]
34001fb2:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
34001fb6:	73fb      	strb	r3, [r7, #15]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
34001fb8:	e01e      	b.n	34001ff8 <prvUnlockQueue+0x54>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
            {
                if( pxQueue->pxQueueSetContainer != NULL )
34001fba:	687b      	ldr	r3, [r7, #4]
34001fbc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34001fbe:	2b00      	cmp	r3, #0
34001fc0:	d008      	beq.n	34001fd4 <prvUnlockQueue+0x30>
                {
                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
34001fc2:	6878      	ldr	r0, [r7, #4]
34001fc4:	f000 f897 	bl	340020f6 <prvNotifyQueueSetContainer>
34001fc8:	4603      	mov	r3, r0
34001fca:	2b00      	cmp	r3, #0
34001fcc:	d010      	beq.n	34001ff0 <prvUnlockQueue+0x4c>
                    {
                        /* The queue is a member of a queue set, and posting to
                         * the queue set caused a higher priority task to unblock.
                         * A context switch is required. */
                        vTaskMissedYield();
34001fce:	f000 ff37 	bl	34002e40 <vTaskMissedYield>
34001fd2:	e00d      	b.n	34001ff0 <prvUnlockQueue+0x4c>
                else
                {
                    /* Tasks that are removed from the event list will get
                     * added to the pending ready list as the scheduler is still
                     * suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
34001fd4:	687b      	ldr	r3, [r7, #4]
34001fd6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34001fd8:	2b00      	cmp	r3, #0
34001fda:	d012      	beq.n	34002002 <prvUnlockQueue+0x5e>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
34001fdc:	687b      	ldr	r3, [r7, #4]
34001fde:	3324      	adds	r3, #36	@ 0x24
34001fe0:	4618      	mov	r0, r3
34001fe2:	f000 fddf 	bl	34002ba4 <xTaskRemoveFromEventList>
34001fe6:	4603      	mov	r3, r0
34001fe8:	2b00      	cmp	r3, #0
34001fea:	d001      	beq.n	34001ff0 <prvUnlockQueue+0x4c>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            vTaskMissedYield();
34001fec:	f000 ff28 	bl	34002e40 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
34001ff0:	7bfb      	ldrb	r3, [r7, #15]
34001ff2:	3b01      	subs	r3, #1
34001ff4:	b2db      	uxtb	r3, r3
34001ff6:	73fb      	strb	r3, [r7, #15]
        while( cTxLock > queueLOCKED_UNMODIFIED )
34001ff8:	f997 300f 	ldrsb.w	r3, [r7, #15]
34001ffc:	2b00      	cmp	r3, #0
34001ffe:	dcdc      	bgt.n	34001fba <prvUnlockQueue+0x16>
34002000:	e000      	b.n	34002004 <prvUnlockQueue+0x60>
                        break;
34002002:	bf00      	nop
        }

        pxQueue->cTxLock = queueUNLOCKED;
34002004:	687b      	ldr	r3, [r7, #4]
34002006:	22ff      	movs	r2, #255	@ 0xff
34002008:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
    }
    taskEXIT_CRITICAL();
3400200c:	f7ff fbb2 	bl	34001774 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
34002010:	f7ff fb9e 	bl	34001750 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
34002014:	687b      	ldr	r3, [r7, #4]
34002016:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
3400201a:	73bb      	strb	r3, [r7, #14]

        while( cRxLock > queueLOCKED_UNMODIFIED )
3400201c:	e011      	b.n	34002042 <prvUnlockQueue+0x9e>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
3400201e:	687b      	ldr	r3, [r7, #4]
34002020:	691b      	ldr	r3, [r3, #16]
34002022:	2b00      	cmp	r3, #0
34002024:	d012      	beq.n	3400204c <prvUnlockQueue+0xa8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
34002026:	687b      	ldr	r3, [r7, #4]
34002028:	3310      	adds	r3, #16
3400202a:	4618      	mov	r0, r3
3400202c:	f000 fdba 	bl	34002ba4 <xTaskRemoveFromEventList>
34002030:	4603      	mov	r3, r0
34002032:	2b00      	cmp	r3, #0
34002034:	d001      	beq.n	3400203a <prvUnlockQueue+0x96>
                {
                    vTaskMissedYield();
34002036:	f000 ff03 	bl	34002e40 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
3400203a:	7bbb      	ldrb	r3, [r7, #14]
3400203c:	3b01      	subs	r3, #1
3400203e:	b2db      	uxtb	r3, r3
34002040:	73bb      	strb	r3, [r7, #14]
        while( cRxLock > queueLOCKED_UNMODIFIED )
34002042:	f997 300e 	ldrsb.w	r3, [r7, #14]
34002046:	2b00      	cmp	r3, #0
34002048:	dce9      	bgt.n	3400201e <prvUnlockQueue+0x7a>
3400204a:	e000      	b.n	3400204e <prvUnlockQueue+0xaa>
            }
            else
            {
                break;
3400204c:	bf00      	nop
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
3400204e:	687b      	ldr	r3, [r7, #4]
34002050:	22ff      	movs	r2, #255	@ 0xff
34002052:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
    }
    taskEXIT_CRITICAL();
34002056:	f7ff fb8d 	bl	34001774 <vPortExitCritical>
}
3400205a:	bf00      	nop
3400205c:	3710      	adds	r7, #16
3400205e:	46bd      	mov	sp, r7
34002060:	bd80      	pop	{r7, pc}

34002062 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
34002062:	b580      	push	{r7, lr}
34002064:	b084      	sub	sp, #16
34002066:	af00      	add	r7, sp, #0
34002068:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
3400206a:	f7ff fb71 	bl	34001750 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
3400206e:	687b      	ldr	r3, [r7, #4]
34002070:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34002072:	2b00      	cmp	r3, #0
34002074:	d102      	bne.n	3400207c <prvIsQueueEmpty+0x1a>
        {
            xReturn = pdTRUE;
34002076:	2301      	movs	r3, #1
34002078:	60fb      	str	r3, [r7, #12]
3400207a:	e001      	b.n	34002080 <prvIsQueueEmpty+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
3400207c:	2300      	movs	r3, #0
3400207e:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
34002080:	f7ff fb78 	bl	34001774 <vPortExitCritical>

    return xReturn;
34002084:	68fb      	ldr	r3, [r7, #12]
}
34002086:	4618      	mov	r0, r3
34002088:	3710      	adds	r7, #16
3400208a:	46bd      	mov	sp, r7
3400208c:	bd80      	pop	{r7, pc}

3400208e <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
3400208e:	b580      	push	{r7, lr}
34002090:	b086      	sub	sp, #24
34002092:	af00      	add	r7, sp, #0
34002094:	60f8      	str	r0, [r7, #12]
34002096:	60b9      	str	r1, [r7, #8]
34002098:	607a      	str	r2, [r7, #4]
        Queue_t * const pxQueue = xQueue;
3400209a:	68fb      	ldr	r3, [r7, #12]
3400209c:	617b      	str	r3, [r7, #20]
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
3400209e:	f7ff fb57 	bl	34001750 <vPortEnterCritical>
340020a2:	697b      	ldr	r3, [r7, #20]
340020a4:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
340020a8:	b25b      	sxtb	r3, r3
340020aa:	f1b3 3fff 	cmp.w	r3, #4294967295
340020ae:	d103      	bne.n	340020b8 <vQueueWaitForMessageRestricted+0x2a>
340020b0:	697b      	ldr	r3, [r7, #20]
340020b2:	2200      	movs	r2, #0
340020b4:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
340020b8:	697b      	ldr	r3, [r7, #20]
340020ba:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
340020be:	b25b      	sxtb	r3, r3
340020c0:	f1b3 3fff 	cmp.w	r3, #4294967295
340020c4:	d103      	bne.n	340020ce <vQueueWaitForMessageRestricted+0x40>
340020c6:	697b      	ldr	r3, [r7, #20]
340020c8:	2200      	movs	r2, #0
340020ca:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
340020ce:	f7ff fb51 	bl	34001774 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
340020d2:	697b      	ldr	r3, [r7, #20]
340020d4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340020d6:	2b00      	cmp	r3, #0
340020d8:	d106      	bne.n	340020e8 <vQueueWaitForMessageRestricted+0x5a>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
340020da:	697b      	ldr	r3, [r7, #20]
340020dc:	3324      	adds	r3, #36	@ 0x24
340020de:	687a      	ldr	r2, [r7, #4]
340020e0:	68b9      	ldr	r1, [r7, #8]
340020e2:	4618      	mov	r0, r3
340020e4:	f000 fd20 	bl	34002b28 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
340020e8:	6978      	ldr	r0, [r7, #20]
340020ea:	f7ff ff5b 	bl	34001fa4 <prvUnlockQueue>

        traceRETURN_vQueueWaitForMessageRestricted();
    }
340020ee:	bf00      	nop
340020f0:	3718      	adds	r7, #24
340020f2:	46bd      	mov	sp, r7
340020f4:	bd80      	pop	{r7, pc}

340020f6 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
340020f6:	b580      	push	{r7, lr}
340020f8:	b086      	sub	sp, #24
340020fa:	af00      	add	r7, sp, #0
340020fc:	6078      	str	r0, [r7, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
340020fe:	687b      	ldr	r3, [r7, #4]
34002100:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34002102:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
34002104:	2300      	movs	r3, #0
34002106:	617b      	str	r3, [r7, #20]
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
34002108:	693b      	ldr	r3, [r7, #16]
3400210a:	2b00      	cmp	r3, #0
3400210c:	d103      	bne.n	34002116 <prvNotifyQueueSetContainer+0x20>
3400210e:	f7ff fcc5 	bl	34001a9c <ulSetInterruptMask>
34002112:	bf00      	nop
34002114:	e7fd      	b.n	34002112 <prvNotifyQueueSetContainer+0x1c>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
34002116:	693b      	ldr	r3, [r7, #16]
34002118:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400211a:	693b      	ldr	r3, [r7, #16]
3400211c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400211e:	429a      	cmp	r2, r3
34002120:	d303      	bcc.n	3400212a <prvNotifyQueueSetContainer+0x34>
34002122:	f7ff fcbb 	bl	34001a9c <ulSetInterruptMask>
34002126:	bf00      	nop
34002128:	e7fd      	b.n	34002126 <prvNotifyQueueSetContainer+0x30>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
3400212a:	693b      	ldr	r3, [r7, #16]
3400212c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400212e:	693b      	ldr	r3, [r7, #16]
34002130:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34002132:	429a      	cmp	r2, r3
34002134:	d235      	bcs.n	340021a2 <prvNotifyQueueSetContainer+0xac>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
34002136:	693b      	ldr	r3, [r7, #16]
34002138:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
3400213c:	73fb      	strb	r3, [r7, #15]

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
3400213e:	1d3b      	adds	r3, r7, #4
34002140:	2200      	movs	r2, #0
34002142:	4619      	mov	r1, r3
34002144:	6938      	ldr	r0, [r7, #16]
34002146:	f7ff fe9d 	bl	34001e84 <prvCopyDataToQueue>
3400214a:	6178      	str	r0, [r7, #20]

            if( cTxLock == queueUNLOCKED )
3400214c:	f997 300f 	ldrsb.w	r3, [r7, #15]
34002150:	f1b3 3fff 	cmp.w	r3, #4294967295
34002154:	d10e      	bne.n	34002174 <prvNotifyQueueSetContainer+0x7e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
34002156:	693b      	ldr	r3, [r7, #16]
34002158:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400215a:	2b00      	cmp	r3, #0
3400215c:	d021      	beq.n	340021a2 <prvNotifyQueueSetContainer+0xac>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
3400215e:	693b      	ldr	r3, [r7, #16]
34002160:	3324      	adds	r3, #36	@ 0x24
34002162:	4618      	mov	r0, r3
34002164:	f000 fd1e 	bl	34002ba4 <xTaskRemoveFromEventList>
34002168:	4603      	mov	r3, r0
3400216a:	2b00      	cmp	r3, #0
3400216c:	d019      	beq.n	340021a2 <prvNotifyQueueSetContainer+0xac>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
3400216e:	2301      	movs	r3, #1
34002170:	617b      	str	r3, [r7, #20]
34002172:	e016      	b.n	340021a2 <prvNotifyQueueSetContainer+0xac>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                prvIncrementQueueTxLock( pxQueueSetContainer, cTxLock );
34002174:	f000 fb48 	bl	34002808 <uxTaskGetNumberOfTasks>
34002178:	60b8      	str	r0, [r7, #8]
3400217a:	f997 300f 	ldrsb.w	r3, [r7, #15]
3400217e:	68ba      	ldr	r2, [r7, #8]
34002180:	429a      	cmp	r2, r3
34002182:	d90e      	bls.n	340021a2 <prvNotifyQueueSetContainer+0xac>
34002184:	f997 300f 	ldrsb.w	r3, [r7, #15]
34002188:	2b7f      	cmp	r3, #127	@ 0x7f
3400218a:	d103      	bne.n	34002194 <prvNotifyQueueSetContainer+0x9e>
3400218c:	f7ff fc86 	bl	34001a9c <ulSetInterruptMask>
34002190:	bf00      	nop
34002192:	e7fd      	b.n	34002190 <prvNotifyQueueSetContainer+0x9a>
34002194:	7bfb      	ldrb	r3, [r7, #15]
34002196:	3301      	adds	r3, #1
34002198:	b2db      	uxtb	r3, r3
3400219a:	b25a      	sxtb	r2, r3
3400219c:	693b      	ldr	r3, [r7, #16]
3400219e:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
340021a2:	697b      	ldr	r3, [r7, #20]
    }
340021a4:	4618      	mov	r0, r3
340021a6:	3718      	adds	r7, #24
340021a8:	46bd      	mov	sp, r7
340021aa:	bd80      	pop	{r7, pc}

340021ac <prvCreateTask>:
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask )
    {
340021ac:	b580      	push	{r7, lr}
340021ae:	b08a      	sub	sp, #40	@ 0x28
340021b0:	af04      	add	r7, sp, #16
340021b2:	60f8      	str	r0, [r7, #12]
340021b4:	60b9      	str	r1, [r7, #8]
340021b6:	607a      	str	r2, [r7, #4]
340021b8:	603b      	str	r3, [r7, #0]

            /* Allocate space for the stack used by the task being created. */
            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
340021ba:	687b      	ldr	r3, [r7, #4]
340021bc:	009b      	lsls	r3, r3, #2
340021be:	4618      	mov	r0, r3
340021c0:	f001 f82e 	bl	34003220 <pvPortMalloc>
340021c4:	6138      	str	r0, [r7, #16]

            if( pxStack != NULL )
340021c6:	693b      	ldr	r3, [r7, #16]
340021c8:	2b00      	cmp	r3, #0
340021ca:	d013      	beq.n	340021f4 <prvCreateTask+0x48>
            {
                /* Allocate space for the TCB. */
                /* MISRA Ref 11.5.1 [Malloc memory assignment] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                /* coverity[misra_c_2012_rule_11_5_violation] */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
340021cc:	2058      	movs	r0, #88	@ 0x58
340021ce:	f001 f827 	bl	34003220 <pvPortMalloc>
340021d2:	6178      	str	r0, [r7, #20]

                if( pxNewTCB != NULL )
340021d4:	697b      	ldr	r3, [r7, #20]
340021d6:	2b00      	cmp	r3, #0
340021d8:	d008      	beq.n	340021ec <prvCreateTask+0x40>
                {
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
340021da:	2258      	movs	r2, #88	@ 0x58
340021dc:	2100      	movs	r1, #0
340021de:	6978      	ldr	r0, [r7, #20]
340021e0:	f001 fcce 	bl	34003b80 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
340021e4:	697b      	ldr	r3, [r7, #20]
340021e6:	693a      	ldr	r2, [r7, #16]
340021e8:	631a      	str	r2, [r3, #48]	@ 0x30
340021ea:	e005      	b.n	340021f8 <prvCreateTask+0x4c>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
340021ec:	6938      	ldr	r0, [r7, #16]
340021ee:	f001 f91d 	bl	3400342c <vPortFree>
340021f2:	e001      	b.n	340021f8 <prvCreateTask+0x4c>
                }
            }
            else
            {
                pxNewTCB = NULL;
340021f4:	2300      	movs	r3, #0
340021f6:	617b      	str	r3, [r7, #20]
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
340021f8:	697b      	ldr	r3, [r7, #20]
340021fa:	2b00      	cmp	r3, #0
340021fc:	d00d      	beq.n	3400221a <prvCreateTask+0x6e>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
340021fe:	2300      	movs	r3, #0
34002200:	9303      	str	r3, [sp, #12]
34002202:	697b      	ldr	r3, [r7, #20]
34002204:	9302      	str	r3, [sp, #8]
34002206:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002208:	9301      	str	r3, [sp, #4]
3400220a:	6a3b      	ldr	r3, [r7, #32]
3400220c:	9300      	str	r3, [sp, #0]
3400220e:	683b      	ldr	r3, [r7, #0]
34002210:	687a      	ldr	r2, [r7, #4]
34002212:	68b9      	ldr	r1, [r7, #8]
34002214:	68f8      	ldr	r0, [r7, #12]
34002216:	f000 f828 	bl	3400226a <prvInitialiseNewTask>
        }

        return pxNewTCB;
3400221a:	697b      	ldr	r3, [r7, #20]
    }
3400221c:	4618      	mov	r0, r3
3400221e:	3718      	adds	r7, #24
34002220:	46bd      	mov	sp, r7
34002222:	bd80      	pop	{r7, pc}

34002224 <xTaskCreate>:
                            const char * const pcName,
                            const configSTACK_DEPTH_TYPE uxStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
34002224:	b580      	push	{r7, lr}
34002226:	b088      	sub	sp, #32
34002228:	af02      	add	r7, sp, #8
3400222a:	60f8      	str	r0, [r7, #12]
3400222c:	60b9      	str	r1, [r7, #8]
3400222e:	607a      	str	r2, [r7, #4]
34002230:	603b      	str	r3, [r7, #0]
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreate( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
34002232:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002234:	9301      	str	r3, [sp, #4]
34002236:	6a3b      	ldr	r3, [r7, #32]
34002238:	9300      	str	r3, [sp, #0]
3400223a:	683b      	ldr	r3, [r7, #0]
3400223c:	687a      	ldr	r2, [r7, #4]
3400223e:	68b9      	ldr	r1, [r7, #8]
34002240:	68f8      	ldr	r0, [r7, #12]
34002242:	f7ff ffb3 	bl	340021ac <prvCreateTask>
34002246:	6138      	str	r0, [r7, #16]

        if( pxNewTCB != NULL )
34002248:	693b      	ldr	r3, [r7, #16]
3400224a:	2b00      	cmp	r3, #0
3400224c:	d005      	beq.n	3400225a <xTaskCreate+0x36>
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );
3400224e:	6938      	ldr	r0, [r7, #16]
34002250:	f000 f88e 	bl	34002370 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
34002254:	2301      	movs	r3, #1
34002256:	617b      	str	r3, [r7, #20]
34002258:	e002      	b.n	34002260 <xTaskCreate+0x3c>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
3400225a:	f04f 33ff 	mov.w	r3, #4294967295
3400225e:	617b      	str	r3, [r7, #20]
        }

        traceRETURN_xTaskCreate( xReturn );

        return xReturn;
34002260:	697b      	ldr	r3, [r7, #20]
    }
34002262:	4618      	mov	r0, r3
34002264:	3718      	adds	r7, #24
34002266:	46bd      	mov	sp, r7
34002268:	bd80      	pop	{r7, pc}

3400226a <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
3400226a:	b580      	push	{r7, lr}
3400226c:	b086      	sub	sp, #24
3400226e:	af00      	add	r7, sp, #0
34002270:	60f8      	str	r0, [r7, #12]
34002272:	60b9      	str	r1, [r7, #8]
34002274:	607a      	str	r2, [r7, #4]
34002276:	603b      	str	r3, [r7, #0]

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    {
        /* Fill the stack with a known value to assist debugging. */
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) uxStackDepth * sizeof( StackType_t ) );
34002278:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400227a:	6b18      	ldr	r0, [r3, #48]	@ 0x30
3400227c:	687b      	ldr	r3, [r7, #4]
3400227e:	009b      	lsls	r3, r3, #2
34002280:	461a      	mov	r2, r3
34002282:	21a5      	movs	r1, #165	@ 0xa5
34002284:	f001 fc7c 	bl	34003b80 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
34002288:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400228a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400228c:	687b      	ldr	r3, [r7, #4]
3400228e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
34002292:	3b01      	subs	r3, #1
34002294:	009b      	lsls	r3, r3, #2
34002296:	4413      	add	r3, r2
34002298:	613b      	str	r3, [r7, #16]
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
3400229a:	693b      	ldr	r3, [r7, #16]
3400229c:	f023 0307 	bic.w	r3, r3, #7
340022a0:	613b      	str	r3, [r7, #16]

        /* Check the alignment of the calculated top of stack is correct. */
        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0U ) );
340022a2:	693b      	ldr	r3, [r7, #16]
340022a4:	f003 0307 	and.w	r3, r3, #7
340022a8:	2b00      	cmp	r3, #0
340022aa:	d003      	beq.n	340022b4 <prvInitialiseNewTask+0x4a>
340022ac:	f7ff fbf6 	bl	34001a9c <ulSetInterruptMask>
340022b0:	bf00      	nop
340022b2:	e7fd      	b.n	340022b0 <prvInitialiseNewTask+0x46>
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
340022b4:	68bb      	ldr	r3, [r7, #8]
340022b6:	2b00      	cmp	r3, #0
340022b8:	d01e      	beq.n	340022f8 <prvInitialiseNewTask+0x8e>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
340022ba:	2300      	movs	r3, #0
340022bc:	617b      	str	r3, [r7, #20]
340022be:	e012      	b.n	340022e6 <prvInitialiseNewTask+0x7c>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
340022c0:	68ba      	ldr	r2, [r7, #8]
340022c2:	697b      	ldr	r3, [r7, #20]
340022c4:	4413      	add	r3, r2
340022c6:	7819      	ldrb	r1, [r3, #0]
340022c8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340022ca:	697b      	ldr	r3, [r7, #20]
340022cc:	4413      	add	r3, r2
340022ce:	3334      	adds	r3, #52	@ 0x34
340022d0:	460a      	mov	r2, r1
340022d2:	701a      	strb	r2, [r3, #0]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
340022d4:	68ba      	ldr	r2, [r7, #8]
340022d6:	697b      	ldr	r3, [r7, #20]
340022d8:	4413      	add	r3, r2
340022da:	781b      	ldrb	r3, [r3, #0]
340022dc:	2b00      	cmp	r3, #0
340022de:	d006      	beq.n	340022ee <prvInitialiseNewTask+0x84>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
340022e0:	697b      	ldr	r3, [r7, #20]
340022e2:	3301      	adds	r3, #1
340022e4:	617b      	str	r3, [r7, #20]
340022e6:	697b      	ldr	r3, [r7, #20]
340022e8:	2b09      	cmp	r3, #9
340022ea:	d9e9      	bls.n	340022c0 <prvInitialiseNewTask+0x56>
340022ec:	e000      	b.n	340022f0 <prvInitialiseNewTask+0x86>
            {
                break;
340022ee:	bf00      	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
340022f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340022f2:	2200      	movs	r2, #0
340022f4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );
340022f8:	6a3b      	ldr	r3, [r7, #32]
340022fa:	2b1f      	cmp	r3, #31
340022fc:	d903      	bls.n	34002306 <prvInitialiseNewTask+0x9c>
340022fe:	f7ff fbcd 	bl	34001a9c <ulSetInterruptMask>
34002302:	bf00      	nop
34002304:	e7fd      	b.n	34002302 <prvInitialiseNewTask+0x98>

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
34002306:	6a3b      	ldr	r3, [r7, #32]
34002308:	2b1f      	cmp	r3, #31
3400230a:	d901      	bls.n	34002310 <prvInitialiseNewTask+0xa6>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
3400230c:	231f      	movs	r3, #31
3400230e:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
34002310:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002312:	6a3a      	ldr	r2, [r7, #32]
34002314:	62da      	str	r2, [r3, #44]	@ 0x2c
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
34002316:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002318:	6a3a      	ldr	r2, [r7, #32]
3400231a:	649a      	str	r2, [r3, #72]	@ 0x48
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
3400231c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400231e:	3304      	adds	r3, #4
34002320:	4618      	mov	r0, r3
34002322:	f7ff f93b 	bl	3400159c <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
34002326:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002328:	3318      	adds	r3, #24
3400232a:	4618      	mov	r0, r3
3400232c:	f7ff f936 	bl	3400159c <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
34002330:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002332:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34002334:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
34002336:	6a3b      	ldr	r3, [r7, #32]
34002338:	f1c3 0220 	rsb	r2, r3, #32
3400233c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400233e:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
34002340:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002342:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34002344:	625a      	str	r2, [r3, #36]	@ 0x24
         * function as well. */
        #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
        {
            #if ( portSTACK_GROWTH < 0 )
            {
                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
34002346:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002348:	6b19      	ldr	r1, [r3, #48]	@ 0x30
3400234a:	683b      	ldr	r3, [r7, #0]
3400234c:	68fa      	ldr	r2, [r7, #12]
3400234e:	6938      	ldr	r0, [r7, #16]
34002350:	f7ff fa5e 	bl	34001810 <pxPortInitialiseStack>
34002354:	4602      	mov	r2, r0
34002356:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002358:	601a      	str	r2, [r3, #0]
            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */

    if( pxCreatedTask != NULL )
3400235a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400235c:	2b00      	cmp	r3, #0
3400235e:	d002      	beq.n	34002366 <prvInitialiseNewTask+0xfc>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
34002360:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002362:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34002364:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
34002366:	bf00      	nop
34002368:	3718      	adds	r7, #24
3400236a:	46bd      	mov	sp, r7
3400236c:	bd80      	pop	{r7, pc}
	...

34002370 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )

    static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
    {
34002370:	b580      	push	{r7, lr}
34002372:	b084      	sub	sp, #16
34002374:	af00      	add	r7, sp, #0
34002376:	6078      	str	r0, [r7, #4]
        /* Ensure interrupts don't access the task lists while the lists are being
         * updated. */
        taskENTER_CRITICAL();
34002378:	f7ff f9ea 	bl	34001750 <vPortEnterCritical>
        {
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
3400237c:	4b3e      	ldr	r3, [pc, #248]	@ (34002478 <prvAddNewTaskToReadyList+0x108>)
3400237e:	681b      	ldr	r3, [r3, #0]
34002380:	3301      	adds	r3, #1
34002382:	4a3d      	ldr	r2, [pc, #244]	@ (34002478 <prvAddNewTaskToReadyList+0x108>)
34002384:	6013      	str	r3, [r2, #0]

            if( pxCurrentTCB == NULL )
34002386:	4b3d      	ldr	r3, [pc, #244]	@ (3400247c <prvAddNewTaskToReadyList+0x10c>)
34002388:	681b      	ldr	r3, [r3, #0]
3400238a:	2b00      	cmp	r3, #0
3400238c:	d109      	bne.n	340023a2 <prvAddNewTaskToReadyList+0x32>
            {
                /* There are no other tasks, or all the other tasks are in
                 * the suspended state - make this the current task. */
                pxCurrentTCB = pxNewTCB;
3400238e:	4a3b      	ldr	r2, [pc, #236]	@ (3400247c <prvAddNewTaskToReadyList+0x10c>)
34002390:	687b      	ldr	r3, [r7, #4]
34002392:	6013      	str	r3, [r2, #0]

                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
34002394:	4b38      	ldr	r3, [pc, #224]	@ (34002478 <prvAddNewTaskToReadyList+0x108>)
34002396:	681b      	ldr	r3, [r3, #0]
34002398:	2b01      	cmp	r3, #1
3400239a:	d110      	bne.n	340023be <prvAddNewTaskToReadyList+0x4e>
                {
                    /* This is the first task to be created so do the preliminary
                     * initialisation required.  We will not recover if this call
                     * fails, but we will report the failure. */
                    prvInitialiseTaskLists();
3400239c:	f000 fd6c 	bl	34002e78 <prvInitialiseTaskLists>
340023a0:	e00d      	b.n	340023be <prvAddNewTaskToReadyList+0x4e>
            else
            {
                /* If the scheduler is not already running, make this task the
                 * current task if it is the highest priority task to be created
                 * so far. */
                if( xSchedulerRunning == pdFALSE )
340023a2:	4b37      	ldr	r3, [pc, #220]	@ (34002480 <prvAddNewTaskToReadyList+0x110>)
340023a4:	681b      	ldr	r3, [r3, #0]
340023a6:	2b00      	cmp	r3, #0
340023a8:	d109      	bne.n	340023be <prvAddNewTaskToReadyList+0x4e>
                {
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
340023aa:	4b34      	ldr	r3, [pc, #208]	@ (3400247c <prvAddNewTaskToReadyList+0x10c>)
340023ac:	681b      	ldr	r3, [r3, #0]
340023ae:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340023b0:	687b      	ldr	r3, [r7, #4]
340023b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340023b4:	429a      	cmp	r2, r3
340023b6:	d802      	bhi.n	340023be <prvAddNewTaskToReadyList+0x4e>
                    {
                        pxCurrentTCB = pxNewTCB;
340023b8:	4a30      	ldr	r2, [pc, #192]	@ (3400247c <prvAddNewTaskToReadyList+0x10c>)
340023ba:	687b      	ldr	r3, [r7, #4]
340023bc:	6013      	str	r3, [r2, #0]
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            uxTaskNumber++;
340023be:	4b31      	ldr	r3, [pc, #196]	@ (34002484 <prvAddNewTaskToReadyList+0x114>)
340023c0:	681b      	ldr	r3, [r3, #0]
340023c2:	3301      	adds	r3, #1
340023c4:	4a2f      	ldr	r2, [pc, #188]	@ (34002484 <prvAddNewTaskToReadyList+0x114>)
340023c6:	6013      	str	r3, [r2, #0]

            #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
340023c8:	4b2e      	ldr	r3, [pc, #184]	@ (34002484 <prvAddNewTaskToReadyList+0x114>)
340023ca:	681a      	ldr	r2, [r3, #0]
340023cc:	687b      	ldr	r3, [r7, #4]
340023ce:	641a      	str	r2, [r3, #64]	@ 0x40
            }
            #endif /* configUSE_TRACE_FACILITY */
            traceTASK_CREATE( pxNewTCB );

            prvAddTaskToReadyList( pxNewTCB );
340023d0:	687b      	ldr	r3, [r7, #4]
340023d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340023d4:	2201      	movs	r2, #1
340023d6:	409a      	lsls	r2, r3
340023d8:	4b2b      	ldr	r3, [pc, #172]	@ (34002488 <prvAddNewTaskToReadyList+0x118>)
340023da:	681b      	ldr	r3, [r3, #0]
340023dc:	4313      	orrs	r3, r2
340023de:	4a2a      	ldr	r2, [pc, #168]	@ (34002488 <prvAddNewTaskToReadyList+0x118>)
340023e0:	6013      	str	r3, [r2, #0]
340023e2:	687b      	ldr	r3, [r7, #4]
340023e4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340023e6:	4929      	ldr	r1, [pc, #164]	@ (3400248c <prvAddNewTaskToReadyList+0x11c>)
340023e8:	4613      	mov	r3, r2
340023ea:	009b      	lsls	r3, r3, #2
340023ec:	4413      	add	r3, r2
340023ee:	009b      	lsls	r3, r3, #2
340023f0:	440b      	add	r3, r1
340023f2:	3304      	adds	r3, #4
340023f4:	681b      	ldr	r3, [r3, #0]
340023f6:	60fb      	str	r3, [r7, #12]
340023f8:	687b      	ldr	r3, [r7, #4]
340023fa:	68fa      	ldr	r2, [r7, #12]
340023fc:	609a      	str	r2, [r3, #8]
340023fe:	68fb      	ldr	r3, [r7, #12]
34002400:	689a      	ldr	r2, [r3, #8]
34002402:	687b      	ldr	r3, [r7, #4]
34002404:	60da      	str	r2, [r3, #12]
34002406:	68fb      	ldr	r3, [r7, #12]
34002408:	689b      	ldr	r3, [r3, #8]
3400240a:	687a      	ldr	r2, [r7, #4]
3400240c:	3204      	adds	r2, #4
3400240e:	605a      	str	r2, [r3, #4]
34002410:	687b      	ldr	r3, [r7, #4]
34002412:	1d1a      	adds	r2, r3, #4
34002414:	68fb      	ldr	r3, [r7, #12]
34002416:	609a      	str	r2, [r3, #8]
34002418:	687b      	ldr	r3, [r7, #4]
3400241a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400241c:	4613      	mov	r3, r2
3400241e:	009b      	lsls	r3, r3, #2
34002420:	4413      	add	r3, r2
34002422:	009b      	lsls	r3, r3, #2
34002424:	4a19      	ldr	r2, [pc, #100]	@ (3400248c <prvAddNewTaskToReadyList+0x11c>)
34002426:	441a      	add	r2, r3
34002428:	687b      	ldr	r3, [r7, #4]
3400242a:	615a      	str	r2, [r3, #20]
3400242c:	687b      	ldr	r3, [r7, #4]
3400242e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002430:	4916      	ldr	r1, [pc, #88]	@ (3400248c <prvAddNewTaskToReadyList+0x11c>)
34002432:	4613      	mov	r3, r2
34002434:	009b      	lsls	r3, r3, #2
34002436:	4413      	add	r3, r2
34002438:	009b      	lsls	r3, r3, #2
3400243a:	440b      	add	r3, r1
3400243c:	681b      	ldr	r3, [r3, #0]
3400243e:	687a      	ldr	r2, [r7, #4]
34002440:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
34002442:	1c59      	adds	r1, r3, #1
34002444:	4811      	ldr	r0, [pc, #68]	@ (3400248c <prvAddNewTaskToReadyList+0x11c>)
34002446:	4613      	mov	r3, r2
34002448:	009b      	lsls	r3, r3, #2
3400244a:	4413      	add	r3, r2
3400244c:	009b      	lsls	r3, r3, #2
3400244e:	4403      	add	r3, r0
34002450:	6019      	str	r1, [r3, #0]

            portSETUP_TCB( pxNewTCB );
        }
        taskEXIT_CRITICAL();
34002452:	f7ff f98f 	bl	34001774 <vPortExitCritical>

        if( xSchedulerRunning != pdFALSE )
34002456:	4b0a      	ldr	r3, [pc, #40]	@ (34002480 <prvAddNewTaskToReadyList+0x110>)
34002458:	681b      	ldr	r3, [r3, #0]
3400245a:	2b00      	cmp	r3, #0
3400245c:	d008      	beq.n	34002470 <prvAddNewTaskToReadyList+0x100>
        {
            /* If the created task is of a higher priority than the current task
             * then it should run now. */
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
3400245e:	4b07      	ldr	r3, [pc, #28]	@ (3400247c <prvAddNewTaskToReadyList+0x10c>)
34002460:	681b      	ldr	r3, [r3, #0]
34002462:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002464:	687b      	ldr	r3, [r7, #4]
34002466:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34002468:	429a      	cmp	r2, r3
3400246a:	d201      	bcs.n	34002470 <prvAddNewTaskToReadyList+0x100>
3400246c:	f7ff f95e 	bl	3400172c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
34002470:	bf00      	nop
34002472:	3710      	adds	r7, #16
34002474:	46bd      	mov	sp, r7
34002476:	bd80      	pop	{r7, pc}
34002478:	34003f84 	.word	0x34003f84
3400247c:	34003c90 	.word	0x34003c90
34002480:	34003f90 	.word	0x34003f90
34002484:	34003fa0 	.word	0x34003fa0
34002488:	34003f8c 	.word	0x34003f8c
3400248c:	34003c94 	.word	0x34003c94

34002490 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
34002490:	b580      	push	{r7, lr}
34002492:	b084      	sub	sp, #16
34002494:	af00      	add	r7, sp, #0
34002496:	6078      	str	r0, [r7, #4]
        BaseType_t xAlreadyYielded = pdFALSE;
34002498:	2300      	movs	r3, #0
3400249a:	60fb      	str	r3, [r7, #12]

        traceENTER_vTaskDelay( xTicksToDelay );

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
3400249c:	687b      	ldr	r3, [r7, #4]
3400249e:	2b00      	cmp	r3, #0
340024a0:	d010      	beq.n	340024c4 <vTaskDelay+0x34>
        {
            vTaskSuspendAll();
340024a2:	f000 f89b 	bl	340025dc <vTaskSuspendAll>
            {
                configASSERT( uxSchedulerSuspended == 1U );
340024a6:	4b0c      	ldr	r3, [pc, #48]	@ (340024d8 <vTaskDelay+0x48>)
340024a8:	681b      	ldr	r3, [r3, #0]
340024aa:	2b01      	cmp	r3, #1
340024ac:	d003      	beq.n	340024b6 <vTaskDelay+0x26>
340024ae:	f7ff faf5 	bl	34001a9c <ulSetInterruptMask>
340024b2:	bf00      	nop
340024b4:	e7fd      	b.n	340024b2 <vTaskDelay+0x22>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
340024b6:	2100      	movs	r1, #0
340024b8:	6878      	ldr	r0, [r7, #4]
340024ba:	f000 fe2b 	bl	34003114 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
340024be:	f000 f89b 	bl	340025f8 <xTaskResumeAll>
340024c2:	60f8      	str	r0, [r7, #12]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
340024c4:	68fb      	ldr	r3, [r7, #12]
340024c6:	2b00      	cmp	r3, #0
340024c8:	d101      	bne.n	340024ce <vTaskDelay+0x3e>
        {
            taskYIELD_WITHIN_API();
340024ca:	f7ff f92f 	bl	3400172c <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_vTaskDelay();
    }
340024ce:	bf00      	nop
340024d0:	3710      	adds	r7, #16
340024d2:	46bd      	mov	sp, r7
340024d4:	bd80      	pop	{r7, pc}
340024d6:	bf00      	nop
340024d8:	34003fac 	.word	0x34003fac

340024dc <prvCreateIdleTasks>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

static BaseType_t prvCreateIdleTasks( void )
{
340024dc:	b580      	push	{r7, lr}
340024de:	b08a      	sub	sp, #40	@ 0x28
340024e0:	af02      	add	r7, sp, #8
    BaseType_t xReturn = pdPASS;
340024e2:	2301      	movs	r3, #1
340024e4:	61fb      	str	r3, [r7, #28]
    BaseType_t xCoreID;
    char cIdleName[ configMAX_TASK_NAME_LEN ];
    TaskFunction_t pxIdleTaskFunction = NULL;
340024e6:	2300      	movs	r3, #0
340024e8:	613b      	str	r3, [r7, #16]
    BaseType_t xIdleTaskNameIndex;

    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
340024ea:	2300      	movs	r3, #0
340024ec:	617b      	str	r3, [r7, #20]
340024ee:	e011      	b.n	34002514 <prvCreateIdleTasks+0x38>
    {
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
340024f0:	4a1d      	ldr	r2, [pc, #116]	@ (34002568 <prvCreateIdleTasks+0x8c>)
340024f2:	697b      	ldr	r3, [r7, #20]
340024f4:	4413      	add	r3, r2
340024f6:	7819      	ldrb	r1, [r3, #0]
340024f8:	1d3a      	adds	r2, r7, #4
340024fa:	697b      	ldr	r3, [r7, #20]
340024fc:	4413      	add	r3, r2
340024fe:	460a      	mov	r2, r1
34002500:	701a      	strb	r2, [r3, #0]

        /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
         * configMAX_TASK_NAME_LEN characters just in case the memory after the
         * string is not accessible (extremely unlikely). */
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
34002502:	1d3a      	adds	r2, r7, #4
34002504:	697b      	ldr	r3, [r7, #20]
34002506:	4413      	add	r3, r2
34002508:	781b      	ldrb	r3, [r3, #0]
3400250a:	2b00      	cmp	r3, #0
3400250c:	d006      	beq.n	3400251c <prvCreateIdleTasks+0x40>
    for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
3400250e:	697b      	ldr	r3, [r7, #20]
34002510:	3301      	adds	r3, #1
34002512:	617b      	str	r3, [r7, #20]
34002514:	697b      	ldr	r3, [r7, #20]
34002516:	2b09      	cmp	r3, #9
34002518:	ddea      	ble.n	340024f0 <prvCreateIdleTasks+0x14>
3400251a:	e000      	b.n	3400251e <prvCreateIdleTasks+0x42>
        {
            break;
3400251c:	bf00      	nop
            mtCOVERAGE_TEST_MARKER();
        }
    }

    /* Add each idle task at the lowest priority. */
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
3400251e:	2300      	movs	r3, #0
34002520:	61bb      	str	r3, [r7, #24]
34002522:	e016      	b.n	34002552 <prvCreateIdleTasks+0x76>
    {
        #if ( configNUMBER_OF_CORES == 1 )
        {
            pxIdleTaskFunction = prvIdleTask;
34002524:	4b11      	ldr	r3, [pc, #68]	@ (3400256c <prvCreateIdleTasks+0x90>)
34002526:	613b      	str	r3, [r7, #16]
            }
        }
        #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( pxIdleTaskFunction,
34002528:	69bb      	ldr	r3, [r7, #24]
3400252a:	009b      	lsls	r3, r3, #2
3400252c:	4a10      	ldr	r2, [pc, #64]	@ (34002570 <prvCreateIdleTasks+0x94>)
3400252e:	4413      	add	r3, r2
34002530:	1d39      	adds	r1, r7, #4
34002532:	9301      	str	r3, [sp, #4]
34002534:	2300      	movs	r3, #0
34002536:	9300      	str	r3, [sp, #0]
34002538:	2300      	movs	r3, #0
3400253a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400253e:	6938      	ldr	r0, [r7, #16]
34002540:	f7ff fe70 	bl	34002224 <xTaskCreate>
34002544:	61f8      	str	r0, [r7, #28]
                                   &xIdleTaskHandles[ xCoreID ] );
        }
        #endif /* configSUPPORT_STATIC_ALLOCATION */

        /* Break the loop if any of the idle task is failed to be created. */
        if( xReturn == pdFAIL )
34002546:	69fb      	ldr	r3, [r7, #28]
34002548:	2b00      	cmp	r3, #0
3400254a:	d006      	beq.n	3400255a <prvCreateIdleTasks+0x7e>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
3400254c:	69bb      	ldr	r3, [r7, #24]
3400254e:	3301      	adds	r3, #1
34002550:	61bb      	str	r3, [r7, #24]
34002552:	69bb      	ldr	r3, [r7, #24]
34002554:	2b00      	cmp	r3, #0
34002556:	dde5      	ble.n	34002524 <prvCreateIdleTasks+0x48>
34002558:	e000      	b.n	3400255c <prvCreateIdleTasks+0x80>
        {
            break;
3400255a:	bf00      	nop
            }
            #endif
        }
    }

    return xReturn;
3400255c:	69fb      	ldr	r3, [r7, #28]
}
3400255e:	4618      	mov	r0, r3
34002560:	3720      	adds	r7, #32
34002562:	46bd      	mov	sp, r7
34002564:	bd80      	pop	{r7, pc}
34002566:	bf00      	nop
34002568:	34003c14 	.word	0x34003c14
3400256c:	34002e59 	.word	0x34002e59
34002570:	34003fa8 	.word	0x34003fa8

34002574 <vTaskStartScheduler>:

/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
34002574:	b580      	push	{r7, lr}
34002576:	b082      	sub	sp, #8
34002578:	af00      	add	r7, sp, #0
         * the number of bits as confNUMBER_OF_CORES. */
        configASSERT( ( sizeof( UBaseType_t ) * taskBITS_PER_BYTE ) >= configNUMBER_OF_CORES );
    }
    #endif /* #if ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) */

    xReturn = prvCreateIdleTasks();
3400257a:	f7ff ffaf 	bl	340024dc <prvCreateIdleTasks>
3400257e:	6078      	str	r0, [r7, #4]

    #if ( configUSE_TIMERS == 1 )
    {
        if( xReturn == pdPASS )
34002580:	687b      	ldr	r3, [r7, #4]
34002582:	2b01      	cmp	r3, #1
34002584:	d102      	bne.n	3400258c <vTaskStartScheduler+0x18>
        {
            xReturn = xTimerCreateTimerTask();
34002586:	f001 f879 	bl	3400367c <xTimerCreateTimerTask>
3400258a:	6078      	str	r0, [r7, #4]
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
3400258c:	687b      	ldr	r3, [r7, #4]
3400258e:	2b01      	cmp	r3, #1
34002590:	d10e      	bne.n	340025b0 <vTaskStartScheduler+0x3c>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
34002592:	f7ff fa83 	bl	34001a9c <ulSetInterruptMask>
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
34002596:	4b0d      	ldr	r3, [pc, #52]	@ (340025cc <vTaskStartScheduler+0x58>)
34002598:	f04f 32ff 	mov.w	r2, #4294967295
3400259c:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
3400259e:	4b0c      	ldr	r3, [pc, #48]	@ (340025d0 <vTaskStartScheduler+0x5c>)
340025a0:	2201      	movs	r2, #1
340025a2:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
340025a4:	4b0b      	ldr	r3, [pc, #44]	@ (340025d4 <vTaskStartScheduler+0x60>)
340025a6:	2200      	movs	r2, #0
340025a8:	601a      	str	r2, [r3, #0]
        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */

        /* The return value for xPortStartScheduler is not required
         * hence using a void datatype. */
        ( void ) xPortStartScheduler();
340025aa:	f7ff f9bb 	bl	34001924 <xPortStartScheduler>
340025ae:	e007      	b.n	340025c0 <vTaskStartScheduler+0x4c>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
340025b0:	687b      	ldr	r3, [r7, #4]
340025b2:	f1b3 3fff 	cmp.w	r3, #4294967295
340025b6:	d103      	bne.n	340025c0 <vTaskStartScheduler+0x4c>
340025b8:	f7ff fa70 	bl	34001a9c <ulSetInterruptMask>
340025bc:	bf00      	nop
340025be:	e7fd      	b.n	340025bc <vTaskStartScheduler+0x48>
     * meaning xIdleTaskHandles are not used anywhere else. */
    ( void ) xIdleTaskHandles;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
340025c0:	4b05      	ldr	r3, [pc, #20]	@ (340025d8 <vTaskStartScheduler+0x64>)
340025c2:	681b      	ldr	r3, [r3, #0]

    traceRETURN_vTaskStartScheduler();
}
340025c4:	bf00      	nop
340025c6:	3708      	adds	r7, #8
340025c8:	46bd      	mov	sp, r7
340025ca:	bd80      	pop	{r7, pc}
340025cc:	34003fa4 	.word	0x34003fa4
340025d0:	34003f90 	.word	0x34003f90
340025d4:	34003f88 	.word	0x34003f88
340025d8:	34003c24 	.word	0x34003c24

340025dc <vTaskSuspendAll>:
    traceRETURN_vTaskEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
340025dc:	b480      	push	{r7}
340025de:	af00      	add	r7, sp, #0
         * do not otherwise exhibit real time behaviour. */
        portSOFTWARE_BARRIER();

        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
         * is used to allow calls to vTaskSuspendAll() to nest. */
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
340025e0:	4b04      	ldr	r3, [pc, #16]	@ (340025f4 <vTaskSuspendAll+0x18>)
340025e2:	681b      	ldr	r3, [r3, #0]
340025e4:	3301      	adds	r3, #1
340025e6:	4a03      	ldr	r2, [pc, #12]	@ (340025f4 <vTaskSuspendAll+0x18>)
340025e8:	6013      	str	r3, [r2, #0]
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskSuspendAll();
}
340025ea:	bf00      	nop
340025ec:	46bd      	mov	sp, r7
340025ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340025f2:	4770      	bx	lr
340025f4:	34003fac 	.word	0x34003fac

340025f8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
340025f8:	b580      	push	{r7, lr}
340025fa:	b088      	sub	sp, #32
340025fc:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
340025fe:	2300      	movs	r3, #0
34002600:	61fb      	str	r3, [r7, #28]
    BaseType_t xAlreadyYielded = pdFALSE;
34002602:	2300      	movs	r3, #0
34002604:	61bb      	str	r3, [r7, #24]
        /* It is possible that an ISR caused a task to be removed from an event
         * list while the scheduler was suspended.  If this was the case then the
         * removed task will have been added to the xPendingReadyList.  Once the
         * scheduler has been resumed it is safe to move all the pending ready
         * tasks from this list into their appropriate ready list. */
        taskENTER_CRITICAL();
34002606:	f7ff f8a3 	bl	34001750 <vPortEnterCritical>
        {
            BaseType_t xCoreID;
            xCoreID = ( BaseType_t ) portGET_CORE_ID();
3400260a:	2300      	movs	r3, #0
3400260c:	613b      	str	r3, [r7, #16]

            /* If uxSchedulerSuspended is zero then this function does not match a
             * previous call to vTaskSuspendAll(). */
            configASSERT( uxSchedulerSuspended != 0U );
3400260e:	4b6e      	ldr	r3, [pc, #440]	@ (340027c8 <xTaskResumeAll+0x1d0>)
34002610:	681b      	ldr	r3, [r3, #0]
34002612:	2b00      	cmp	r3, #0
34002614:	d103      	bne.n	3400261e <xTaskResumeAll+0x26>
34002616:	f7ff fa41 	bl	34001a9c <ulSetInterruptMask>
3400261a:	bf00      	nop
3400261c:	e7fd      	b.n	3400261a <xTaskResumeAll+0x22>

            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
3400261e:	4b6a      	ldr	r3, [pc, #424]	@ (340027c8 <xTaskResumeAll+0x1d0>)
34002620:	681b      	ldr	r3, [r3, #0]
34002622:	3b01      	subs	r3, #1
34002624:	4a68      	ldr	r2, [pc, #416]	@ (340027c8 <xTaskResumeAll+0x1d0>)
34002626:	6013      	str	r3, [r2, #0]
            portRELEASE_TASK_LOCK();

            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
34002628:	4b67      	ldr	r3, [pc, #412]	@ (340027c8 <xTaskResumeAll+0x1d0>)
3400262a:	681b      	ldr	r3, [r3, #0]
3400262c:	2b00      	cmp	r3, #0
3400262e:	f040 80c4 	bne.w	340027ba <xTaskResumeAll+0x1c2>
            {
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
34002632:	4b66      	ldr	r3, [pc, #408]	@ (340027cc <xTaskResumeAll+0x1d4>)
34002634:	681b      	ldr	r3, [r3, #0]
34002636:	2b00      	cmp	r3, #0
34002638:	f000 80bf 	beq.w	340027ba <xTaskResumeAll+0x1c2>
                {
                    /* Move any readied tasks from the pending list into the
                     * appropriate ready list. */
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
3400263c:	e08e      	b.n	3400275c <xTaskResumeAll+0x164>
                    {
                        /* MISRA Ref 11.5.3 [Void pointer assignment] */
                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
3400263e:	4b64      	ldr	r3, [pc, #400]	@ (340027d0 <xTaskResumeAll+0x1d8>)
34002640:	68db      	ldr	r3, [r3, #12]
34002642:	68db      	ldr	r3, [r3, #12]
34002644:	61fb      	str	r3, [r7, #28]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
34002646:	69fb      	ldr	r3, [r7, #28]
34002648:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400264a:	60fb      	str	r3, [r7, #12]
3400264c:	69fb      	ldr	r3, [r7, #28]
3400264e:	69db      	ldr	r3, [r3, #28]
34002650:	69fa      	ldr	r2, [r7, #28]
34002652:	6a12      	ldr	r2, [r2, #32]
34002654:	609a      	str	r2, [r3, #8]
34002656:	69fb      	ldr	r3, [r7, #28]
34002658:	6a1b      	ldr	r3, [r3, #32]
3400265a:	69fa      	ldr	r2, [r7, #28]
3400265c:	69d2      	ldr	r2, [r2, #28]
3400265e:	605a      	str	r2, [r3, #4]
34002660:	68fb      	ldr	r3, [r7, #12]
34002662:	685a      	ldr	r2, [r3, #4]
34002664:	69fb      	ldr	r3, [r7, #28]
34002666:	3318      	adds	r3, #24
34002668:	429a      	cmp	r2, r3
3400266a:	d103      	bne.n	34002674 <xTaskResumeAll+0x7c>
3400266c:	69fb      	ldr	r3, [r7, #28]
3400266e:	6a1a      	ldr	r2, [r3, #32]
34002670:	68fb      	ldr	r3, [r7, #12]
34002672:	605a      	str	r2, [r3, #4]
34002674:	69fb      	ldr	r3, [r7, #28]
34002676:	2200      	movs	r2, #0
34002678:	629a      	str	r2, [r3, #40]	@ 0x28
3400267a:	68fb      	ldr	r3, [r7, #12]
3400267c:	681b      	ldr	r3, [r3, #0]
3400267e:	1e5a      	subs	r2, r3, #1
34002680:	68fb      	ldr	r3, [r7, #12]
34002682:	601a      	str	r2, [r3, #0]
                        portMEMORY_BARRIER();
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
34002684:	69fb      	ldr	r3, [r7, #28]
34002686:	695b      	ldr	r3, [r3, #20]
34002688:	60bb      	str	r3, [r7, #8]
3400268a:	69fb      	ldr	r3, [r7, #28]
3400268c:	689b      	ldr	r3, [r3, #8]
3400268e:	69fa      	ldr	r2, [r7, #28]
34002690:	68d2      	ldr	r2, [r2, #12]
34002692:	609a      	str	r2, [r3, #8]
34002694:	69fb      	ldr	r3, [r7, #28]
34002696:	68db      	ldr	r3, [r3, #12]
34002698:	69fa      	ldr	r2, [r7, #28]
3400269a:	6892      	ldr	r2, [r2, #8]
3400269c:	605a      	str	r2, [r3, #4]
3400269e:	68bb      	ldr	r3, [r7, #8]
340026a0:	685a      	ldr	r2, [r3, #4]
340026a2:	69fb      	ldr	r3, [r7, #28]
340026a4:	3304      	adds	r3, #4
340026a6:	429a      	cmp	r2, r3
340026a8:	d103      	bne.n	340026b2 <xTaskResumeAll+0xba>
340026aa:	69fb      	ldr	r3, [r7, #28]
340026ac:	68da      	ldr	r2, [r3, #12]
340026ae:	68bb      	ldr	r3, [r7, #8]
340026b0:	605a      	str	r2, [r3, #4]
340026b2:	69fb      	ldr	r3, [r7, #28]
340026b4:	2200      	movs	r2, #0
340026b6:	615a      	str	r2, [r3, #20]
340026b8:	68bb      	ldr	r3, [r7, #8]
340026ba:	681b      	ldr	r3, [r3, #0]
340026bc:	1e5a      	subs	r2, r3, #1
340026be:	68bb      	ldr	r3, [r7, #8]
340026c0:	601a      	str	r2, [r3, #0]
                        prvAddTaskToReadyList( pxTCB );
340026c2:	69fb      	ldr	r3, [r7, #28]
340026c4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340026c6:	2201      	movs	r2, #1
340026c8:	409a      	lsls	r2, r3
340026ca:	4b42      	ldr	r3, [pc, #264]	@ (340027d4 <xTaskResumeAll+0x1dc>)
340026cc:	681b      	ldr	r3, [r3, #0]
340026ce:	4313      	orrs	r3, r2
340026d0:	4a40      	ldr	r2, [pc, #256]	@ (340027d4 <xTaskResumeAll+0x1dc>)
340026d2:	6013      	str	r3, [r2, #0]
340026d4:	69fb      	ldr	r3, [r7, #28]
340026d6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340026d8:	493f      	ldr	r1, [pc, #252]	@ (340027d8 <xTaskResumeAll+0x1e0>)
340026da:	4613      	mov	r3, r2
340026dc:	009b      	lsls	r3, r3, #2
340026de:	4413      	add	r3, r2
340026e0:	009b      	lsls	r3, r3, #2
340026e2:	440b      	add	r3, r1
340026e4:	3304      	adds	r3, #4
340026e6:	681b      	ldr	r3, [r3, #0]
340026e8:	607b      	str	r3, [r7, #4]
340026ea:	69fb      	ldr	r3, [r7, #28]
340026ec:	687a      	ldr	r2, [r7, #4]
340026ee:	609a      	str	r2, [r3, #8]
340026f0:	687b      	ldr	r3, [r7, #4]
340026f2:	689a      	ldr	r2, [r3, #8]
340026f4:	69fb      	ldr	r3, [r7, #28]
340026f6:	60da      	str	r2, [r3, #12]
340026f8:	687b      	ldr	r3, [r7, #4]
340026fa:	689b      	ldr	r3, [r3, #8]
340026fc:	69fa      	ldr	r2, [r7, #28]
340026fe:	3204      	adds	r2, #4
34002700:	605a      	str	r2, [r3, #4]
34002702:	69fb      	ldr	r3, [r7, #28]
34002704:	1d1a      	adds	r2, r3, #4
34002706:	687b      	ldr	r3, [r7, #4]
34002708:	609a      	str	r2, [r3, #8]
3400270a:	69fb      	ldr	r3, [r7, #28]
3400270c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400270e:	4613      	mov	r3, r2
34002710:	009b      	lsls	r3, r3, #2
34002712:	4413      	add	r3, r2
34002714:	009b      	lsls	r3, r3, #2
34002716:	4a30      	ldr	r2, [pc, #192]	@ (340027d8 <xTaskResumeAll+0x1e0>)
34002718:	441a      	add	r2, r3
3400271a:	69fb      	ldr	r3, [r7, #28]
3400271c:	615a      	str	r2, [r3, #20]
3400271e:	69fb      	ldr	r3, [r7, #28]
34002720:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002722:	492d      	ldr	r1, [pc, #180]	@ (340027d8 <xTaskResumeAll+0x1e0>)
34002724:	4613      	mov	r3, r2
34002726:	009b      	lsls	r3, r3, #2
34002728:	4413      	add	r3, r2
3400272a:	009b      	lsls	r3, r3, #2
3400272c:	440b      	add	r3, r1
3400272e:	681b      	ldr	r3, [r3, #0]
34002730:	69fa      	ldr	r2, [r7, #28]
34002732:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
34002734:	1c59      	adds	r1, r3, #1
34002736:	4828      	ldr	r0, [pc, #160]	@ (340027d8 <xTaskResumeAll+0x1e0>)
34002738:	4613      	mov	r3, r2
3400273a:	009b      	lsls	r3, r3, #2
3400273c:	4413      	add	r3, r2
3400273e:	009b      	lsls	r3, r3, #2
34002740:	4403      	add	r3, r0
34002742:	6019      	str	r1, [r3, #0]

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            /* If the moved task has a priority higher than the current
                             * task then a yield must be performed. */
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
34002744:	69fb      	ldr	r3, [r7, #28]
34002746:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002748:	4b24      	ldr	r3, [pc, #144]	@ (340027dc <xTaskResumeAll+0x1e4>)
3400274a:	681b      	ldr	r3, [r3, #0]
3400274c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400274e:	429a      	cmp	r2, r3
34002750:	d904      	bls.n	3400275c <xTaskResumeAll+0x164>
                            {
                                xYieldPendings[ xCoreID ] = pdTRUE;
34002752:	4a23      	ldr	r2, [pc, #140]	@ (340027e0 <xTaskResumeAll+0x1e8>)
34002754:	693b      	ldr	r3, [r7, #16]
34002756:	2101      	movs	r1, #1
34002758:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
3400275c:	4b1c      	ldr	r3, [pc, #112]	@ (340027d0 <xTaskResumeAll+0x1d8>)
3400275e:	681b      	ldr	r3, [r3, #0]
34002760:	2b00      	cmp	r3, #0
34002762:	f47f af6c 	bne.w	3400263e <xTaskResumeAll+0x46>
                             * which sets xYieldPendings for the current core to pdTRUE. */
                        }
                        #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
                    }

                    if( pxTCB != NULL )
34002766:	69fb      	ldr	r3, [r7, #28]
34002768:	2b00      	cmp	r3, #0
3400276a:	d001      	beq.n	34002770 <xTaskResumeAll+0x178>
                         * which may have prevented the next unblock time from being
                         * re-calculated, in which case re-calculate it now.  Mainly
                         * important for low power tickless implementations, where
                         * this can prevent an unnecessary exit from low power
                         * state. */
                        prvResetNextTaskUnblockTime();
3400276c:	f000 fc02 	bl	34002f74 <prvResetNextTaskUnblockTime>
                     * It should be safe to call xTaskIncrementTick here from any core
                     * since we are in a critical section and xTaskIncrementTick itself
                     * protects itself within a critical section. Suspending the scheduler
                     * from any core causes xTaskIncrementTick to increment uxPendedCounts. */
                    {
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
34002770:	4b1c      	ldr	r3, [pc, #112]	@ (340027e4 <xTaskResumeAll+0x1ec>)
34002772:	681b      	ldr	r3, [r3, #0]
34002774:	617b      	str	r3, [r7, #20]

                        if( xPendedCounts > ( TickType_t ) 0U )
34002776:	697b      	ldr	r3, [r7, #20]
34002778:	2b00      	cmp	r3, #0
3400277a:	d012      	beq.n	340027a2 <xTaskResumeAll+0x1aa>
                        {
                            do
                            {
                                if( xTaskIncrementTick() != pdFALSE )
3400277c:	f000 f850 	bl	34002820 <xTaskIncrementTick>
34002780:	4603      	mov	r3, r0
34002782:	2b00      	cmp	r3, #0
34002784:	d004      	beq.n	34002790 <xTaskResumeAll+0x198>
                                {
                                    /* Other cores are interrupted from
                                     * within xTaskIncrementTick(). */
                                    xYieldPendings[ xCoreID ] = pdTRUE;
34002786:	4a16      	ldr	r2, [pc, #88]	@ (340027e0 <xTaskResumeAll+0x1e8>)
34002788:	693b      	ldr	r3, [r7, #16]
3400278a:	2101      	movs	r1, #1
3400278c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }

                                --xPendedCounts;
34002790:	697b      	ldr	r3, [r7, #20]
34002792:	3b01      	subs	r3, #1
34002794:	617b      	str	r3, [r7, #20]
                            } while( xPendedCounts > ( TickType_t ) 0U );
34002796:	697b      	ldr	r3, [r7, #20]
34002798:	2b00      	cmp	r3, #0
3400279a:	d1ef      	bne.n	3400277c <xTaskResumeAll+0x184>

                            xPendedTicks = 0;
3400279c:	4b11      	ldr	r3, [pc, #68]	@ (340027e4 <xTaskResumeAll+0x1ec>)
3400279e:	2200      	movs	r2, #0
340027a0:	601a      	str	r2, [r3, #0]
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }

                    if( xYieldPendings[ xCoreID ] != pdFALSE )
340027a2:	4a0f      	ldr	r2, [pc, #60]	@ (340027e0 <xTaskResumeAll+0x1e8>)
340027a4:	693b      	ldr	r3, [r7, #16]
340027a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340027aa:	2b00      	cmp	r3, #0
340027ac:	d005      	beq.n	340027ba <xTaskResumeAll+0x1c2>
                    {
                        #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
340027ae:	2301      	movs	r3, #1
340027b0:	61bb      	str	r3, [r7, #24]
                        }
                        #endif /* #if ( configUSE_PREEMPTION != 0 ) */

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
340027b2:	4b0a      	ldr	r3, [pc, #40]	@ (340027dc <xTaskResumeAll+0x1e4>)
340027b4:	681b      	ldr	r3, [r3, #0]
340027b6:	f7fe ffb9 	bl	3400172c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
340027ba:	f7fe ffdb 	bl	34001774 <vPortExitCritical>
    }

    traceRETURN_xTaskResumeAll( xAlreadyYielded );

    return xAlreadyYielded;
340027be:	69bb      	ldr	r3, [r7, #24]
}
340027c0:	4618      	mov	r0, r3
340027c2:	3720      	adds	r7, #32
340027c4:	46bd      	mov	sp, r7
340027c6:	bd80      	pop	{r7, pc}
340027c8:	34003fac 	.word	0x34003fac
340027cc:	34003f84 	.word	0x34003f84
340027d0:	34003f44 	.word	0x34003f44
340027d4:	34003f8c 	.word	0x34003f8c
340027d8:	34003c94 	.word	0x34003c94
340027dc:	34003c90 	.word	0x34003c90
340027e0:	34003f98 	.word	0x34003f98
340027e4:	34003f94 	.word	0x34003f94

340027e8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
340027e8:	b480      	push	{r7}
340027ea:	b083      	sub	sp, #12
340027ec:	af00      	add	r7, sp, #0
    traceENTER_xTaskGetTickCount();

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
340027ee:	4b05      	ldr	r3, [pc, #20]	@ (34002804 <xTaskGetTickCount+0x1c>)
340027f0:	681b      	ldr	r3, [r3, #0]
340027f2:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    traceRETURN_xTaskGetTickCount( xTicks );

    return xTicks;
340027f4:	687b      	ldr	r3, [r7, #4]
}
340027f6:	4618      	mov	r0, r3
340027f8:	370c      	adds	r7, #12
340027fa:	46bd      	mov	sp, r7
340027fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34002800:	4770      	bx	lr
34002802:	bf00      	nop
34002804:	34003f88 	.word	0x34003f88

34002808 <uxTaskGetNumberOfTasks>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
34002808:	b480      	push	{r7}
3400280a:	af00      	add	r7, sp, #0

    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    traceRETURN_uxTaskGetNumberOfTasks( uxCurrentNumberOfTasks );

    return uxCurrentNumberOfTasks;
3400280c:	4b03      	ldr	r3, [pc, #12]	@ (3400281c <uxTaskGetNumberOfTasks+0x14>)
3400280e:	681b      	ldr	r3, [r3, #0]
}
34002810:	4618      	mov	r0, r3
34002812:	46bd      	mov	sp, r7
34002814:	f85d 7b04 	ldr.w	r7, [sp], #4
34002818:	4770      	bx	lr
3400281a:	bf00      	nop
3400281c:	34003f84 	.word	0x34003f84

34002820 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
34002820:	b580      	push	{r7, lr}
34002822:	b088      	sub	sp, #32
34002824:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
34002826:	2300      	movs	r3, #0
34002828:	61fb      	str	r3, [r7, #28]

    /* Tick increment should occur on every kernel timer event. Core 0 has the
     * responsibility to increment the tick, or increment the pended ticks if the
     * scheduler is suspended.  If pended ticks is greater than zero, the core that
     * calls xTaskResumeAll has the responsibility to increment the tick. */
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
3400282a:	4b7b      	ldr	r3, [pc, #492]	@ (34002a18 <xTaskIncrementTick+0x1f8>)
3400282c:	681b      	ldr	r3, [r3, #0]
3400282e:	2b00      	cmp	r3, #0
34002830:	f040 80e7 	bne.w	34002a02 <xTaskIncrementTick+0x1e2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
34002834:	4b79      	ldr	r3, [pc, #484]	@ (34002a1c <xTaskIncrementTick+0x1fc>)
34002836:	681b      	ldr	r3, [r3, #0]
34002838:	3301      	adds	r3, #1
3400283a:	61bb      	str	r3, [r7, #24]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
3400283c:	4a77      	ldr	r2, [pc, #476]	@ (34002a1c <xTaskIncrementTick+0x1fc>)
3400283e:	69bb      	ldr	r3, [r7, #24]
34002840:	6013      	str	r3, [r2, #0]

        if( xConstTickCount == ( TickType_t ) 0U )
34002842:	69bb      	ldr	r3, [r7, #24]
34002844:	2b00      	cmp	r3, #0
34002846:	d119      	bne.n	3400287c <xTaskIncrementTick+0x5c>
        {
            taskSWITCH_DELAYED_LISTS();
34002848:	4b75      	ldr	r3, [pc, #468]	@ (34002a20 <xTaskIncrementTick+0x200>)
3400284a:	681b      	ldr	r3, [r3, #0]
3400284c:	681b      	ldr	r3, [r3, #0]
3400284e:	2b00      	cmp	r3, #0
34002850:	d003      	beq.n	3400285a <xTaskIncrementTick+0x3a>
34002852:	f7ff f923 	bl	34001a9c <ulSetInterruptMask>
34002856:	bf00      	nop
34002858:	e7fd      	b.n	34002856 <xTaskIncrementTick+0x36>
3400285a:	4b71      	ldr	r3, [pc, #452]	@ (34002a20 <xTaskIncrementTick+0x200>)
3400285c:	681b      	ldr	r3, [r3, #0]
3400285e:	617b      	str	r3, [r7, #20]
34002860:	4b70      	ldr	r3, [pc, #448]	@ (34002a24 <xTaskIncrementTick+0x204>)
34002862:	681b      	ldr	r3, [r3, #0]
34002864:	4a6e      	ldr	r2, [pc, #440]	@ (34002a20 <xTaskIncrementTick+0x200>)
34002866:	6013      	str	r3, [r2, #0]
34002868:	4a6e      	ldr	r2, [pc, #440]	@ (34002a24 <xTaskIncrementTick+0x204>)
3400286a:	697b      	ldr	r3, [r7, #20]
3400286c:	6013      	str	r3, [r2, #0]
3400286e:	4b6e      	ldr	r3, [pc, #440]	@ (34002a28 <xTaskIncrementTick+0x208>)
34002870:	681b      	ldr	r3, [r3, #0]
34002872:	3301      	adds	r3, #1
34002874:	4a6c      	ldr	r2, [pc, #432]	@ (34002a28 <xTaskIncrementTick+0x208>)
34002876:	6013      	str	r3, [r2, #0]
34002878:	f000 fb7c 	bl	34002f74 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
3400287c:	4b6b      	ldr	r3, [pc, #428]	@ (34002a2c <xTaskIncrementTick+0x20c>)
3400287e:	681b      	ldr	r3, [r3, #0]
34002880:	69ba      	ldr	r2, [r7, #24]
34002882:	429a      	cmp	r2, r3
34002884:	f0c0 80a8 	bcc.w	340029d8 <xTaskIncrementTick+0x1b8>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
34002888:	4b65      	ldr	r3, [pc, #404]	@ (34002a20 <xTaskIncrementTick+0x200>)
3400288a:	681b      	ldr	r3, [r3, #0]
3400288c:	681b      	ldr	r3, [r3, #0]
3400288e:	2b00      	cmp	r3, #0
34002890:	d104      	bne.n	3400289c <xTaskIncrementTick+0x7c>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY;
34002892:	4b66      	ldr	r3, [pc, #408]	@ (34002a2c <xTaskIncrementTick+0x20c>)
34002894:	f04f 32ff 	mov.w	r2, #4294967295
34002898:	601a      	str	r2, [r3, #0]
                    break;
3400289a:	e09d      	b.n	340029d8 <xTaskIncrementTick+0x1b8>
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    /* MISRA Ref 11.5.3 [Void pointer assignment] */
                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                    /* coverity[misra_c_2012_rule_11_5_violation] */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
3400289c:	4b60      	ldr	r3, [pc, #384]	@ (34002a20 <xTaskIncrementTick+0x200>)
3400289e:	681b      	ldr	r3, [r3, #0]
340028a0:	68db      	ldr	r3, [r3, #12]
340028a2:	68db      	ldr	r3, [r3, #12]
340028a4:	613b      	str	r3, [r7, #16]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
340028a6:	693b      	ldr	r3, [r7, #16]
340028a8:	685b      	ldr	r3, [r3, #4]
340028aa:	60fb      	str	r3, [r7, #12]

                    if( xConstTickCount < xItemValue )
340028ac:	69ba      	ldr	r2, [r7, #24]
340028ae:	68fb      	ldr	r3, [r7, #12]
340028b0:	429a      	cmp	r2, r3
340028b2:	d203      	bcs.n	340028bc <xTaskIncrementTick+0x9c>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
340028b4:	4a5d      	ldr	r2, [pc, #372]	@ (34002a2c <xTaskIncrementTick+0x20c>)
340028b6:	68fb      	ldr	r3, [r7, #12]
340028b8:	6013      	str	r3, [r2, #0]
                        break;
340028ba:	e08d      	b.n	340029d8 <xTaskIncrementTick+0x1b8>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
340028bc:	693b      	ldr	r3, [r7, #16]
340028be:	695b      	ldr	r3, [r3, #20]
340028c0:	60bb      	str	r3, [r7, #8]
340028c2:	693b      	ldr	r3, [r7, #16]
340028c4:	689b      	ldr	r3, [r3, #8]
340028c6:	693a      	ldr	r2, [r7, #16]
340028c8:	68d2      	ldr	r2, [r2, #12]
340028ca:	609a      	str	r2, [r3, #8]
340028cc:	693b      	ldr	r3, [r7, #16]
340028ce:	68db      	ldr	r3, [r3, #12]
340028d0:	693a      	ldr	r2, [r7, #16]
340028d2:	6892      	ldr	r2, [r2, #8]
340028d4:	605a      	str	r2, [r3, #4]
340028d6:	68bb      	ldr	r3, [r7, #8]
340028d8:	685a      	ldr	r2, [r3, #4]
340028da:	693b      	ldr	r3, [r7, #16]
340028dc:	3304      	adds	r3, #4
340028de:	429a      	cmp	r2, r3
340028e0:	d103      	bne.n	340028ea <xTaskIncrementTick+0xca>
340028e2:	693b      	ldr	r3, [r7, #16]
340028e4:	68da      	ldr	r2, [r3, #12]
340028e6:	68bb      	ldr	r3, [r7, #8]
340028e8:	605a      	str	r2, [r3, #4]
340028ea:	693b      	ldr	r3, [r7, #16]
340028ec:	2200      	movs	r2, #0
340028ee:	615a      	str	r2, [r3, #20]
340028f0:	68bb      	ldr	r3, [r7, #8]
340028f2:	681b      	ldr	r3, [r3, #0]
340028f4:	1e5a      	subs	r2, r3, #1
340028f6:	68bb      	ldr	r3, [r7, #8]
340028f8:	601a      	str	r2, [r3, #0]

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
340028fa:	693b      	ldr	r3, [r7, #16]
340028fc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340028fe:	2b00      	cmp	r3, #0
34002900:	d01e      	beq.n	34002940 <xTaskIncrementTick+0x120>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
34002902:	693b      	ldr	r3, [r7, #16]
34002904:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34002906:	607b      	str	r3, [r7, #4]
34002908:	693b      	ldr	r3, [r7, #16]
3400290a:	69db      	ldr	r3, [r3, #28]
3400290c:	693a      	ldr	r2, [r7, #16]
3400290e:	6a12      	ldr	r2, [r2, #32]
34002910:	609a      	str	r2, [r3, #8]
34002912:	693b      	ldr	r3, [r7, #16]
34002914:	6a1b      	ldr	r3, [r3, #32]
34002916:	693a      	ldr	r2, [r7, #16]
34002918:	69d2      	ldr	r2, [r2, #28]
3400291a:	605a      	str	r2, [r3, #4]
3400291c:	687b      	ldr	r3, [r7, #4]
3400291e:	685a      	ldr	r2, [r3, #4]
34002920:	693b      	ldr	r3, [r7, #16]
34002922:	3318      	adds	r3, #24
34002924:	429a      	cmp	r2, r3
34002926:	d103      	bne.n	34002930 <xTaskIncrementTick+0x110>
34002928:	693b      	ldr	r3, [r7, #16]
3400292a:	6a1a      	ldr	r2, [r3, #32]
3400292c:	687b      	ldr	r3, [r7, #4]
3400292e:	605a      	str	r2, [r3, #4]
34002930:	693b      	ldr	r3, [r7, #16]
34002932:	2200      	movs	r2, #0
34002934:	629a      	str	r2, [r3, #40]	@ 0x28
34002936:	687b      	ldr	r3, [r7, #4]
34002938:	681b      	ldr	r3, [r3, #0]
3400293a:	1e5a      	subs	r2, r3, #1
3400293c:	687b      	ldr	r3, [r7, #4]
3400293e:	601a      	str	r2, [r3, #0]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
34002940:	693b      	ldr	r3, [r7, #16]
34002942:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34002944:	2201      	movs	r2, #1
34002946:	409a      	lsls	r2, r3
34002948:	4b39      	ldr	r3, [pc, #228]	@ (34002a30 <xTaskIncrementTick+0x210>)
3400294a:	681b      	ldr	r3, [r3, #0]
3400294c:	4313      	orrs	r3, r2
3400294e:	4a38      	ldr	r2, [pc, #224]	@ (34002a30 <xTaskIncrementTick+0x210>)
34002950:	6013      	str	r3, [r2, #0]
34002952:	693b      	ldr	r3, [r7, #16]
34002954:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002956:	4937      	ldr	r1, [pc, #220]	@ (34002a34 <xTaskIncrementTick+0x214>)
34002958:	4613      	mov	r3, r2
3400295a:	009b      	lsls	r3, r3, #2
3400295c:	4413      	add	r3, r2
3400295e:	009b      	lsls	r3, r3, #2
34002960:	440b      	add	r3, r1
34002962:	3304      	adds	r3, #4
34002964:	681b      	ldr	r3, [r3, #0]
34002966:	603b      	str	r3, [r7, #0]
34002968:	693b      	ldr	r3, [r7, #16]
3400296a:	683a      	ldr	r2, [r7, #0]
3400296c:	609a      	str	r2, [r3, #8]
3400296e:	683b      	ldr	r3, [r7, #0]
34002970:	689a      	ldr	r2, [r3, #8]
34002972:	693b      	ldr	r3, [r7, #16]
34002974:	60da      	str	r2, [r3, #12]
34002976:	683b      	ldr	r3, [r7, #0]
34002978:	689b      	ldr	r3, [r3, #8]
3400297a:	693a      	ldr	r2, [r7, #16]
3400297c:	3204      	adds	r2, #4
3400297e:	605a      	str	r2, [r3, #4]
34002980:	693b      	ldr	r3, [r7, #16]
34002982:	1d1a      	adds	r2, r3, #4
34002984:	683b      	ldr	r3, [r7, #0]
34002986:	609a      	str	r2, [r3, #8]
34002988:	693b      	ldr	r3, [r7, #16]
3400298a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400298c:	4613      	mov	r3, r2
3400298e:	009b      	lsls	r3, r3, #2
34002990:	4413      	add	r3, r2
34002992:	009b      	lsls	r3, r3, #2
34002994:	4a27      	ldr	r2, [pc, #156]	@ (34002a34 <xTaskIncrementTick+0x214>)
34002996:	441a      	add	r2, r3
34002998:	693b      	ldr	r3, [r7, #16]
3400299a:	615a      	str	r2, [r3, #20]
3400299c:	693b      	ldr	r3, [r7, #16]
3400299e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340029a0:	4924      	ldr	r1, [pc, #144]	@ (34002a34 <xTaskIncrementTick+0x214>)
340029a2:	4613      	mov	r3, r2
340029a4:	009b      	lsls	r3, r3, #2
340029a6:	4413      	add	r3, r2
340029a8:	009b      	lsls	r3, r3, #2
340029aa:	440b      	add	r3, r1
340029ac:	681b      	ldr	r3, [r3, #0]
340029ae:	693a      	ldr	r2, [r7, #16]
340029b0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
340029b2:	1c59      	adds	r1, r3, #1
340029b4:	481f      	ldr	r0, [pc, #124]	@ (34002a34 <xTaskIncrementTick+0x214>)
340029b6:	4613      	mov	r3, r2
340029b8:	009b      	lsls	r3, r3, #2
340029ba:	4413      	add	r3, r2
340029bc:	009b      	lsls	r3, r3, #2
340029be:	4403      	add	r3, r0
340029c0:	6019      	str	r1, [r3, #0]
                             * task.
                             * The case of equal priority tasks sharing
                             * processing time (which happens when both
                             * preemption and time slicing are on) is
                             * handled below.*/
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
340029c2:	693b      	ldr	r3, [r7, #16]
340029c4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340029c6:	4b1c      	ldr	r3, [pc, #112]	@ (34002a38 <xTaskIncrementTick+0x218>)
340029c8:	681b      	ldr	r3, [r3, #0]
340029ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340029cc:	429a      	cmp	r2, r3
340029ce:	f67f af5b 	bls.w	34002888 <xTaskIncrementTick+0x68>
                            {
                                xSwitchRequired = pdTRUE;
340029d2:	2301      	movs	r3, #1
340029d4:	61fb      	str	r3, [r7, #28]
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
340029d6:	e757      	b.n	34002888 <xTaskIncrementTick+0x68>
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
340029d8:	4b17      	ldr	r3, [pc, #92]	@ (34002a38 <xTaskIncrementTick+0x218>)
340029da:	681b      	ldr	r3, [r3, #0]
340029dc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340029de:	4915      	ldr	r1, [pc, #84]	@ (34002a34 <xTaskIncrementTick+0x214>)
340029e0:	4613      	mov	r3, r2
340029e2:	009b      	lsls	r3, r3, #2
340029e4:	4413      	add	r3, r2
340029e6:	009b      	lsls	r3, r3, #2
340029e8:	440b      	add	r3, r1
340029ea:	681b      	ldr	r3, [r3, #0]
340029ec:	2b01      	cmp	r3, #1
340029ee:	d901      	bls.n	340029f4 <xTaskIncrementTick+0x1d4>
                {
                    xSwitchRequired = pdTRUE;
340029f0:	2301      	movs	r3, #1
340029f2:	61fb      	str	r3, [r7, #28]
        #if ( configUSE_PREEMPTION == 1 )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                /* For single core the core ID is always 0. */
                if( xYieldPendings[ 0 ] != pdFALSE )
340029f4:	4b11      	ldr	r3, [pc, #68]	@ (34002a3c <xTaskIncrementTick+0x21c>)
340029f6:	681b      	ldr	r3, [r3, #0]
340029f8:	2b00      	cmp	r3, #0
340029fa:	d007      	beq.n	34002a0c <xTaskIncrementTick+0x1ec>
                {
                    xSwitchRequired = pdTRUE;
340029fc:	2301      	movs	r3, #1
340029fe:	61fb      	str	r3, [r7, #28]
34002a00:	e004      	b.n	34002a0c <xTaskIncrementTick+0x1ec>
        }
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    else
    {
        xPendedTicks += 1U;
34002a02:	4b0f      	ldr	r3, [pc, #60]	@ (34002a40 <xTaskIncrementTick+0x220>)
34002a04:	681b      	ldr	r3, [r3, #0]
34002a06:	3301      	adds	r3, #1
34002a08:	4a0d      	ldr	r2, [pc, #52]	@ (34002a40 <xTaskIncrementTick+0x220>)
34002a0a:	6013      	str	r3, [r2, #0]
        #endif
    }

    traceRETURN_xTaskIncrementTick( xSwitchRequired );

    return xSwitchRequired;
34002a0c:	69fb      	ldr	r3, [r7, #28]
}
34002a0e:	4618      	mov	r0, r3
34002a10:	3720      	adds	r7, #32
34002a12:	46bd      	mov	sp, r7
34002a14:	bd80      	pop	{r7, pc}
34002a16:	bf00      	nop
34002a18:	34003fac 	.word	0x34003fac
34002a1c:	34003f88 	.word	0x34003f88
34002a20:	34003f3c 	.word	0x34003f3c
34002a24:	34003f40 	.word	0x34003f40
34002a28:	34003f9c 	.word	0x34003f9c
34002a2c:	34003fa4 	.word	0x34003fa4
34002a30:	34003f8c 	.word	0x34003f8c
34002a34:	34003c94 	.word	0x34003c94
34002a38:	34003c90 	.word	0x34003c90
34002a3c:	34003f98 	.word	0x34003f98
34002a40:	34003f94 	.word	0x34003f94

34002a44 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )
    void vTaskSwitchContext( void )
    {
34002a44:	b580      	push	{r7, lr}
34002a46:	b084      	sub	sp, #16
34002a48:	af00      	add	r7, sp, #0
        traceENTER_vTaskSwitchContext();

        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
34002a4a:	4b23      	ldr	r3, [pc, #140]	@ (34002ad8 <vTaskSwitchContext+0x94>)
34002a4c:	681b      	ldr	r3, [r3, #0]
34002a4e:	2b00      	cmp	r3, #0
34002a50:	d003      	beq.n	34002a5a <vTaskSwitchContext+0x16>
        {
            /* The scheduler is currently suspended - do not allow a context
             * switch. */
            xYieldPendings[ 0 ] = pdTRUE;
34002a52:	4b22      	ldr	r3, [pc, #136]	@ (34002adc <vTaskSwitchContext+0x98>)
34002a54:	2201      	movs	r2, #1
34002a56:	601a      	str	r2, [r3, #0]
            }
            #endif
        }

        traceRETURN_vTaskSwitchContext();
    }
34002a58:	e039      	b.n	34002ace <vTaskSwitchContext+0x8a>
            xYieldPendings[ 0 ] = pdFALSE;
34002a5a:	4b20      	ldr	r3, [pc, #128]	@ (34002adc <vTaskSwitchContext+0x98>)
34002a5c:	2200      	movs	r2, #0
34002a5e:	601a      	str	r2, [r3, #0]
            taskSELECT_HIGHEST_PRIORITY_TASK();
34002a60:	4b1f      	ldr	r3, [pc, #124]	@ (34002ae0 <vTaskSwitchContext+0x9c>)
34002a62:	681b      	ldr	r3, [r3, #0]
34002a64:	607b      	str	r3, [r7, #4]
 */
    static portFORCE_INLINE uint32_t ulPortCountLeadingZeros( uint32_t ulBitmap )
    {
        uint32_t ulReturn;

        __asm volatile ( "clz %0, %1" : "=r" ( ulReturn ) : "r" ( ulBitmap ) : "memory" );
34002a66:	687b      	ldr	r3, [r7, #4]
34002a68:	fab3 f383 	clz	r3, r3
34002a6c:	603b      	str	r3, [r7, #0]

        return ulReturn;
34002a6e:	683b      	ldr	r3, [r7, #0]
34002a70:	f1c3 031f 	rsb	r3, r3, #31
34002a74:	60fb      	str	r3, [r7, #12]
34002a76:	491b      	ldr	r1, [pc, #108]	@ (34002ae4 <vTaskSwitchContext+0xa0>)
34002a78:	68fa      	ldr	r2, [r7, #12]
34002a7a:	4613      	mov	r3, r2
34002a7c:	009b      	lsls	r3, r3, #2
34002a7e:	4413      	add	r3, r2
34002a80:	009b      	lsls	r3, r3, #2
34002a82:	440b      	add	r3, r1
34002a84:	681b      	ldr	r3, [r3, #0]
34002a86:	2b00      	cmp	r3, #0
34002a88:	d103      	bne.n	34002a92 <vTaskSwitchContext+0x4e>
34002a8a:	f7ff f807 	bl	34001a9c <ulSetInterruptMask>
34002a8e:	bf00      	nop
34002a90:	e7fd      	b.n	34002a8e <vTaskSwitchContext+0x4a>
34002a92:	68fa      	ldr	r2, [r7, #12]
34002a94:	4613      	mov	r3, r2
34002a96:	009b      	lsls	r3, r3, #2
34002a98:	4413      	add	r3, r2
34002a9a:	009b      	lsls	r3, r3, #2
34002a9c:	4a11      	ldr	r2, [pc, #68]	@ (34002ae4 <vTaskSwitchContext+0xa0>)
34002a9e:	4413      	add	r3, r2
34002aa0:	60bb      	str	r3, [r7, #8]
34002aa2:	68bb      	ldr	r3, [r7, #8]
34002aa4:	685b      	ldr	r3, [r3, #4]
34002aa6:	685a      	ldr	r2, [r3, #4]
34002aa8:	68bb      	ldr	r3, [r7, #8]
34002aaa:	605a      	str	r2, [r3, #4]
34002aac:	68bb      	ldr	r3, [r7, #8]
34002aae:	685a      	ldr	r2, [r3, #4]
34002ab0:	68bb      	ldr	r3, [r7, #8]
34002ab2:	3308      	adds	r3, #8
34002ab4:	429a      	cmp	r2, r3
34002ab6:	d103      	bne.n	34002ac0 <vTaskSwitchContext+0x7c>
34002ab8:	68bb      	ldr	r3, [r7, #8]
34002aba:	68da      	ldr	r2, [r3, #12]
34002abc:	68bb      	ldr	r3, [r7, #8]
34002abe:	605a      	str	r2, [r3, #4]
34002ac0:	68bb      	ldr	r3, [r7, #8]
34002ac2:	685b      	ldr	r3, [r3, #4]
34002ac4:	68db      	ldr	r3, [r3, #12]
34002ac6:	4a08      	ldr	r2, [pc, #32]	@ (34002ae8 <vTaskSwitchContext+0xa4>)
34002ac8:	6013      	str	r3, [r2, #0]
            portTASK_SWITCH_HOOK( pxCurrentTCB );
34002aca:	4b07      	ldr	r3, [pc, #28]	@ (34002ae8 <vTaskSwitchContext+0xa4>)
34002acc:	681b      	ldr	r3, [r3, #0]
    }
34002ace:	bf00      	nop
34002ad0:	3710      	adds	r7, #16
34002ad2:	46bd      	mov	sp, r7
34002ad4:	bd80      	pop	{r7, pc}
34002ad6:	bf00      	nop
34002ad8:	34003fac 	.word	0x34003fac
34002adc:	34003f98 	.word	0x34003f98
34002ae0:	34003f8c 	.word	0x34003f8c
34002ae4:	34003c94 	.word	0x34003c94
34002ae8:	34003c90 	.word	0x34003c90

34002aec <vTaskPlaceOnEventList>:
#endif /* if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
34002aec:	b580      	push	{r7, lr}
34002aee:	b082      	sub	sp, #8
34002af0:	af00      	add	r7, sp, #0
34002af2:	6078      	str	r0, [r7, #4]
34002af4:	6039      	str	r1, [r7, #0]
    traceENTER_vTaskPlaceOnEventList( pxEventList, xTicksToWait );

    configASSERT( pxEventList );
34002af6:	687b      	ldr	r3, [r7, #4]
34002af8:	2b00      	cmp	r3, #0
34002afa:	d103      	bne.n	34002b04 <vTaskPlaceOnEventList+0x18>
34002afc:	f7fe ffce 	bl	34001a9c <ulSetInterruptMask>
34002b00:	bf00      	nop
34002b02:	e7fd      	b.n	34002b00 <vTaskPlaceOnEventList+0x14>
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
34002b04:	4b07      	ldr	r3, [pc, #28]	@ (34002b24 <vTaskPlaceOnEventList+0x38>)
34002b06:	681b      	ldr	r3, [r3, #0]
34002b08:	3318      	adds	r3, #24
34002b0a:	4619      	mov	r1, r3
34002b0c:	6878      	ldr	r0, [r7, #4]
34002b0e:	f7fe fd52 	bl	340015b6 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
34002b12:	2101      	movs	r1, #1
34002b14:	6838      	ldr	r0, [r7, #0]
34002b16:	f000 fafd 	bl	34003114 <prvAddCurrentTaskToDelayedList>

    traceRETURN_vTaskPlaceOnEventList();
}
34002b1a:	bf00      	nop
34002b1c:	3708      	adds	r7, #8
34002b1e:	46bd      	mov	sp, r7
34002b20:	bd80      	pop	{r7, pc}
34002b22:	bf00      	nop
34002b24:	34003c90 	.word	0x34003c90

34002b28 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
34002b28:	b580      	push	{r7, lr}
34002b2a:	b086      	sub	sp, #24
34002b2c:	af00      	add	r7, sp, #0
34002b2e:	60f8      	str	r0, [r7, #12]
34002b30:	60b9      	str	r1, [r7, #8]
34002b32:	607a      	str	r2, [r7, #4]
        traceENTER_vTaskPlaceOnEventListRestricted( pxEventList, xTicksToWait, xWaitIndefinitely );

        configASSERT( pxEventList );
34002b34:	68fb      	ldr	r3, [r7, #12]
34002b36:	2b00      	cmp	r3, #0
34002b38:	d103      	bne.n	34002b42 <vTaskPlaceOnEventListRestricted+0x1a>
34002b3a:	f7fe ffaf 	bl	34001a9c <ulSetInterruptMask>
34002b3e:	bf00      	nop
34002b40:	e7fd      	b.n	34002b3e <vTaskPlaceOnEventListRestricted+0x16>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
34002b42:	68fb      	ldr	r3, [r7, #12]
34002b44:	685b      	ldr	r3, [r3, #4]
34002b46:	617b      	str	r3, [r7, #20]
34002b48:	4b15      	ldr	r3, [pc, #84]	@ (34002ba0 <vTaskPlaceOnEventListRestricted+0x78>)
34002b4a:	681b      	ldr	r3, [r3, #0]
34002b4c:	697a      	ldr	r2, [r7, #20]
34002b4e:	61da      	str	r2, [r3, #28]
34002b50:	4b13      	ldr	r3, [pc, #76]	@ (34002ba0 <vTaskPlaceOnEventListRestricted+0x78>)
34002b52:	681b      	ldr	r3, [r3, #0]
34002b54:	697a      	ldr	r2, [r7, #20]
34002b56:	6892      	ldr	r2, [r2, #8]
34002b58:	621a      	str	r2, [r3, #32]
34002b5a:	4b11      	ldr	r3, [pc, #68]	@ (34002ba0 <vTaskPlaceOnEventListRestricted+0x78>)
34002b5c:	681a      	ldr	r2, [r3, #0]
34002b5e:	697b      	ldr	r3, [r7, #20]
34002b60:	689b      	ldr	r3, [r3, #8]
34002b62:	3218      	adds	r2, #24
34002b64:	605a      	str	r2, [r3, #4]
34002b66:	4b0e      	ldr	r3, [pc, #56]	@ (34002ba0 <vTaskPlaceOnEventListRestricted+0x78>)
34002b68:	681b      	ldr	r3, [r3, #0]
34002b6a:	f103 0218 	add.w	r2, r3, #24
34002b6e:	697b      	ldr	r3, [r7, #20]
34002b70:	609a      	str	r2, [r3, #8]
34002b72:	4b0b      	ldr	r3, [pc, #44]	@ (34002ba0 <vTaskPlaceOnEventListRestricted+0x78>)
34002b74:	681b      	ldr	r3, [r3, #0]
34002b76:	68fa      	ldr	r2, [r7, #12]
34002b78:	629a      	str	r2, [r3, #40]	@ 0x28
34002b7a:	68fb      	ldr	r3, [r7, #12]
34002b7c:	681b      	ldr	r3, [r3, #0]
34002b7e:	1c5a      	adds	r2, r3, #1
34002b80:	68fb      	ldr	r3, [r7, #12]
34002b82:	601a      	str	r2, [r3, #0]

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
34002b84:	687b      	ldr	r3, [r7, #4]
34002b86:	2b00      	cmp	r3, #0
34002b88:	d002      	beq.n	34002b90 <vTaskPlaceOnEventListRestricted+0x68>
        {
            xTicksToWait = portMAX_DELAY;
34002b8a:	f04f 33ff 	mov.w	r3, #4294967295
34002b8e:	60bb      	str	r3, [r7, #8]
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
34002b90:	6879      	ldr	r1, [r7, #4]
34002b92:	68b8      	ldr	r0, [r7, #8]
34002b94:	f000 fabe 	bl	34003114 <prvAddCurrentTaskToDelayedList>

        traceRETURN_vTaskPlaceOnEventListRestricted();
    }
34002b98:	bf00      	nop
34002b9a:	3718      	adds	r7, #24
34002b9c:	46bd      	mov	sp, r7
34002b9e:	bd80      	pop	{r7, pc}
34002ba0:	34003c90 	.word	0x34003c90

34002ba4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
34002ba4:	b580      	push	{r7, lr}
34002ba6:	b088      	sub	sp, #32
34002ba8:	af00      	add	r7, sp, #0
34002baa:	6078      	str	r0, [r7, #4]
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    /* MISRA Ref 11.5.3 [Void pointer assignment] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
34002bac:	687b      	ldr	r3, [r7, #4]
34002bae:	68db      	ldr	r3, [r3, #12]
34002bb0:	68db      	ldr	r3, [r3, #12]
34002bb2:	61bb      	str	r3, [r7, #24]
    configASSERT( pxUnblockedTCB );
34002bb4:	69bb      	ldr	r3, [r7, #24]
34002bb6:	2b00      	cmp	r3, #0
34002bb8:	d103      	bne.n	34002bc2 <xTaskRemoveFromEventList+0x1e>
34002bba:	f7fe ff6f 	bl	34001a9c <ulSetInterruptMask>
34002bbe:	bf00      	nop
34002bc0:	e7fd      	b.n	34002bbe <xTaskRemoveFromEventList+0x1a>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
34002bc2:	69bb      	ldr	r3, [r7, #24]
34002bc4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34002bc6:	617b      	str	r3, [r7, #20]
34002bc8:	69bb      	ldr	r3, [r7, #24]
34002bca:	69db      	ldr	r3, [r3, #28]
34002bcc:	69ba      	ldr	r2, [r7, #24]
34002bce:	6a12      	ldr	r2, [r2, #32]
34002bd0:	609a      	str	r2, [r3, #8]
34002bd2:	69bb      	ldr	r3, [r7, #24]
34002bd4:	6a1b      	ldr	r3, [r3, #32]
34002bd6:	69ba      	ldr	r2, [r7, #24]
34002bd8:	69d2      	ldr	r2, [r2, #28]
34002bda:	605a      	str	r2, [r3, #4]
34002bdc:	697b      	ldr	r3, [r7, #20]
34002bde:	685a      	ldr	r2, [r3, #4]
34002be0:	69bb      	ldr	r3, [r7, #24]
34002be2:	3318      	adds	r3, #24
34002be4:	429a      	cmp	r2, r3
34002be6:	d103      	bne.n	34002bf0 <xTaskRemoveFromEventList+0x4c>
34002be8:	69bb      	ldr	r3, [r7, #24]
34002bea:	6a1a      	ldr	r2, [r3, #32]
34002bec:	697b      	ldr	r3, [r7, #20]
34002bee:	605a      	str	r2, [r3, #4]
34002bf0:	69bb      	ldr	r3, [r7, #24]
34002bf2:	2200      	movs	r2, #0
34002bf4:	629a      	str	r2, [r3, #40]	@ 0x28
34002bf6:	697b      	ldr	r3, [r7, #20]
34002bf8:	681b      	ldr	r3, [r3, #0]
34002bfa:	1e5a      	subs	r2, r3, #1
34002bfc:	697b      	ldr	r3, [r7, #20]
34002bfe:	601a      	str	r2, [r3, #0]

    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
34002c00:	4b4a      	ldr	r3, [pc, #296]	@ (34002d2c <xTaskRemoveFromEventList+0x188>)
34002c02:	681b      	ldr	r3, [r3, #0]
34002c04:	2b00      	cmp	r3, #0
34002c06:	d160      	bne.n	34002cca <xTaskRemoveFromEventList+0x126>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
34002c08:	69bb      	ldr	r3, [r7, #24]
34002c0a:	695b      	ldr	r3, [r3, #20]
34002c0c:	60fb      	str	r3, [r7, #12]
34002c0e:	69bb      	ldr	r3, [r7, #24]
34002c10:	689b      	ldr	r3, [r3, #8]
34002c12:	69ba      	ldr	r2, [r7, #24]
34002c14:	68d2      	ldr	r2, [r2, #12]
34002c16:	609a      	str	r2, [r3, #8]
34002c18:	69bb      	ldr	r3, [r7, #24]
34002c1a:	68db      	ldr	r3, [r3, #12]
34002c1c:	69ba      	ldr	r2, [r7, #24]
34002c1e:	6892      	ldr	r2, [r2, #8]
34002c20:	605a      	str	r2, [r3, #4]
34002c22:	68fb      	ldr	r3, [r7, #12]
34002c24:	685a      	ldr	r2, [r3, #4]
34002c26:	69bb      	ldr	r3, [r7, #24]
34002c28:	3304      	adds	r3, #4
34002c2a:	429a      	cmp	r2, r3
34002c2c:	d103      	bne.n	34002c36 <xTaskRemoveFromEventList+0x92>
34002c2e:	69bb      	ldr	r3, [r7, #24]
34002c30:	68da      	ldr	r2, [r3, #12]
34002c32:	68fb      	ldr	r3, [r7, #12]
34002c34:	605a      	str	r2, [r3, #4]
34002c36:	69bb      	ldr	r3, [r7, #24]
34002c38:	2200      	movs	r2, #0
34002c3a:	615a      	str	r2, [r3, #20]
34002c3c:	68fb      	ldr	r3, [r7, #12]
34002c3e:	681b      	ldr	r3, [r3, #0]
34002c40:	1e5a      	subs	r2, r3, #1
34002c42:	68fb      	ldr	r3, [r7, #12]
34002c44:	601a      	str	r2, [r3, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
34002c46:	69bb      	ldr	r3, [r7, #24]
34002c48:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34002c4a:	2201      	movs	r2, #1
34002c4c:	409a      	lsls	r2, r3
34002c4e:	4b38      	ldr	r3, [pc, #224]	@ (34002d30 <xTaskRemoveFromEventList+0x18c>)
34002c50:	681b      	ldr	r3, [r3, #0]
34002c52:	4313      	orrs	r3, r2
34002c54:	4a36      	ldr	r2, [pc, #216]	@ (34002d30 <xTaskRemoveFromEventList+0x18c>)
34002c56:	6013      	str	r3, [r2, #0]
34002c58:	69bb      	ldr	r3, [r7, #24]
34002c5a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002c5c:	4935      	ldr	r1, [pc, #212]	@ (34002d34 <xTaskRemoveFromEventList+0x190>)
34002c5e:	4613      	mov	r3, r2
34002c60:	009b      	lsls	r3, r3, #2
34002c62:	4413      	add	r3, r2
34002c64:	009b      	lsls	r3, r3, #2
34002c66:	440b      	add	r3, r1
34002c68:	3304      	adds	r3, #4
34002c6a:	681b      	ldr	r3, [r3, #0]
34002c6c:	60bb      	str	r3, [r7, #8]
34002c6e:	69bb      	ldr	r3, [r7, #24]
34002c70:	68ba      	ldr	r2, [r7, #8]
34002c72:	609a      	str	r2, [r3, #8]
34002c74:	68bb      	ldr	r3, [r7, #8]
34002c76:	689a      	ldr	r2, [r3, #8]
34002c78:	69bb      	ldr	r3, [r7, #24]
34002c7a:	60da      	str	r2, [r3, #12]
34002c7c:	68bb      	ldr	r3, [r7, #8]
34002c7e:	689b      	ldr	r3, [r3, #8]
34002c80:	69ba      	ldr	r2, [r7, #24]
34002c82:	3204      	adds	r2, #4
34002c84:	605a      	str	r2, [r3, #4]
34002c86:	69bb      	ldr	r3, [r7, #24]
34002c88:	1d1a      	adds	r2, r3, #4
34002c8a:	68bb      	ldr	r3, [r7, #8]
34002c8c:	609a      	str	r2, [r3, #8]
34002c8e:	69bb      	ldr	r3, [r7, #24]
34002c90:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002c92:	4613      	mov	r3, r2
34002c94:	009b      	lsls	r3, r3, #2
34002c96:	4413      	add	r3, r2
34002c98:	009b      	lsls	r3, r3, #2
34002c9a:	4a26      	ldr	r2, [pc, #152]	@ (34002d34 <xTaskRemoveFromEventList+0x190>)
34002c9c:	441a      	add	r2, r3
34002c9e:	69bb      	ldr	r3, [r7, #24]
34002ca0:	615a      	str	r2, [r3, #20]
34002ca2:	69bb      	ldr	r3, [r7, #24]
34002ca4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002ca6:	4923      	ldr	r1, [pc, #140]	@ (34002d34 <xTaskRemoveFromEventList+0x190>)
34002ca8:	4613      	mov	r3, r2
34002caa:	009b      	lsls	r3, r3, #2
34002cac:	4413      	add	r3, r2
34002cae:	009b      	lsls	r3, r3, #2
34002cb0:	440b      	add	r3, r1
34002cb2:	681b      	ldr	r3, [r3, #0]
34002cb4:	69ba      	ldr	r2, [r7, #24]
34002cb6:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
34002cb8:	1c59      	adds	r1, r3, #1
34002cba:	481e      	ldr	r0, [pc, #120]	@ (34002d34 <xTaskRemoveFromEventList+0x190>)
34002cbc:	4613      	mov	r3, r2
34002cbe:	009b      	lsls	r3, r3, #2
34002cc0:	4413      	add	r3, r2
34002cc2:	009b      	lsls	r3, r3, #2
34002cc4:	4403      	add	r3, r0
34002cc6:	6019      	str	r1, [r3, #0]
34002cc8:	e01b      	b.n	34002d02 <xTaskRemoveFromEventList+0x15e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
34002cca:	4b1b      	ldr	r3, [pc, #108]	@ (34002d38 <xTaskRemoveFromEventList+0x194>)
34002ccc:	685b      	ldr	r3, [r3, #4]
34002cce:	613b      	str	r3, [r7, #16]
34002cd0:	69bb      	ldr	r3, [r7, #24]
34002cd2:	693a      	ldr	r2, [r7, #16]
34002cd4:	61da      	str	r2, [r3, #28]
34002cd6:	693b      	ldr	r3, [r7, #16]
34002cd8:	689a      	ldr	r2, [r3, #8]
34002cda:	69bb      	ldr	r3, [r7, #24]
34002cdc:	621a      	str	r2, [r3, #32]
34002cde:	693b      	ldr	r3, [r7, #16]
34002ce0:	689b      	ldr	r3, [r3, #8]
34002ce2:	69ba      	ldr	r2, [r7, #24]
34002ce4:	3218      	adds	r2, #24
34002ce6:	605a      	str	r2, [r3, #4]
34002ce8:	69bb      	ldr	r3, [r7, #24]
34002cea:	f103 0218 	add.w	r2, r3, #24
34002cee:	693b      	ldr	r3, [r7, #16]
34002cf0:	609a      	str	r2, [r3, #8]
34002cf2:	69bb      	ldr	r3, [r7, #24]
34002cf4:	4a10      	ldr	r2, [pc, #64]	@ (34002d38 <xTaskRemoveFromEventList+0x194>)
34002cf6:	629a      	str	r2, [r3, #40]	@ 0x28
34002cf8:	4b0f      	ldr	r3, [pc, #60]	@ (34002d38 <xTaskRemoveFromEventList+0x194>)
34002cfa:	681b      	ldr	r3, [r3, #0]
34002cfc:	3301      	adds	r3, #1
34002cfe:	4a0e      	ldr	r2, [pc, #56]	@ (34002d38 <xTaskRemoveFromEventList+0x194>)
34002d00:	6013      	str	r3, [r2, #0]
    }

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
34002d02:	69bb      	ldr	r3, [r7, #24]
34002d04:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002d06:	4b0d      	ldr	r3, [pc, #52]	@ (34002d3c <xTaskRemoveFromEventList+0x198>)
34002d08:	681b      	ldr	r3, [r3, #0]
34002d0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34002d0c:	429a      	cmp	r2, r3
34002d0e:	d905      	bls.n	34002d1c <xTaskRemoveFromEventList+0x178>
        {
            /* Return true if the task removed from the event list has a higher
             * priority than the calling task.  This allows the calling task to know if
             * it should force a context switch now. */
            xReturn = pdTRUE;
34002d10:	2301      	movs	r3, #1
34002d12:	61fb      	str	r3, [r7, #28]

            /* Mark that a yield is pending in case the user is not using the
             * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
            xYieldPendings[ 0 ] = pdTRUE;
34002d14:	4b0a      	ldr	r3, [pc, #40]	@ (34002d40 <xTaskRemoveFromEventList+0x19c>)
34002d16:	2201      	movs	r2, #1
34002d18:	601a      	str	r2, [r3, #0]
34002d1a:	e001      	b.n	34002d20 <xTaskRemoveFromEventList+0x17c>
        }
        else
        {
            xReturn = pdFALSE;
34002d1c:	2300      	movs	r3, #0
34002d1e:	61fb      	str	r3, [r7, #28]
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_xTaskRemoveFromEventList( xReturn );
    return xReturn;
34002d20:	69fb      	ldr	r3, [r7, #28]
}
34002d22:	4618      	mov	r0, r3
34002d24:	3720      	adds	r7, #32
34002d26:	46bd      	mov	sp, r7
34002d28:	bd80      	pop	{r7, pc}
34002d2a:	bf00      	nop
34002d2c:	34003fac 	.word	0x34003fac
34002d30:	34003f8c 	.word	0x34003f8c
34002d34:	34003c94 	.word	0x34003c94
34002d38:	34003f44 	.word	0x34003f44
34002d3c:	34003c90 	.word	0x34003c90
34002d40:	34003f98 	.word	0x34003f98

34002d44 <vTaskInternalSetTimeOutState>:
    traceRETURN_vTaskSetTimeOutState();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
34002d44:	b480      	push	{r7}
34002d46:	b083      	sub	sp, #12
34002d48:	af00      	add	r7, sp, #0
34002d4a:	6078      	str	r0, [r7, #4]
    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );

    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
34002d4c:	4b06      	ldr	r3, [pc, #24]	@ (34002d68 <vTaskInternalSetTimeOutState+0x24>)
34002d4e:	681a      	ldr	r2, [r3, #0]
34002d50:	687b      	ldr	r3, [r7, #4]
34002d52:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
34002d54:	4b05      	ldr	r3, [pc, #20]	@ (34002d6c <vTaskInternalSetTimeOutState+0x28>)
34002d56:	681a      	ldr	r2, [r3, #0]
34002d58:	687b      	ldr	r3, [r7, #4]
34002d5a:	605a      	str	r2, [r3, #4]

    traceRETURN_vTaskInternalSetTimeOutState();
}
34002d5c:	bf00      	nop
34002d5e:	370c      	adds	r7, #12
34002d60:	46bd      	mov	sp, r7
34002d62:	f85d 7b04 	ldr.w	r7, [sp], #4
34002d66:	4770      	bx	lr
34002d68:	34003f9c 	.word	0x34003f9c
34002d6c:	34003f88 	.word	0x34003f88

34002d70 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
34002d70:	b580      	push	{r7, lr}
34002d72:	b086      	sub	sp, #24
34002d74:	af00      	add	r7, sp, #0
34002d76:	6078      	str	r0, [r7, #4]
34002d78:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn;

    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );

    configASSERT( pxTimeOut );
34002d7a:	687b      	ldr	r3, [r7, #4]
34002d7c:	2b00      	cmp	r3, #0
34002d7e:	d103      	bne.n	34002d88 <xTaskCheckForTimeOut+0x18>
34002d80:	f7fe fe8c 	bl	34001a9c <ulSetInterruptMask>
34002d84:	bf00      	nop
34002d86:	e7fd      	b.n	34002d84 <xTaskCheckForTimeOut+0x14>
    configASSERT( pxTicksToWait );
34002d88:	683b      	ldr	r3, [r7, #0]
34002d8a:	2b00      	cmp	r3, #0
34002d8c:	d103      	bne.n	34002d96 <xTaskCheckForTimeOut+0x26>
34002d8e:	f7fe fe85 	bl	34001a9c <ulSetInterruptMask>
34002d92:	bf00      	nop
34002d94:	e7fd      	b.n	34002d92 <xTaskCheckForTimeOut+0x22>

    taskENTER_CRITICAL();
34002d96:	f7fe fcdb 	bl	34001750 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
34002d9a:	4b26      	ldr	r3, [pc, #152]	@ (34002e34 <xTaskCheckForTimeOut+0xc4>)
34002d9c:	681b      	ldr	r3, [r3, #0]
34002d9e:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
34002da0:	687b      	ldr	r3, [r7, #4]
34002da2:	685b      	ldr	r3, [r3, #4]
34002da4:	693a      	ldr	r2, [r7, #16]
34002da6:	1ad3      	subs	r3, r2, r3
34002da8:	60fb      	str	r3, [r7, #12]

        #if ( INCLUDE_xTaskAbortDelay == 1 )
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
34002daa:	4b23      	ldr	r3, [pc, #140]	@ (34002e38 <xTaskCheckForTimeOut+0xc8>)
34002dac:	681b      	ldr	r3, [r3, #0]
34002dae:	f893 3055 	ldrb.w	r3, [r3, #85]	@ 0x55
34002db2:	2b00      	cmp	r3, #0
34002db4:	d007      	beq.n	34002dc6 <xTaskCheckForTimeOut+0x56>
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
34002db6:	4b20      	ldr	r3, [pc, #128]	@ (34002e38 <xTaskCheckForTimeOut+0xc8>)
34002db8:	681b      	ldr	r3, [r3, #0]
34002dba:	2200      	movs	r2, #0
34002dbc:	f883 2055 	strb.w	r2, [r3, #85]	@ 0x55
                xReturn = pdTRUE;
34002dc0:	2301      	movs	r3, #1
34002dc2:	617b      	str	r3, [r7, #20]
34002dc4:	e02e      	b.n	34002e24 <xTaskCheckForTimeOut+0xb4>
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
34002dc6:	683b      	ldr	r3, [r7, #0]
34002dc8:	681b      	ldr	r3, [r3, #0]
34002dca:	f1b3 3fff 	cmp.w	r3, #4294967295
34002dce:	d102      	bne.n	34002dd6 <xTaskCheckForTimeOut+0x66>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
34002dd0:	2300      	movs	r3, #0
34002dd2:	617b      	str	r3, [r7, #20]
34002dd4:	e026      	b.n	34002e24 <xTaskCheckForTimeOut+0xb4>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
34002dd6:	687b      	ldr	r3, [r7, #4]
34002dd8:	681a      	ldr	r2, [r3, #0]
34002dda:	4b18      	ldr	r3, [pc, #96]	@ (34002e3c <xTaskCheckForTimeOut+0xcc>)
34002ddc:	681b      	ldr	r3, [r3, #0]
34002dde:	429a      	cmp	r2, r3
34002de0:	d00a      	beq.n	34002df8 <xTaskCheckForTimeOut+0x88>
34002de2:	687b      	ldr	r3, [r7, #4]
34002de4:	685b      	ldr	r3, [r3, #4]
34002de6:	693a      	ldr	r2, [r7, #16]
34002de8:	429a      	cmp	r2, r3
34002dea:	d305      	bcc.n	34002df8 <xTaskCheckForTimeOut+0x88>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
34002dec:	2301      	movs	r3, #1
34002dee:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
34002df0:	683b      	ldr	r3, [r7, #0]
34002df2:	2200      	movs	r2, #0
34002df4:	601a      	str	r2, [r3, #0]
34002df6:	e015      	b.n	34002e24 <xTaskCheckForTimeOut+0xb4>
        }
        else if( xElapsedTime < *pxTicksToWait )
34002df8:	683b      	ldr	r3, [r7, #0]
34002dfa:	681b      	ldr	r3, [r3, #0]
34002dfc:	68fa      	ldr	r2, [r7, #12]
34002dfe:	429a      	cmp	r2, r3
34002e00:	d20b      	bcs.n	34002e1a <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
34002e02:	683b      	ldr	r3, [r7, #0]
34002e04:	681a      	ldr	r2, [r3, #0]
34002e06:	68fb      	ldr	r3, [r7, #12]
34002e08:	1ad2      	subs	r2, r2, r3
34002e0a:	683b      	ldr	r3, [r7, #0]
34002e0c:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
34002e0e:	6878      	ldr	r0, [r7, #4]
34002e10:	f7ff ff98 	bl	34002d44 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
34002e14:	2300      	movs	r3, #0
34002e16:	617b      	str	r3, [r7, #20]
34002e18:	e004      	b.n	34002e24 <xTaskCheckForTimeOut+0xb4>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
34002e1a:	683b      	ldr	r3, [r7, #0]
34002e1c:	2200      	movs	r2, #0
34002e1e:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
34002e20:	2301      	movs	r3, #1
34002e22:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
34002e24:	f7fe fca6 	bl	34001774 <vPortExitCritical>

    traceRETURN_xTaskCheckForTimeOut( xReturn );

    return xReturn;
34002e28:	697b      	ldr	r3, [r7, #20]
}
34002e2a:	4618      	mov	r0, r3
34002e2c:	3718      	adds	r7, #24
34002e2e:	46bd      	mov	sp, r7
34002e30:	bd80      	pop	{r7, pc}
34002e32:	bf00      	nop
34002e34:	34003f88 	.word	0x34003f88
34002e38:	34003c90 	.word	0x34003c90
34002e3c:	34003f9c 	.word	0x34003f9c

34002e40 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
34002e40:	b480      	push	{r7}
34002e42:	af00      	add	r7, sp, #0
    traceENTER_vTaskMissedYield();

    /* Must be called from within a critical section. */
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
34002e44:	4b03      	ldr	r3, [pc, #12]	@ (34002e54 <vTaskMissedYield+0x14>)
34002e46:	2201      	movs	r2, #1
34002e48:	601a      	str	r2, [r3, #0]

    traceRETURN_vTaskMissedYield();
}
34002e4a:	bf00      	nop
34002e4c:	46bd      	mov	sp, r7
34002e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e52:	4770      	bx	lr
34002e54:	34003f98 	.word	0x34003f98

34002e58 <prvIdleTask>:
 * void prvIdleTask( void *pvParameters );
 *
 */

static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
34002e58:	b580      	push	{r7, lr}
34002e5a:	b082      	sub	sp, #8
34002e5c:	af00      	add	r7, sp, #0
34002e5e:	6078      	str	r0, [r7, #4]

    for( ; configCONTROL_INFINITE_LOOP(); )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
34002e60:	f000 f84a 	bl	34002ef8 <prvCheckTasksWaitingTermination>
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains one more task than the
             * number of idle tasks, which is equal to the configured numbers of cores
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
34002e64:	4b03      	ldr	r3, [pc, #12]	@ (34002e74 <prvIdleTask+0x1c>)
34002e66:	681b      	ldr	r3, [r3, #0]
34002e68:	2b01      	cmp	r3, #1
34002e6a:	d9f9      	bls.n	34002e60 <prvIdleTask+0x8>
            {
                taskYIELD();
34002e6c:	f7fe fc5e 	bl	3400172c <vPortYield>
        prvCheckTasksWaitingTermination();
34002e70:	e7f6      	b.n	34002e60 <prvIdleTask+0x8>
34002e72:	bf00      	nop
34002e74:	34003c94 	.word	0x34003c94

34002e78 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
34002e78:	b580      	push	{r7, lr}
34002e7a:	b082      	sub	sp, #8
34002e7c:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
34002e7e:	2300      	movs	r3, #0
34002e80:	607b      	str	r3, [r7, #4]
34002e82:	e00c      	b.n	34002e9e <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
34002e84:	687a      	ldr	r2, [r7, #4]
34002e86:	4613      	mov	r3, r2
34002e88:	009b      	lsls	r3, r3, #2
34002e8a:	4413      	add	r3, r2
34002e8c:	009b      	lsls	r3, r3, #2
34002e8e:	4a12      	ldr	r2, [pc, #72]	@ (34002ed8 <prvInitialiseTaskLists+0x60>)
34002e90:	4413      	add	r3, r2
34002e92:	4618      	mov	r0, r3
34002e94:	f7fe fb62 	bl	3400155c <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
34002e98:	687b      	ldr	r3, [r7, #4]
34002e9a:	3301      	adds	r3, #1
34002e9c:	607b      	str	r3, [r7, #4]
34002e9e:	687b      	ldr	r3, [r7, #4]
34002ea0:	2b1f      	cmp	r3, #31
34002ea2:	d9ef      	bls.n	34002e84 <prvInitialiseTaskLists+0xc>
    }

    vListInitialise( &xDelayedTaskList1 );
34002ea4:	480d      	ldr	r0, [pc, #52]	@ (34002edc <prvInitialiseTaskLists+0x64>)
34002ea6:	f7fe fb59 	bl	3400155c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
34002eaa:	480d      	ldr	r0, [pc, #52]	@ (34002ee0 <prvInitialiseTaskLists+0x68>)
34002eac:	f7fe fb56 	bl	3400155c <vListInitialise>
    vListInitialise( &xPendingReadyList );
34002eb0:	480c      	ldr	r0, [pc, #48]	@ (34002ee4 <prvInitialiseTaskLists+0x6c>)
34002eb2:	f7fe fb53 	bl	3400155c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
34002eb6:	480c      	ldr	r0, [pc, #48]	@ (34002ee8 <prvInitialiseTaskLists+0x70>)
34002eb8:	f7fe fb50 	bl	3400155c <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
34002ebc:	480b      	ldr	r0, [pc, #44]	@ (34002eec <prvInitialiseTaskLists+0x74>)
34002ebe:	f7fe fb4d 	bl	3400155c <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
34002ec2:	4b0b      	ldr	r3, [pc, #44]	@ (34002ef0 <prvInitialiseTaskLists+0x78>)
34002ec4:	4a05      	ldr	r2, [pc, #20]	@ (34002edc <prvInitialiseTaskLists+0x64>)
34002ec6:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
34002ec8:	4b0a      	ldr	r3, [pc, #40]	@ (34002ef4 <prvInitialiseTaskLists+0x7c>)
34002eca:	4a05      	ldr	r2, [pc, #20]	@ (34002ee0 <prvInitialiseTaskLists+0x68>)
34002ecc:	601a      	str	r2, [r3, #0]
}
34002ece:	bf00      	nop
34002ed0:	3708      	adds	r7, #8
34002ed2:	46bd      	mov	sp, r7
34002ed4:	bd80      	pop	{r7, pc}
34002ed6:	bf00      	nop
34002ed8:	34003c94 	.word	0x34003c94
34002edc:	34003f14 	.word	0x34003f14
34002ee0:	34003f28 	.word	0x34003f28
34002ee4:	34003f44 	.word	0x34003f44
34002ee8:	34003f58 	.word	0x34003f58
34002eec:	34003f70 	.word	0x34003f70
34002ef0:	34003f3c 	.word	0x34003f3c
34002ef4:	34003f40 	.word	0x34003f40

34002ef8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
34002ef8:	b580      	push	{r7, lr}
34002efa:	b082      	sub	sp, #8
34002efc:	af00      	add	r7, sp, #0
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
34002efe:	e019      	b.n	34002f34 <prvCheckTasksWaitingTermination+0x3c>
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                taskENTER_CRITICAL();
34002f00:	f7fe fc26 	bl	34001750 <vPortEnterCritical>
                {
                    {
                        /* MISRA Ref 11.5.3 [Void pointer assignment] */
                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
34002f04:	4b10      	ldr	r3, [pc, #64]	@ (34002f48 <prvCheckTasksWaitingTermination+0x50>)
34002f06:	68db      	ldr	r3, [r3, #12]
34002f08:	68db      	ldr	r3, [r3, #12]
34002f0a:	607b      	str	r3, [r7, #4]
                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
34002f0c:	687b      	ldr	r3, [r7, #4]
34002f0e:	3304      	adds	r3, #4
34002f10:	4618      	mov	r0, r3
34002f12:	f7fe fb89 	bl	34001628 <uxListRemove>
                        --uxCurrentNumberOfTasks;
34002f16:	4b0d      	ldr	r3, [pc, #52]	@ (34002f4c <prvCheckTasksWaitingTermination+0x54>)
34002f18:	681b      	ldr	r3, [r3, #0]
34002f1a:	3b01      	subs	r3, #1
34002f1c:	4a0b      	ldr	r2, [pc, #44]	@ (34002f4c <prvCheckTasksWaitingTermination+0x54>)
34002f1e:	6013      	str	r3, [r2, #0]
                        --uxDeletedTasksWaitingCleanUp;
34002f20:	4b0b      	ldr	r3, [pc, #44]	@ (34002f50 <prvCheckTasksWaitingTermination+0x58>)
34002f22:	681b      	ldr	r3, [r3, #0]
34002f24:	3b01      	subs	r3, #1
34002f26:	4a0a      	ldr	r2, [pc, #40]	@ (34002f50 <prvCheckTasksWaitingTermination+0x58>)
34002f28:	6013      	str	r3, [r2, #0]
                    }
                }
                taskEXIT_CRITICAL();
34002f2a:	f7fe fc23 	bl	34001774 <vPortExitCritical>

                prvDeleteTCB( pxTCB );
34002f2e:	6878      	ldr	r0, [r7, #4]
34002f30:	f000 f810 	bl	34002f54 <prvDeleteTCB>
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
34002f34:	4b06      	ldr	r3, [pc, #24]	@ (34002f50 <prvCheckTasksWaitingTermination+0x58>)
34002f36:	681b      	ldr	r3, [r3, #0]
34002f38:	2b00      	cmp	r3, #0
34002f3a:	d1e1      	bne.n	34002f00 <prvCheckTasksWaitingTermination+0x8>
            }
            #endif /* #if( configNUMBER_OF_CORES == 1 ) */
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
34002f3c:	bf00      	nop
34002f3e:	bf00      	nop
34002f40:	3708      	adds	r7, #8
34002f42:	46bd      	mov	sp, r7
34002f44:	bd80      	pop	{r7, pc}
34002f46:	bf00      	nop
34002f48:	34003f58 	.word	0x34003f58
34002f4c:	34003f84 	.word	0x34003f84
34002f50:	34003f6c 	.word	0x34003f6c

34002f54 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
34002f54:	b580      	push	{r7, lr}
34002f56:	b082      	sub	sp, #8
34002f58:	af00      	add	r7, sp, #0
34002f5a:	6078      	str	r0, [r7, #4]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
34002f5c:	687b      	ldr	r3, [r7, #4]
34002f5e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34002f60:	4618      	mov	r0, r3
34002f62:	f000 fa63 	bl	3400342c <vPortFree>
            vPortFree( pxTCB );
34002f66:	6878      	ldr	r0, [r7, #4]
34002f68:	f000 fa60 	bl	3400342c <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
34002f6c:	bf00      	nop
34002f6e:	3708      	adds	r7, #8
34002f70:	46bd      	mov	sp, r7
34002f72:	bd80      	pop	{r7, pc}

34002f74 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
34002f74:	b480      	push	{r7}
34002f76:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
34002f78:	4b0a      	ldr	r3, [pc, #40]	@ (34002fa4 <prvResetNextTaskUnblockTime+0x30>)
34002f7a:	681b      	ldr	r3, [r3, #0]
34002f7c:	681b      	ldr	r3, [r3, #0]
34002f7e:	2b00      	cmp	r3, #0
34002f80:	d104      	bne.n	34002f8c <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
34002f82:	4b09      	ldr	r3, [pc, #36]	@ (34002fa8 <prvResetNextTaskUnblockTime+0x34>)
34002f84:	f04f 32ff 	mov.w	r2, #4294967295
34002f88:	601a      	str	r2, [r3, #0]
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
34002f8a:	e005      	b.n	34002f98 <prvResetNextTaskUnblockTime+0x24>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
34002f8c:	4b05      	ldr	r3, [pc, #20]	@ (34002fa4 <prvResetNextTaskUnblockTime+0x30>)
34002f8e:	681b      	ldr	r3, [r3, #0]
34002f90:	68db      	ldr	r3, [r3, #12]
34002f92:	681b      	ldr	r3, [r3, #0]
34002f94:	4a04      	ldr	r2, [pc, #16]	@ (34002fa8 <prvResetNextTaskUnblockTime+0x34>)
34002f96:	6013      	str	r3, [r2, #0]
}
34002f98:	bf00      	nop
34002f9a:	46bd      	mov	sp, r7
34002f9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002fa0:	4770      	bx	lr
34002fa2:	bf00      	nop
34002fa4:	34003f3c 	.word	0x34003f3c
34002fa8:	34003fa4 	.word	0x34003fa4

34002fac <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
34002fac:	b480      	push	{r7}
34002fae:	b083      	sub	sp, #12
34002fb0:	af00      	add	r7, sp, #0
        BaseType_t xReturn;

        traceENTER_xTaskGetSchedulerState();

        if( xSchedulerRunning == pdFALSE )
34002fb2:	4b0b      	ldr	r3, [pc, #44]	@ (34002fe0 <xTaskGetSchedulerState+0x34>)
34002fb4:	681b      	ldr	r3, [r3, #0]
34002fb6:	2b00      	cmp	r3, #0
34002fb8:	d102      	bne.n	34002fc0 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
34002fba:	2301      	movs	r3, #1
34002fbc:	607b      	str	r3, [r7, #4]
34002fbe:	e008      	b.n	34002fd2 <xTaskGetSchedulerState+0x26>
        {
            #if ( configNUMBER_OF_CORES > 1 )
                taskENTER_CRITICAL();
            #endif
            {
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
34002fc0:	4b08      	ldr	r3, [pc, #32]	@ (34002fe4 <xTaskGetSchedulerState+0x38>)
34002fc2:	681b      	ldr	r3, [r3, #0]
34002fc4:	2b00      	cmp	r3, #0
34002fc6:	d102      	bne.n	34002fce <xTaskGetSchedulerState+0x22>
                {
                    xReturn = taskSCHEDULER_RUNNING;
34002fc8:	2302      	movs	r3, #2
34002fca:	607b      	str	r3, [r7, #4]
34002fcc:	e001      	b.n	34002fd2 <xTaskGetSchedulerState+0x26>
                }
                else
                {
                    xReturn = taskSCHEDULER_SUSPENDED;
34002fce:	2300      	movs	r3, #0
34002fd0:	607b      	str	r3, [r7, #4]
            #endif
        }

        traceRETURN_xTaskGetSchedulerState( xReturn );

        return xReturn;
34002fd2:	687b      	ldr	r3, [r7, #4]
    }
34002fd4:	4618      	mov	r0, r3
34002fd6:	370c      	adds	r7, #12
34002fd8:	46bd      	mov	sp, r7
34002fda:	f85d 7b04 	ldr.w	r7, [sp], #4
34002fde:	4770      	bx	lr
34002fe0:	34003f90 	.word	0x34003f90
34002fe4:	34003fac 	.word	0x34003fac

34002fe8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
34002fe8:	b580      	push	{r7, lr}
34002fea:	b086      	sub	sp, #24
34002fec:	af00      	add	r7, sp, #0
34002fee:	6078      	str	r0, [r7, #4]
        TCB_t * const pxTCB = pxMutexHolder;
34002ff0:	687b      	ldr	r3, [r7, #4]
34002ff2:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
34002ff4:	2300      	movs	r3, #0
34002ff6:	617b      	str	r3, [r7, #20]

        traceENTER_xTaskPriorityDisinherit( pxMutexHolder );

        if( pxMutexHolder != NULL )
34002ff8:	687b      	ldr	r3, [r7, #4]
34002ffa:	2b00      	cmp	r3, #0
34002ffc:	d07f      	beq.n	340030fe <xTaskPriorityDisinherit+0x116>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
34002ffe:	4b42      	ldr	r3, [pc, #264]	@ (34003108 <xTaskPriorityDisinherit+0x120>)
34003000:	681b      	ldr	r3, [r3, #0]
34003002:	693a      	ldr	r2, [r7, #16]
34003004:	429a      	cmp	r2, r3
34003006:	d003      	beq.n	34003010 <xTaskPriorityDisinherit+0x28>
34003008:	f7fe fd48 	bl	34001a9c <ulSetInterruptMask>
3400300c:	bf00      	nop
3400300e:	e7fd      	b.n	3400300c <xTaskPriorityDisinherit+0x24>
            configASSERT( pxTCB->uxMutexesHeld );
34003010:	693b      	ldr	r3, [r7, #16]
34003012:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34003014:	2b00      	cmp	r3, #0
34003016:	d103      	bne.n	34003020 <xTaskPriorityDisinherit+0x38>
34003018:	f7fe fd40 	bl	34001a9c <ulSetInterruptMask>
3400301c:	bf00      	nop
3400301e:	e7fd      	b.n	3400301c <xTaskPriorityDisinherit+0x34>
            ( pxTCB->uxMutexesHeld )--;
34003020:	693b      	ldr	r3, [r7, #16]
34003022:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34003024:	1e5a      	subs	r2, r3, #1
34003026:	693b      	ldr	r3, [r7, #16]
34003028:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3400302a:	693b      	ldr	r3, [r7, #16]
3400302c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400302e:	693b      	ldr	r3, [r7, #16]
34003030:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34003032:	429a      	cmp	r2, r3
34003034:	d063      	beq.n	340030fe <xTaskPriorityDisinherit+0x116>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
34003036:	693b      	ldr	r3, [r7, #16]
34003038:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400303a:	2b00      	cmp	r3, #0
3400303c:	d15f      	bne.n	340030fe <xTaskPriorityDisinherit+0x116>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3400303e:	693b      	ldr	r3, [r7, #16]
34003040:	3304      	adds	r3, #4
34003042:	4618      	mov	r0, r3
34003044:	f7fe faf0 	bl	34001628 <uxListRemove>
34003048:	4603      	mov	r3, r0
3400304a:	2b00      	cmp	r3, #0
3400304c:	d10a      	bne.n	34003064 <xTaskPriorityDisinherit+0x7c>
                    {
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
3400304e:	693b      	ldr	r3, [r7, #16]
34003050:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34003052:	2201      	movs	r2, #1
34003054:	fa02 f303 	lsl.w	r3, r2, r3
34003058:	43da      	mvns	r2, r3
3400305a:	4b2c      	ldr	r3, [pc, #176]	@ (3400310c <xTaskPriorityDisinherit+0x124>)
3400305c:	681b      	ldr	r3, [r3, #0]
3400305e:	4013      	ands	r3, r2
34003060:	4a2a      	ldr	r2, [pc, #168]	@ (3400310c <xTaskPriorityDisinherit+0x124>)
34003062:	6013      	str	r3, [r2, #0]
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
34003064:	693b      	ldr	r3, [r7, #16]
34003066:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34003068:	693b      	ldr	r3, [r7, #16]
3400306a:	62da      	str	r2, [r3, #44]	@ 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
3400306c:	693b      	ldr	r3, [r7, #16]
3400306e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34003070:	f1c3 0220 	rsb	r2, r3, #32
34003074:	693b      	ldr	r3, [r7, #16]
34003076:	619a      	str	r2, [r3, #24]
                    prvAddTaskToReadyList( pxTCB );
34003078:	693b      	ldr	r3, [r7, #16]
3400307a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400307c:	2201      	movs	r2, #1
3400307e:	409a      	lsls	r2, r3
34003080:	4b22      	ldr	r3, [pc, #136]	@ (3400310c <xTaskPriorityDisinherit+0x124>)
34003082:	681b      	ldr	r3, [r3, #0]
34003084:	4313      	orrs	r3, r2
34003086:	4a21      	ldr	r2, [pc, #132]	@ (3400310c <xTaskPriorityDisinherit+0x124>)
34003088:	6013      	str	r3, [r2, #0]
3400308a:	693b      	ldr	r3, [r7, #16]
3400308c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400308e:	4920      	ldr	r1, [pc, #128]	@ (34003110 <xTaskPriorityDisinherit+0x128>)
34003090:	4613      	mov	r3, r2
34003092:	009b      	lsls	r3, r3, #2
34003094:	4413      	add	r3, r2
34003096:	009b      	lsls	r3, r3, #2
34003098:	440b      	add	r3, r1
3400309a:	3304      	adds	r3, #4
3400309c:	681b      	ldr	r3, [r3, #0]
3400309e:	60fb      	str	r3, [r7, #12]
340030a0:	693b      	ldr	r3, [r7, #16]
340030a2:	68fa      	ldr	r2, [r7, #12]
340030a4:	609a      	str	r2, [r3, #8]
340030a6:	68fb      	ldr	r3, [r7, #12]
340030a8:	689a      	ldr	r2, [r3, #8]
340030aa:	693b      	ldr	r3, [r7, #16]
340030ac:	60da      	str	r2, [r3, #12]
340030ae:	68fb      	ldr	r3, [r7, #12]
340030b0:	689b      	ldr	r3, [r3, #8]
340030b2:	693a      	ldr	r2, [r7, #16]
340030b4:	3204      	adds	r2, #4
340030b6:	605a      	str	r2, [r3, #4]
340030b8:	693b      	ldr	r3, [r7, #16]
340030ba:	1d1a      	adds	r2, r3, #4
340030bc:	68fb      	ldr	r3, [r7, #12]
340030be:	609a      	str	r2, [r3, #8]
340030c0:	693b      	ldr	r3, [r7, #16]
340030c2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340030c4:	4613      	mov	r3, r2
340030c6:	009b      	lsls	r3, r3, #2
340030c8:	4413      	add	r3, r2
340030ca:	009b      	lsls	r3, r3, #2
340030cc:	4a10      	ldr	r2, [pc, #64]	@ (34003110 <xTaskPriorityDisinherit+0x128>)
340030ce:	441a      	add	r2, r3
340030d0:	693b      	ldr	r3, [r7, #16]
340030d2:	615a      	str	r2, [r3, #20]
340030d4:	693b      	ldr	r3, [r7, #16]
340030d6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340030d8:	490d      	ldr	r1, [pc, #52]	@ (34003110 <xTaskPriorityDisinherit+0x128>)
340030da:	4613      	mov	r3, r2
340030dc:	009b      	lsls	r3, r3, #2
340030de:	4413      	add	r3, r2
340030e0:	009b      	lsls	r3, r3, #2
340030e2:	440b      	add	r3, r1
340030e4:	681b      	ldr	r3, [r3, #0]
340030e6:	693a      	ldr	r2, [r7, #16]
340030e8:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
340030ea:	1c59      	adds	r1, r3, #1
340030ec:	4808      	ldr	r0, [pc, #32]	@ (34003110 <xTaskPriorityDisinherit+0x128>)
340030ee:	4613      	mov	r3, r2
340030f0:	009b      	lsls	r3, r3, #2
340030f2:	4413      	add	r3, r2
340030f4:	009b      	lsls	r3, r3, #2
340030f6:	4403      	add	r3, r0
340030f8:	6019      	str	r1, [r3, #0]
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
340030fa:	2301      	movs	r3, #1
340030fc:	617b      	str	r3, [r7, #20]
            mtCOVERAGE_TEST_MARKER();
        }

        traceRETURN_xTaskPriorityDisinherit( xReturn );

        return xReturn;
340030fe:	697b      	ldr	r3, [r7, #20]
    }
34003100:	4618      	mov	r0, r3
34003102:	3718      	adds	r7, #24
34003104:	46bd      	mov	sp, r7
34003106:	bd80      	pop	{r7, pc}
34003108:	34003c90 	.word	0x34003c90
3400310c:	34003f8c 	.word	0x34003f8c
34003110:	34003c94 	.word	0x34003c94

34003114 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
34003114:	b580      	push	{r7, lr}
34003116:	b088      	sub	sp, #32
34003118:	af00      	add	r7, sp, #0
3400311a:	6078      	str	r0, [r7, #4]
3400311c:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
3400311e:	4b39      	ldr	r3, [pc, #228]	@ (34003204 <prvAddCurrentTaskToDelayedList+0xf0>)
34003120:	681b      	ldr	r3, [r3, #0]
34003122:	61fb      	str	r3, [r7, #28]
    List_t * const pxDelayedList = pxDelayedTaskList;
34003124:	4b38      	ldr	r3, [pc, #224]	@ (34003208 <prvAddCurrentTaskToDelayedList+0xf4>)
34003126:	681b      	ldr	r3, [r3, #0]
34003128:	61bb      	str	r3, [r7, #24]
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
3400312a:	4b38      	ldr	r3, [pc, #224]	@ (3400320c <prvAddCurrentTaskToDelayedList+0xf8>)
3400312c:	681b      	ldr	r3, [r3, #0]
3400312e:	617b      	str	r3, [r7, #20]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. */
        pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
34003130:	4b37      	ldr	r3, [pc, #220]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
34003132:	681b      	ldr	r3, [r3, #0]
34003134:	2200      	movs	r2, #0
34003136:	f883 2055 	strb.w	r2, [r3, #85]	@ 0x55
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3400313a:	4b35      	ldr	r3, [pc, #212]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
3400313c:	681b      	ldr	r3, [r3, #0]
3400313e:	3304      	adds	r3, #4
34003140:	4618      	mov	r0, r3
34003142:	f7fe fa71 	bl	34001628 <uxListRemove>
34003146:	4603      	mov	r3, r0
34003148:	2b00      	cmp	r3, #0
3400314a:	d10b      	bne.n	34003164 <prvAddCurrentTaskToDelayedList+0x50>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
3400314c:	4b30      	ldr	r3, [pc, #192]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
3400314e:	681b      	ldr	r3, [r3, #0]
34003150:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34003152:	2201      	movs	r2, #1
34003154:	fa02 f303 	lsl.w	r3, r2, r3
34003158:	43da      	mvns	r2, r3
3400315a:	4b2e      	ldr	r3, [pc, #184]	@ (34003214 <prvAddCurrentTaskToDelayedList+0x100>)
3400315c:	681b      	ldr	r3, [r3, #0]
3400315e:	4013      	ands	r3, r2
34003160:	4a2c      	ldr	r2, [pc, #176]	@ (34003214 <prvAddCurrentTaskToDelayedList+0x100>)
34003162:	6013      	str	r3, [r2, #0]
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
34003164:	687b      	ldr	r3, [r7, #4]
34003166:	f1b3 3fff 	cmp.w	r3, #4294967295
3400316a:	d124      	bne.n	340031b6 <prvAddCurrentTaskToDelayedList+0xa2>
3400316c:	683b      	ldr	r3, [r7, #0]
3400316e:	2b00      	cmp	r3, #0
34003170:	d021      	beq.n	340031b6 <prvAddCurrentTaskToDelayedList+0xa2>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
34003172:	4b29      	ldr	r3, [pc, #164]	@ (34003218 <prvAddCurrentTaskToDelayedList+0x104>)
34003174:	685b      	ldr	r3, [r3, #4]
34003176:	613b      	str	r3, [r7, #16]
34003178:	4b25      	ldr	r3, [pc, #148]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
3400317a:	681b      	ldr	r3, [r3, #0]
3400317c:	693a      	ldr	r2, [r7, #16]
3400317e:	609a      	str	r2, [r3, #8]
34003180:	4b23      	ldr	r3, [pc, #140]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
34003182:	681b      	ldr	r3, [r3, #0]
34003184:	693a      	ldr	r2, [r7, #16]
34003186:	6892      	ldr	r2, [r2, #8]
34003188:	60da      	str	r2, [r3, #12]
3400318a:	4b21      	ldr	r3, [pc, #132]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
3400318c:	681a      	ldr	r2, [r3, #0]
3400318e:	693b      	ldr	r3, [r7, #16]
34003190:	689b      	ldr	r3, [r3, #8]
34003192:	3204      	adds	r2, #4
34003194:	605a      	str	r2, [r3, #4]
34003196:	4b1e      	ldr	r3, [pc, #120]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
34003198:	681b      	ldr	r3, [r3, #0]
3400319a:	1d1a      	adds	r2, r3, #4
3400319c:	693b      	ldr	r3, [r7, #16]
3400319e:	609a      	str	r2, [r3, #8]
340031a0:	4b1b      	ldr	r3, [pc, #108]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
340031a2:	681b      	ldr	r3, [r3, #0]
340031a4:	4a1c      	ldr	r2, [pc, #112]	@ (34003218 <prvAddCurrentTaskToDelayedList+0x104>)
340031a6:	615a      	str	r2, [r3, #20]
340031a8:	4b1b      	ldr	r3, [pc, #108]	@ (34003218 <prvAddCurrentTaskToDelayedList+0x104>)
340031aa:	681b      	ldr	r3, [r3, #0]
340031ac:	3301      	adds	r3, #1
340031ae:	4a1a      	ldr	r2, [pc, #104]	@ (34003218 <prvAddCurrentTaskToDelayedList+0x104>)
340031b0:	6013      	str	r3, [r2, #0]
340031b2:	bf00      	nop

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
340031b4:	e022      	b.n	340031fc <prvAddCurrentTaskToDelayedList+0xe8>
            xTimeToWake = xConstTickCount + xTicksToWait;
340031b6:	69fa      	ldr	r2, [r7, #28]
340031b8:	687b      	ldr	r3, [r7, #4]
340031ba:	4413      	add	r3, r2
340031bc:	60fb      	str	r3, [r7, #12]
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
340031be:	4b14      	ldr	r3, [pc, #80]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
340031c0:	681b      	ldr	r3, [r3, #0]
340031c2:	68fa      	ldr	r2, [r7, #12]
340031c4:	605a      	str	r2, [r3, #4]
            if( xTimeToWake < xConstTickCount )
340031c6:	68fa      	ldr	r2, [r7, #12]
340031c8:	69fb      	ldr	r3, [r7, #28]
340031ca:	429a      	cmp	r2, r3
340031cc:	d207      	bcs.n	340031de <prvAddCurrentTaskToDelayedList+0xca>
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
340031ce:	4b10      	ldr	r3, [pc, #64]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
340031d0:	681b      	ldr	r3, [r3, #0]
340031d2:	3304      	adds	r3, #4
340031d4:	4619      	mov	r1, r3
340031d6:	6978      	ldr	r0, [r7, #20]
340031d8:	f7fe f9ed 	bl	340015b6 <vListInsert>
}
340031dc:	e00e      	b.n	340031fc <prvAddCurrentTaskToDelayedList+0xe8>
                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
340031de:	4b0c      	ldr	r3, [pc, #48]	@ (34003210 <prvAddCurrentTaskToDelayedList+0xfc>)
340031e0:	681b      	ldr	r3, [r3, #0]
340031e2:	3304      	adds	r3, #4
340031e4:	4619      	mov	r1, r3
340031e6:	69b8      	ldr	r0, [r7, #24]
340031e8:	f7fe f9e5 	bl	340015b6 <vListInsert>
                if( xTimeToWake < xNextTaskUnblockTime )
340031ec:	4b0b      	ldr	r3, [pc, #44]	@ (3400321c <prvAddCurrentTaskToDelayedList+0x108>)
340031ee:	681b      	ldr	r3, [r3, #0]
340031f0:	68fa      	ldr	r2, [r7, #12]
340031f2:	429a      	cmp	r2, r3
340031f4:	d202      	bcs.n	340031fc <prvAddCurrentTaskToDelayedList+0xe8>
                    xNextTaskUnblockTime = xTimeToWake;
340031f6:	4a09      	ldr	r2, [pc, #36]	@ (3400321c <prvAddCurrentTaskToDelayedList+0x108>)
340031f8:	68fb      	ldr	r3, [r7, #12]
340031fa:	6013      	str	r3, [r2, #0]
}
340031fc:	bf00      	nop
340031fe:	3720      	adds	r7, #32
34003200:	46bd      	mov	sp, r7
34003202:	bd80      	pop	{r7, pc}
34003204:	34003f88 	.word	0x34003f88
34003208:	34003f3c 	.word	0x34003f3c
3400320c:	34003f40 	.word	0x34003f40
34003210:	34003c90 	.word	0x34003c90
34003214:	34003f8c 	.word	0x34003f8c
34003218:	34003f70 	.word	0x34003f70
3400321c:	34003fa4 	.word	0x34003fa4

34003220 <pvPortMalloc>:
PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = ( size_t ) 0U;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
34003220:	b580      	push	{r7, lr}
34003222:	b088      	sub	sp, #32
34003224:	af00      	add	r7, sp, #0
34003226:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock;
    BlockLink_t * pxPreviousBlock;
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
34003228:	2300      	movs	r3, #0
3400322a:	617b      	str	r3, [r7, #20]
    size_t xAdditionalRequiredSize;

    if( xWantedSize > 0 )
3400322c:	687b      	ldr	r3, [r7, #4]
3400322e:	2b00      	cmp	r3, #0
34003230:	d022      	beq.n	34003278 <pvPortMalloc+0x58>
    {
        /* The wanted size must be increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
34003232:	2308      	movs	r3, #8
34003234:	43db      	mvns	r3, r3
34003236:	687a      	ldr	r2, [r7, #4]
34003238:	429a      	cmp	r2, r3
3400323a:	d81b      	bhi.n	34003274 <pvPortMalloc+0x54>
        {
            xWantedSize += xHeapStructSize;
3400323c:	2208      	movs	r2, #8
3400323e:	687b      	ldr	r3, [r7, #4]
34003240:	4413      	add	r3, r2
34003242:	607b      	str	r3, [r7, #4]

            /* Ensure that blocks are always aligned to the required number
             * of bytes. */
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
34003244:	687b      	ldr	r3, [r7, #4]
34003246:	f003 0307 	and.w	r3, r3, #7
3400324a:	2b00      	cmp	r3, #0
3400324c:	d014      	beq.n	34003278 <pvPortMalloc+0x58>
            {
                /* Byte alignment required. */
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
3400324e:	687b      	ldr	r3, [r7, #4]
34003250:	f003 0307 	and.w	r3, r3, #7
34003254:	f1c3 0308 	rsb	r3, r3, #8
34003258:	613b      	str	r3, [r7, #16]

                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
3400325a:	693b      	ldr	r3, [r7, #16]
3400325c:	43db      	mvns	r3, r3
3400325e:	687a      	ldr	r2, [r7, #4]
34003260:	429a      	cmp	r2, r3
34003262:	d804      	bhi.n	3400326e <pvPortMalloc+0x4e>
                {
                    xWantedSize += xAdditionalRequiredSize;
34003264:	687a      	ldr	r2, [r7, #4]
34003266:	693b      	ldr	r3, [r7, #16]
34003268:	4413      	add	r3, r2
3400326a:	607b      	str	r3, [r7, #4]
3400326c:	e004      	b.n	34003278 <pvPortMalloc+0x58>
                }
                else
                {
                    xWantedSize = 0;
3400326e:	2300      	movs	r3, #0
34003270:	607b      	str	r3, [r7, #4]
34003272:	e001      	b.n	34003278 <pvPortMalloc+0x58>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            xWantedSize = 0;
34003274:	2300      	movs	r3, #0
34003276:	607b      	str	r3, [r7, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    vTaskSuspendAll();
34003278:	f7ff f9b0 	bl	340025dc <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
3400327c:	4b64      	ldr	r3, [pc, #400]	@ (34003410 <pvPortMalloc+0x1f0>)
3400327e:	681b      	ldr	r3, [r3, #0]
34003280:	2b00      	cmp	r3, #0
34003282:	d101      	bne.n	34003288 <pvPortMalloc+0x68>
        {
            prvHeapInit();
34003284:	f000 f930 	bl	340034e8 <prvHeapInit>

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
34003288:	687b      	ldr	r3, [r7, #4]
3400328a:	2b00      	cmp	r3, #0
3400328c:	f2c0 80ab 	blt.w	340033e6 <pvPortMalloc+0x1c6>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
34003290:	687b      	ldr	r3, [r7, #4]
34003292:	2b00      	cmp	r3, #0
34003294:	f000 80a7 	beq.w	340033e6 <pvPortMalloc+0x1c6>
34003298:	4b5e      	ldr	r3, [pc, #376]	@ (34003414 <pvPortMalloc+0x1f4>)
3400329a:	681b      	ldr	r3, [r3, #0]
3400329c:	687a      	ldr	r2, [r7, #4]
3400329e:	429a      	cmp	r2, r3
340032a0:	f200 80a1 	bhi.w	340033e6 <pvPortMalloc+0x1c6>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
340032a4:	4b5c      	ldr	r3, [pc, #368]	@ (34003418 <pvPortMalloc+0x1f8>)
340032a6:	61bb      	str	r3, [r7, #24]
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
340032a8:	4b5b      	ldr	r3, [pc, #364]	@ (34003418 <pvPortMalloc+0x1f8>)
340032aa:	681b      	ldr	r3, [r3, #0]
340032ac:	61fb      	str	r3, [r7, #28]
                heapVALIDATE_BLOCK_POINTER( pxBlock );
340032ae:	69fb      	ldr	r3, [r7, #28]
340032b0:	4a5a      	ldr	r2, [pc, #360]	@ (3400341c <pvPortMalloc+0x1fc>)
340032b2:	4293      	cmp	r3, r2
340032b4:	d305      	bcc.n	340032c2 <pvPortMalloc+0xa2>
340032b6:	69fb      	ldr	r3, [r7, #28]
340032b8:	4a59      	ldr	r2, [pc, #356]	@ (34003420 <pvPortMalloc+0x200>)
340032ba:	4293      	cmp	r3, r2
340032bc:	d801      	bhi.n	340032c2 <pvPortMalloc+0xa2>
340032be:	2301      	movs	r3, #1
340032c0:	e000      	b.n	340032c4 <pvPortMalloc+0xa4>
340032c2:	2300      	movs	r3, #0
340032c4:	2b00      	cmp	r3, #0
340032c6:	d119      	bne.n	340032fc <pvPortMalloc+0xdc>
340032c8:	f7fe fbe8 	bl	34001a9c <ulSetInterruptMask>
340032cc:	bf00      	nop
340032ce:	e7fd      	b.n	340032cc <pvPortMalloc+0xac>

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
                {
                    pxPreviousBlock = pxBlock;
340032d0:	69fb      	ldr	r3, [r7, #28]
340032d2:	61bb      	str	r3, [r7, #24]
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
340032d4:	69fb      	ldr	r3, [r7, #28]
340032d6:	681b      	ldr	r3, [r3, #0]
340032d8:	61fb      	str	r3, [r7, #28]
                    heapVALIDATE_BLOCK_POINTER( pxBlock );
340032da:	69fb      	ldr	r3, [r7, #28]
340032dc:	4a4f      	ldr	r2, [pc, #316]	@ (3400341c <pvPortMalloc+0x1fc>)
340032de:	4293      	cmp	r3, r2
340032e0:	d305      	bcc.n	340032ee <pvPortMalloc+0xce>
340032e2:	69fb      	ldr	r3, [r7, #28]
340032e4:	4a4e      	ldr	r2, [pc, #312]	@ (34003420 <pvPortMalloc+0x200>)
340032e6:	4293      	cmp	r3, r2
340032e8:	d801      	bhi.n	340032ee <pvPortMalloc+0xce>
340032ea:	2301      	movs	r3, #1
340032ec:	e000      	b.n	340032f0 <pvPortMalloc+0xd0>
340032ee:	2300      	movs	r3, #0
340032f0:	2b00      	cmp	r3, #0
340032f2:	d103      	bne.n	340032fc <pvPortMalloc+0xdc>
340032f4:	f7fe fbd2 	bl	34001a9c <ulSetInterruptMask>
340032f8:	bf00      	nop
340032fa:	e7fd      	b.n	340032f8 <pvPortMalloc+0xd8>
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
340032fc:	69fb      	ldr	r3, [r7, #28]
340032fe:	685b      	ldr	r3, [r3, #4]
34003300:	687a      	ldr	r2, [r7, #4]
34003302:	429a      	cmp	r2, r3
34003304:	d903      	bls.n	3400330e <pvPortMalloc+0xee>
34003306:	69fb      	ldr	r3, [r7, #28]
34003308:	681b      	ldr	r3, [r3, #0]
3400330a:	2b00      	cmp	r3, #0
3400330c:	d1e0      	bne.n	340032d0 <pvPortMalloc+0xb0>
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
3400330e:	4b40      	ldr	r3, [pc, #256]	@ (34003410 <pvPortMalloc+0x1f0>)
34003310:	681b      	ldr	r3, [r3, #0]
34003312:	69fa      	ldr	r2, [r7, #28]
34003314:	429a      	cmp	r2, r3
34003316:	d066      	beq.n	340033e6 <pvPortMalloc+0x1c6>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
34003318:	69bb      	ldr	r3, [r7, #24]
3400331a:	681b      	ldr	r3, [r3, #0]
3400331c:	2208      	movs	r2, #8
3400331e:	4413      	add	r3, r2
34003320:	617b      	str	r3, [r7, #20]
                    heapVALIDATE_BLOCK_POINTER( pvReturn );
34003322:	697b      	ldr	r3, [r7, #20]
34003324:	4a3d      	ldr	r2, [pc, #244]	@ (3400341c <pvPortMalloc+0x1fc>)
34003326:	4293      	cmp	r3, r2
34003328:	d305      	bcc.n	34003336 <pvPortMalloc+0x116>
3400332a:	697b      	ldr	r3, [r7, #20]
3400332c:	4a3c      	ldr	r2, [pc, #240]	@ (34003420 <pvPortMalloc+0x200>)
3400332e:	4293      	cmp	r3, r2
34003330:	d801      	bhi.n	34003336 <pvPortMalloc+0x116>
34003332:	2301      	movs	r3, #1
34003334:	e000      	b.n	34003338 <pvPortMalloc+0x118>
34003336:	2300      	movs	r3, #0
34003338:	2b00      	cmp	r3, #0
3400333a:	d103      	bne.n	34003344 <pvPortMalloc+0x124>
3400333c:	f7fe fbae 	bl	34001a9c <ulSetInterruptMask>
34003340:	bf00      	nop
34003342:	e7fd      	b.n	34003340 <pvPortMalloc+0x120>

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
34003344:	69fb      	ldr	r3, [r7, #28]
34003346:	681a      	ldr	r2, [r3, #0]
34003348:	69bb      	ldr	r3, [r7, #24]
3400334a:	601a      	str	r2, [r3, #0]

                    /* If the block is larger than required it can be split into
                     * two. */
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );
3400334c:	69fb      	ldr	r3, [r7, #28]
3400334e:	685b      	ldr	r3, [r3, #4]
34003350:	687a      	ldr	r2, [r7, #4]
34003352:	429a      	cmp	r2, r3
34003354:	d903      	bls.n	3400335e <pvPortMalloc+0x13e>
34003356:	f7fe fba1 	bl	34001a9c <ulSetInterruptMask>
3400335a:	bf00      	nop
3400335c:	e7fd      	b.n	3400335a <pvPortMalloc+0x13a>

                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
3400335e:	69fb      	ldr	r3, [r7, #28]
34003360:	685a      	ldr	r2, [r3, #4]
34003362:	687b      	ldr	r3, [r7, #4]
34003364:	1ad2      	subs	r2, r2, r3
34003366:	2308      	movs	r3, #8
34003368:	005b      	lsls	r3, r3, #1
3400336a:	429a      	cmp	r2, r3
3400336c:	d91c      	bls.n	340033a8 <pvPortMalloc+0x188>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
3400336e:	69fa      	ldr	r2, [r7, #28]
34003370:	687b      	ldr	r3, [r7, #4]
34003372:	4413      	add	r3, r2
34003374:	60fb      	str	r3, [r7, #12]
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
34003376:	68fb      	ldr	r3, [r7, #12]
34003378:	f003 0307 	and.w	r3, r3, #7
3400337c:	2b00      	cmp	r3, #0
3400337e:	d003      	beq.n	34003388 <pvPortMalloc+0x168>
34003380:	f7fe fb8c 	bl	34001a9c <ulSetInterruptMask>
34003384:	bf00      	nop
34003386:	e7fd      	b.n	34003384 <pvPortMalloc+0x164>

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
34003388:	69fb      	ldr	r3, [r7, #28]
3400338a:	685a      	ldr	r2, [r3, #4]
3400338c:	687b      	ldr	r3, [r7, #4]
3400338e:	1ad2      	subs	r2, r2, r3
34003390:	68fb      	ldr	r3, [r7, #12]
34003392:	605a      	str	r2, [r3, #4]
                        pxBlock->xBlockSize = xWantedSize;
34003394:	69fb      	ldr	r3, [r7, #28]
34003396:	687a      	ldr	r2, [r7, #4]
34003398:	605a      	str	r2, [r3, #4]

                        /* Insert the new block into the list of free blocks. */
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
3400339a:	69bb      	ldr	r3, [r7, #24]
3400339c:	681a      	ldr	r2, [r3, #0]
3400339e:	68fb      	ldr	r3, [r7, #12]
340033a0:	601a      	str	r2, [r3, #0]
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
340033a2:	69bb      	ldr	r3, [r7, #24]
340033a4:	68fa      	ldr	r2, [r7, #12]
340033a6:	601a      	str	r2, [r3, #0]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
340033a8:	4b1a      	ldr	r3, [pc, #104]	@ (34003414 <pvPortMalloc+0x1f4>)
340033aa:	681a      	ldr	r2, [r3, #0]
340033ac:	69fb      	ldr	r3, [r7, #28]
340033ae:	685b      	ldr	r3, [r3, #4]
340033b0:	1ad3      	subs	r3, r2, r3
340033b2:	4a18      	ldr	r2, [pc, #96]	@ (34003414 <pvPortMalloc+0x1f4>)
340033b4:	6013      	str	r3, [r2, #0]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
340033b6:	4b17      	ldr	r3, [pc, #92]	@ (34003414 <pvPortMalloc+0x1f4>)
340033b8:	681a      	ldr	r2, [r3, #0]
340033ba:	4b1a      	ldr	r3, [pc, #104]	@ (34003424 <pvPortMalloc+0x204>)
340033bc:	681b      	ldr	r3, [r3, #0]
340033be:	429a      	cmp	r2, r3
340033c0:	d203      	bcs.n	340033ca <pvPortMalloc+0x1aa>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
340033c2:	4b14      	ldr	r3, [pc, #80]	@ (34003414 <pvPortMalloc+0x1f4>)
340033c4:	681b      	ldr	r3, [r3, #0]
340033c6:	4a17      	ldr	r2, [pc, #92]	@ (34003424 <pvPortMalloc+0x204>)
340033c8:	6013      	str	r3, [r2, #0]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
340033ca:	69fb      	ldr	r3, [r7, #28]
340033cc:	685b      	ldr	r3, [r3, #4]
340033ce:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
340033d2:	69fb      	ldr	r3, [r7, #28]
340033d4:	605a      	str	r2, [r3, #4]
                    pxBlock->pxNextFreeBlock = NULL;
340033d6:	69fb      	ldr	r3, [r7, #28]
340033d8:	2200      	movs	r2, #0
340033da:	601a      	str	r2, [r3, #0]
                    xNumberOfSuccessfulAllocations++;
340033dc:	4b12      	ldr	r3, [pc, #72]	@ (34003428 <pvPortMalloc+0x208>)
340033de:	681b      	ldr	r3, [r3, #0]
340033e0:	3301      	adds	r3, #1
340033e2:	4a11      	ldr	r2, [pc, #68]	@ (34003428 <pvPortMalloc+0x208>)
340033e4:	6013      	str	r3, [r2, #0]
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
340033e6:	f7ff f907 	bl	340025f8 <xTaskResumeAll>

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
340033ea:	697b      	ldr	r3, [r7, #20]
340033ec:	2b00      	cmp	r3, #0
340033ee:	d101      	bne.n	340033f4 <pvPortMalloc+0x1d4>
        {
            vApplicationMallocFailedHook();
340033f0:	f7fd fa5e 	bl	340008b0 <vApplicationMallocFailedHook>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
340033f4:	697b      	ldr	r3, [r7, #20]
340033f6:	f003 0307 	and.w	r3, r3, #7
340033fa:	2b00      	cmp	r3, #0
340033fc:	d003      	beq.n	34003406 <pvPortMalloc+0x1e6>
340033fe:	f7fe fb4d 	bl	34001a9c <ulSetInterruptMask>
34003402:	bf00      	nop
34003404:	e7fd      	b.n	34003402 <pvPortMalloc+0x1e2>
    return pvReturn;
34003406:	697b      	ldr	r3, [r7, #20]
}
34003408:	4618      	mov	r0, r3
3400340a:	3720      	adds	r7, #32
3400340c:	46bd      	mov	sp, r7
3400340e:	bd80      	pop	{r7, pc}
34003410:	34012fb8 	.word	0x34012fb8
34003414:	34012fbc 	.word	0x34012fbc
34003418:	34012fb0 	.word	0x34012fb0
3400341c:	34003fb0 	.word	0x34003fb0
34003420:	34012faf 	.word	0x34012faf
34003424:	34012fc0 	.word	0x34012fc0
34003428:	34012fc4 	.word	0x34012fc4

3400342c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
3400342c:	b580      	push	{r7, lr}
3400342e:	b084      	sub	sp, #16
34003430:	af00      	add	r7, sp, #0
34003432:	6078      	str	r0, [r7, #4]
    uint8_t * puc = ( uint8_t * ) pv;
34003434:	687b      	ldr	r3, [r7, #4]
34003436:	60fb      	str	r3, [r7, #12]
    BlockLink_t * pxLink;

    if( pv != NULL )
34003438:	687b      	ldr	r3, [r7, #4]
3400343a:	2b00      	cmp	r3, #0
3400343c:	d048      	beq.n	340034d0 <vPortFree+0xa4>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;
3400343e:	2308      	movs	r3, #8
34003440:	425b      	negs	r3, r3
34003442:	68fa      	ldr	r2, [r7, #12]
34003444:	4413      	add	r3, r2
34003446:	60fb      	str	r3, [r7, #12]

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
34003448:	68fb      	ldr	r3, [r7, #12]
3400344a:	60bb      	str	r3, [r7, #8]

        heapVALIDATE_BLOCK_POINTER( pxLink );
3400344c:	68bb      	ldr	r3, [r7, #8]
3400344e:	4a22      	ldr	r2, [pc, #136]	@ (340034d8 <vPortFree+0xac>)
34003450:	4293      	cmp	r3, r2
34003452:	d305      	bcc.n	34003460 <vPortFree+0x34>
34003454:	68bb      	ldr	r3, [r7, #8]
34003456:	4a21      	ldr	r2, [pc, #132]	@ (340034dc <vPortFree+0xb0>)
34003458:	4293      	cmp	r3, r2
3400345a:	d801      	bhi.n	34003460 <vPortFree+0x34>
3400345c:	2301      	movs	r3, #1
3400345e:	e000      	b.n	34003462 <vPortFree+0x36>
34003460:	2300      	movs	r3, #0
34003462:	2b00      	cmp	r3, #0
34003464:	d103      	bne.n	3400346e <vPortFree+0x42>
34003466:	f7fe fb19 	bl	34001a9c <ulSetInterruptMask>
3400346a:	bf00      	nop
3400346c:	e7fd      	b.n	3400346a <vPortFree+0x3e>
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
3400346e:	68bb      	ldr	r3, [r7, #8]
34003470:	685b      	ldr	r3, [r3, #4]
34003472:	2b00      	cmp	r3, #0
34003474:	db03      	blt.n	3400347e <vPortFree+0x52>
34003476:	f7fe fb11 	bl	34001a9c <ulSetInterruptMask>
3400347a:	bf00      	nop
3400347c:	e7fd      	b.n	3400347a <vPortFree+0x4e>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
3400347e:	68bb      	ldr	r3, [r7, #8]
34003480:	681b      	ldr	r3, [r3, #0]
34003482:	2b00      	cmp	r3, #0
34003484:	d003      	beq.n	3400348e <vPortFree+0x62>
34003486:	f7fe fb09 	bl	34001a9c <ulSetInterruptMask>
3400348a:	bf00      	nop
3400348c:	e7fd      	b.n	3400348a <vPortFree+0x5e>

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
3400348e:	68bb      	ldr	r3, [r7, #8]
34003490:	685b      	ldr	r3, [r3, #4]
34003492:	2b00      	cmp	r3, #0
34003494:	da1c      	bge.n	340034d0 <vPortFree+0xa4>
        {
            if( pxLink->pxNextFreeBlock == NULL )
34003496:	68bb      	ldr	r3, [r7, #8]
34003498:	681b      	ldr	r3, [r3, #0]
3400349a:	2b00      	cmp	r3, #0
3400349c:	d118      	bne.n	340034d0 <vPortFree+0xa4>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
3400349e:	68bb      	ldr	r3, [r7, #8]
340034a0:	685b      	ldr	r3, [r3, #4]
340034a2:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
340034a6:	68bb      	ldr	r3, [r7, #8]
340034a8:	605a      	str	r2, [r3, #4]
                        ( void ) memset( puc + xHeapStructSize, 0, pxLink->xBlockSize - xHeapStructSize );
                    }
                }
                #endif

                vTaskSuspendAll();
340034aa:	f7ff f897 	bl	340025dc <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
340034ae:	68bb      	ldr	r3, [r7, #8]
340034b0:	685a      	ldr	r2, [r3, #4]
340034b2:	4b0b      	ldr	r3, [pc, #44]	@ (340034e0 <vPortFree+0xb4>)
340034b4:	681b      	ldr	r3, [r3, #0]
340034b6:	4413      	add	r3, r2
340034b8:	4a09      	ldr	r2, [pc, #36]	@ (340034e0 <vPortFree+0xb4>)
340034ba:	6013      	str	r3, [r2, #0]
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
340034bc:	68b8      	ldr	r0, [r7, #8]
340034be:	f000 f86d 	bl	3400359c <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
340034c2:	4b08      	ldr	r3, [pc, #32]	@ (340034e4 <vPortFree+0xb8>)
340034c4:	681b      	ldr	r3, [r3, #0]
340034c6:	3301      	adds	r3, #1
340034c8:	4a06      	ldr	r2, [pc, #24]	@ (340034e4 <vPortFree+0xb8>)
340034ca:	6013      	str	r3, [r2, #0]
                }
                ( void ) xTaskResumeAll();
340034cc:	f7ff f894 	bl	340025f8 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
340034d0:	bf00      	nop
340034d2:	3710      	adds	r7, #16
340034d4:	46bd      	mov	sp, r7
340034d6:	bd80      	pop	{r7, pc}
340034d8:	34003fb0 	.word	0x34003fb0
340034dc:	34012faf 	.word	0x34012faf
340034e0:	34012fbc 	.word	0x34012fbc
340034e4:	34012fc8 	.word	0x34012fc8

340034e8 <prvHeapInit>:
    return pv;
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
340034e8:	b480      	push	{r7}
340034ea:	b085      	sub	sp, #20
340034ec:	af00      	add	r7, sp, #0
    BlockLink_t * pxFirstFreeBlock;
    portPOINTER_SIZE_TYPE uxStartAddress, uxEndAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
340034ee:	f44f 4370 	mov.w	r3, #61440	@ 0xf000
340034f2:	60bb      	str	r3, [r7, #8]

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
340034f4:	4b24      	ldr	r3, [pc, #144]	@ (34003588 <prvHeapInit+0xa0>)
340034f6:	60fb      	str	r3, [r7, #12]

    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
340034f8:	68fb      	ldr	r3, [r7, #12]
340034fa:	f003 0307 	and.w	r3, r3, #7
340034fe:	2b00      	cmp	r3, #0
34003500:	d00c      	beq.n	3400351c <prvHeapInit+0x34>
    {
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
34003502:	68fb      	ldr	r3, [r7, #12]
34003504:	3307      	adds	r3, #7
34003506:	60fb      	str	r3, [r7, #12]
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
34003508:	68fb      	ldr	r3, [r7, #12]
3400350a:	f023 0307 	bic.w	r3, r3, #7
3400350e:	60fb      	str	r3, [r7, #12]
        xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
34003510:	68ba      	ldr	r2, [r7, #8]
34003512:	68fb      	ldr	r3, [r7, #12]
34003514:	1ad3      	subs	r3, r2, r3
34003516:	4a1c      	ldr	r2, [pc, #112]	@ (34003588 <prvHeapInit+0xa0>)
34003518:	4413      	add	r3, r2
3400351a:	60bb      	str	r3, [r7, #8]
    }
    #endif

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
3400351c:	68fb      	ldr	r3, [r7, #12]
3400351e:	4a1b      	ldr	r2, [pc, #108]	@ (3400358c <prvHeapInit+0xa4>)
34003520:	6013      	str	r3, [r2, #0]
    xStart.xBlockSize = ( size_t ) 0;
34003522:	4b1a      	ldr	r3, [pc, #104]	@ (3400358c <prvHeapInit+0xa4>)
34003524:	2200      	movs	r2, #0
34003526:	605a      	str	r2, [r3, #4]

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
34003528:	68fa      	ldr	r2, [r7, #12]
3400352a:	68bb      	ldr	r3, [r7, #8]
3400352c:	4413      	add	r3, r2
3400352e:	607b      	str	r3, [r7, #4]
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
34003530:	2208      	movs	r2, #8
34003532:	687b      	ldr	r3, [r7, #4]
34003534:	1a9b      	subs	r3, r3, r2
34003536:	607b      	str	r3, [r7, #4]
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
34003538:	687b      	ldr	r3, [r7, #4]
3400353a:	f023 0307 	bic.w	r3, r3, #7
3400353e:	607b      	str	r3, [r7, #4]
    pxEnd = ( BlockLink_t * ) uxEndAddress;
34003540:	687b      	ldr	r3, [r7, #4]
34003542:	4a13      	ldr	r2, [pc, #76]	@ (34003590 <prvHeapInit+0xa8>)
34003544:	6013      	str	r3, [r2, #0]
    pxEnd->xBlockSize = 0;
34003546:	4b12      	ldr	r3, [pc, #72]	@ (34003590 <prvHeapInit+0xa8>)
34003548:	681b      	ldr	r3, [r3, #0]
3400354a:	2200      	movs	r2, #0
3400354c:	605a      	str	r2, [r3, #4]
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
3400354e:	4b10      	ldr	r3, [pc, #64]	@ (34003590 <prvHeapInit+0xa8>)
34003550:	681b      	ldr	r3, [r3, #0]
34003552:	2200      	movs	r2, #0
34003554:	601a      	str	r2, [r3, #0]

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
34003556:	68fb      	ldr	r3, [r7, #12]
34003558:	603b      	str	r3, [r7, #0]
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
3400355a:	683b      	ldr	r3, [r7, #0]
3400355c:	687a      	ldr	r2, [r7, #4]
3400355e:	1ad2      	subs	r2, r2, r3
34003560:	683b      	ldr	r3, [r7, #0]
34003562:	605a      	str	r2, [r3, #4]
    pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
34003564:	4b0a      	ldr	r3, [pc, #40]	@ (34003590 <prvHeapInit+0xa8>)
34003566:	681a      	ldr	r2, [r3, #0]
34003568:	683b      	ldr	r3, [r7, #0]
3400356a:	601a      	str	r2, [r3, #0]

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
3400356c:	683b      	ldr	r3, [r7, #0]
3400356e:	685b      	ldr	r3, [r3, #4]
34003570:	4a08      	ldr	r2, [pc, #32]	@ (34003594 <prvHeapInit+0xac>)
34003572:	6013      	str	r3, [r2, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
34003574:	683b      	ldr	r3, [r7, #0]
34003576:	685b      	ldr	r3, [r3, #4]
34003578:	4a07      	ldr	r2, [pc, #28]	@ (34003598 <prvHeapInit+0xb0>)
3400357a:	6013      	str	r3, [r2, #0]
}
3400357c:	bf00      	nop
3400357e:	3714      	adds	r7, #20
34003580:	46bd      	mov	sp, r7
34003582:	f85d 7b04 	ldr.w	r7, [sp], #4
34003586:	4770      	bx	lr
34003588:	34003fb0 	.word	0x34003fb0
3400358c:	34012fb0 	.word	0x34012fb0
34003590:	34012fb8 	.word	0x34012fb8
34003594:	34012fc0 	.word	0x34012fc0
34003598:	34012fbc 	.word	0x34012fbc

3400359c <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
3400359c:	b580      	push	{r7, lr}
3400359e:	b084      	sub	sp, #16
340035a0:	af00      	add	r7, sp, #0
340035a2:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
340035a4:	4b31      	ldr	r3, [pc, #196]	@ (3400366c <prvInsertBlockIntoFreeList+0xd0>)
340035a6:	60fb      	str	r3, [r7, #12]
340035a8:	e002      	b.n	340035b0 <prvInsertBlockIntoFreeList+0x14>
340035aa:	68fb      	ldr	r3, [r7, #12]
340035ac:	681b      	ldr	r3, [r3, #0]
340035ae:	60fb      	str	r3, [r7, #12]
340035b0:	68fb      	ldr	r3, [r7, #12]
340035b2:	681b      	ldr	r3, [r3, #0]
340035b4:	687a      	ldr	r2, [r7, #4]
340035b6:	429a      	cmp	r2, r3
340035b8:	d8f7      	bhi.n	340035aa <prvInsertBlockIntoFreeList+0xe>
    {
        /* Nothing to do here, just iterate to the right position. */
    }

    if( pxIterator != &xStart )
340035ba:	68fb      	ldr	r3, [r7, #12]
340035bc:	4a2b      	ldr	r2, [pc, #172]	@ (3400366c <prvInsertBlockIntoFreeList+0xd0>)
340035be:	4293      	cmp	r3, r2
340035c0:	d010      	beq.n	340035e4 <prvInsertBlockIntoFreeList+0x48>
    {
        heapVALIDATE_BLOCK_POINTER( pxIterator );
340035c2:	68fb      	ldr	r3, [r7, #12]
340035c4:	4a2a      	ldr	r2, [pc, #168]	@ (34003670 <prvInsertBlockIntoFreeList+0xd4>)
340035c6:	4293      	cmp	r3, r2
340035c8:	d305      	bcc.n	340035d6 <prvInsertBlockIntoFreeList+0x3a>
340035ca:	68fb      	ldr	r3, [r7, #12]
340035cc:	4a29      	ldr	r2, [pc, #164]	@ (34003674 <prvInsertBlockIntoFreeList+0xd8>)
340035ce:	4293      	cmp	r3, r2
340035d0:	d801      	bhi.n	340035d6 <prvInsertBlockIntoFreeList+0x3a>
340035d2:	2301      	movs	r3, #1
340035d4:	e000      	b.n	340035d8 <prvInsertBlockIntoFreeList+0x3c>
340035d6:	2300      	movs	r3, #0
340035d8:	2b00      	cmp	r3, #0
340035da:	d103      	bne.n	340035e4 <prvInsertBlockIntoFreeList+0x48>
340035dc:	f7fe fa5e 	bl	34001a9c <ulSetInterruptMask>
340035e0:	bf00      	nop
340035e2:	e7fd      	b.n	340035e0 <prvInsertBlockIntoFreeList+0x44>
    }

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;
340035e4:	68fb      	ldr	r3, [r7, #12]
340035e6:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
340035e8:	68fb      	ldr	r3, [r7, #12]
340035ea:	685b      	ldr	r3, [r3, #4]
340035ec:	68ba      	ldr	r2, [r7, #8]
340035ee:	4413      	add	r3, r2
340035f0:	687a      	ldr	r2, [r7, #4]
340035f2:	429a      	cmp	r2, r3
340035f4:	d108      	bne.n	34003608 <prvInsertBlockIntoFreeList+0x6c>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
340035f6:	68fb      	ldr	r3, [r7, #12]
340035f8:	685a      	ldr	r2, [r3, #4]
340035fa:	687b      	ldr	r3, [r7, #4]
340035fc:	685b      	ldr	r3, [r3, #4]
340035fe:	441a      	add	r2, r3
34003600:	68fb      	ldr	r3, [r7, #12]
34003602:	605a      	str	r2, [r3, #4]
        pxBlockToInsert = pxIterator;
34003604:	68fb      	ldr	r3, [r7, #12]
34003606:	607b      	str	r3, [r7, #4]
        mtCOVERAGE_TEST_MARKER();
    }

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;
34003608:	687b      	ldr	r3, [r7, #4]
3400360a:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
3400360c:	687b      	ldr	r3, [r7, #4]
3400360e:	685b      	ldr	r3, [r3, #4]
34003610:	68ba      	ldr	r2, [r7, #8]
34003612:	441a      	add	r2, r3
34003614:	68fb      	ldr	r3, [r7, #12]
34003616:	681b      	ldr	r3, [r3, #0]
34003618:	429a      	cmp	r2, r3
3400361a:	d118      	bne.n	3400364e <prvInsertBlockIntoFreeList+0xb2>
    {
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
3400361c:	68fb      	ldr	r3, [r7, #12]
3400361e:	681a      	ldr	r2, [r3, #0]
34003620:	4b15      	ldr	r3, [pc, #84]	@ (34003678 <prvInsertBlockIntoFreeList+0xdc>)
34003622:	681b      	ldr	r3, [r3, #0]
34003624:	429a      	cmp	r2, r3
34003626:	d00d      	beq.n	34003644 <prvInsertBlockIntoFreeList+0xa8>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
34003628:	687b      	ldr	r3, [r7, #4]
3400362a:	685a      	ldr	r2, [r3, #4]
3400362c:	68fb      	ldr	r3, [r7, #12]
3400362e:	681b      	ldr	r3, [r3, #0]
34003630:	685b      	ldr	r3, [r3, #4]
34003632:	441a      	add	r2, r3
34003634:	687b      	ldr	r3, [r7, #4]
34003636:	605a      	str	r2, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
34003638:	68fb      	ldr	r3, [r7, #12]
3400363a:	681b      	ldr	r3, [r3, #0]
3400363c:	681a      	ldr	r2, [r3, #0]
3400363e:	687b      	ldr	r3, [r7, #4]
34003640:	601a      	str	r2, [r3, #0]
34003642:	e008      	b.n	34003656 <prvInsertBlockIntoFreeList+0xba>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
34003644:	4b0c      	ldr	r3, [pc, #48]	@ (34003678 <prvInsertBlockIntoFreeList+0xdc>)
34003646:	681a      	ldr	r2, [r3, #0]
34003648:	687b      	ldr	r3, [r7, #4]
3400364a:	601a      	str	r2, [r3, #0]
3400364c:	e003      	b.n	34003656 <prvInsertBlockIntoFreeList+0xba>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
3400364e:	68fb      	ldr	r3, [r7, #12]
34003650:	681a      	ldr	r2, [r3, #0]
34003652:	687b      	ldr	r3, [r7, #4]
34003654:	601a      	str	r2, [r3, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
34003656:	68fa      	ldr	r2, [r7, #12]
34003658:	687b      	ldr	r3, [r7, #4]
3400365a:	429a      	cmp	r2, r3
3400365c:	d002      	beq.n	34003664 <prvInsertBlockIntoFreeList+0xc8>
    {
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
3400365e:	68fb      	ldr	r3, [r7, #12]
34003660:	687a      	ldr	r2, [r7, #4]
34003662:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
34003664:	bf00      	nop
34003666:	3710      	adds	r7, #16
34003668:	46bd      	mov	sp, r7
3400366a:	bd80      	pop	{r7, pc}
3400366c:	34012fb0 	.word	0x34012fb0
34003670:	34003fb0 	.word	0x34003fb0
34003674:	34012faf 	.word	0x34012faf
34003678:	34012fb8 	.word	0x34012fb8

3400367c <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
3400367c:	b580      	push	{r7, lr}
3400367e:	b084      	sub	sp, #16
34003680:	af02      	add	r7, sp, #8
        BaseType_t xReturn = pdFAIL;
34003682:	2300      	movs	r3, #0
34003684:	607b      	str	r3, [r7, #4]

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
34003686:	f000 fa51 	bl	34003b2c <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
3400368a:	4b0e      	ldr	r3, [pc, #56]	@ (340036c4 <xTimerCreateTimerTask+0x48>)
3400368c:	681b      	ldr	r3, [r3, #0]
3400368e:	2b00      	cmp	r3, #0
34003690:	d00b      	beq.n	340036aa <xTimerCreateTimerTask+0x2e>
                        xReturn = pdPASS;
                    }
                }
                #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
34003692:	4b0d      	ldr	r3, [pc, #52]	@ (340036c8 <xTimerCreateTimerTask+0x4c>)
34003694:	9301      	str	r3, [sp, #4]
34003696:	2302      	movs	r3, #2
34003698:	9300      	str	r3, [sp, #0]
3400369a:	2300      	movs	r3, #0
3400369c:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340036a0:	490a      	ldr	r1, [pc, #40]	@ (340036cc <xTimerCreateTimerTask+0x50>)
340036a2:	480b      	ldr	r0, [pc, #44]	@ (340036d0 <xTimerCreateTimerTask+0x54>)
340036a4:	f7fe fdbe 	bl	34002224 <xTaskCreate>
340036a8:	6078      	str	r0, [r7, #4]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
340036aa:	687b      	ldr	r3, [r7, #4]
340036ac:	2b00      	cmp	r3, #0
340036ae:	d103      	bne.n	340036b8 <xTimerCreateTimerTask+0x3c>
340036b0:	f7fe f9f4 	bl	34001a9c <ulSetInterruptMask>
340036b4:	bf00      	nop
340036b6:	e7fd      	b.n	340036b4 <xTimerCreateTimerTask+0x38>

        traceRETURN_xTimerCreateTimerTask( xReturn );

        return xReturn;
340036b8:	687b      	ldr	r3, [r7, #4]
    }
340036ba:	4618      	mov	r0, r3
340036bc:	3708      	adds	r7, #8
340036be:	46bd      	mov	sp, r7
340036c0:	bd80      	pop	{r7, pc}
340036c2:	bf00      	nop
340036c4:	34012ffc 	.word	0x34012ffc
340036c8:	34013000 	.word	0x34013000
340036cc:	34003c1c 	.word	0x34003c1c
340036d0:	34003779 	.word	0x34003779

340036d4 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
340036d4:	b580      	push	{r7, lr}
340036d6:	b084      	sub	sp, #16
340036d8:	af00      	add	r7, sp, #0
340036da:	60f8      	str	r0, [r7, #12]
340036dc:	60b9      	str	r1, [r7, #8]
340036de:	607a      	str	r2, [r7, #4]
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
340036e0:	e008      	b.n	340036f4 <prvReloadTimer+0x20>
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
340036e2:	68fb      	ldr	r3, [r7, #12]
340036e4:	699b      	ldr	r3, [r3, #24]
340036e6:	68ba      	ldr	r2, [r7, #8]
340036e8:	4413      	add	r3, r2
340036ea:	60bb      	str	r3, [r7, #8]

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
340036ec:	68fb      	ldr	r3, [r7, #12]
340036ee:	6a1b      	ldr	r3, [r3, #32]
340036f0:	68f8      	ldr	r0, [r7, #12]
340036f2:	4798      	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
340036f4:	68fb      	ldr	r3, [r7, #12]
340036f6:	699a      	ldr	r2, [r3, #24]
340036f8:	68bb      	ldr	r3, [r7, #8]
340036fa:	18d1      	adds	r1, r2, r3
340036fc:	68bb      	ldr	r3, [r7, #8]
340036fe:	687a      	ldr	r2, [r7, #4]
34003700:	68f8      	ldr	r0, [r7, #12]
34003702:	f000 f8d7 	bl	340038b4 <prvInsertTimerInActiveList>
34003706:	4603      	mov	r3, r0
34003708:	2b00      	cmp	r3, #0
3400370a:	d1ea      	bne.n	340036e2 <prvReloadTimer+0xe>
        }
    }
3400370c:	bf00      	nop
3400370e:	bf00      	nop
34003710:	3710      	adds	r7, #16
34003712:	46bd      	mov	sp, r7
34003714:	bd80      	pop	{r7, pc}
	...

34003718 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
34003718:	b580      	push	{r7, lr}
3400371a:	b084      	sub	sp, #16
3400371c:	af00      	add	r7, sp, #0
3400371e:	6078      	str	r0, [r7, #4]
34003720:	6039      	str	r1, [r7, #0]
        /* MISRA Ref 11.5.3 [Void pointer assignment] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
        /* coverity[misra_c_2012_rule_11_5_violation] */
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
34003722:	4b14      	ldr	r3, [pc, #80]	@ (34003774 <prvProcessExpiredTimer+0x5c>)
34003724:	681b      	ldr	r3, [r3, #0]
34003726:	68db      	ldr	r3, [r3, #12]
34003728:	68db      	ldr	r3, [r3, #12]
3400372a:	60fb      	str	r3, [r7, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
3400372c:	68fb      	ldr	r3, [r7, #12]
3400372e:	3304      	adds	r3, #4
34003730:	4618      	mov	r0, r3
34003732:	f7fd ff79 	bl	34001628 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
34003736:	68fb      	ldr	r3, [r7, #12]
34003738:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
3400373c:	f003 0304 	and.w	r3, r3, #4
34003740:	2b00      	cmp	r3, #0
34003742:	d005      	beq.n	34003750 <prvProcessExpiredTimer+0x38>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
34003744:	683a      	ldr	r2, [r7, #0]
34003746:	6879      	ldr	r1, [r7, #4]
34003748:	68f8      	ldr	r0, [r7, #12]
3400374a:	f7ff ffc3 	bl	340036d4 <prvReloadTimer>
3400374e:	e008      	b.n	34003762 <prvProcessExpiredTimer+0x4a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
34003750:	68fb      	ldr	r3, [r7, #12]
34003752:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003756:	f023 0301 	bic.w	r3, r3, #1
3400375a:	b2da      	uxtb	r2, r3
3400375c:	68fb      	ldr	r3, [r7, #12]
3400375e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
34003762:	68fb      	ldr	r3, [r7, #12]
34003764:	6a1b      	ldr	r3, [r3, #32]
34003766:	68f8      	ldr	r0, [r7, #12]
34003768:	4798      	blx	r3
    }
3400376a:	bf00      	nop
3400376c:	3710      	adds	r7, #16
3400376e:	46bd      	mov	sp, r7
34003770:	bd80      	pop	{r7, pc}
34003772:	bf00      	nop
34003774:	34012ff4 	.word	0x34012ff4

34003778 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
34003778:	b580      	push	{r7, lr}
3400377a:	b084      	sub	sp, #16
3400377c:	af00      	add	r7, sp, #0
3400377e:	6078      	str	r0, [r7, #4]

        for( ; configCONTROL_INFINITE_LOOP(); )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
34003780:	f107 0308 	add.w	r3, r7, #8
34003784:	4618      	mov	r0, r3
34003786:	f000 f851 	bl	3400382c <prvGetNextExpireTime>
3400378a:	60f8      	str	r0, [r7, #12]

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
3400378c:	68bb      	ldr	r3, [r7, #8]
3400378e:	4619      	mov	r1, r3
34003790:	68f8      	ldr	r0, [r7, #12]
34003792:	f000 f805 	bl	340037a0 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
34003796:	f000 f8cf 	bl	34003938 <prvProcessReceivedCommands>
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
3400379a:	bf00      	nop
3400379c:	e7f0      	b.n	34003780 <prvTimerTask+0x8>
	...

340037a0 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
340037a0:	b580      	push	{r7, lr}
340037a2:	b084      	sub	sp, #16
340037a4:	af00      	add	r7, sp, #0
340037a6:	6078      	str	r0, [r7, #4]
340037a8:	6039      	str	r1, [r7, #0]
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
340037aa:	f7fe ff17 	bl	340025dc <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
340037ae:	f107 0308 	add.w	r3, r7, #8
340037b2:	4618      	mov	r0, r3
340037b4:	f000 f85e 	bl	34003874 <prvSampleTimeNow>
340037b8:	60f8      	str	r0, [r7, #12]

            if( xTimerListsWereSwitched == pdFALSE )
340037ba:	68bb      	ldr	r3, [r7, #8]
340037bc:	2b00      	cmp	r3, #0
340037be:	d12a      	bne.n	34003816 <prvProcessTimerOrBlockTask+0x76>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
340037c0:	683b      	ldr	r3, [r7, #0]
340037c2:	2b00      	cmp	r3, #0
340037c4:	d10a      	bne.n	340037dc <prvProcessTimerOrBlockTask+0x3c>
340037c6:	687a      	ldr	r2, [r7, #4]
340037c8:	68fb      	ldr	r3, [r7, #12]
340037ca:	429a      	cmp	r2, r3
340037cc:	d806      	bhi.n	340037dc <prvProcessTimerOrBlockTask+0x3c>
                {
                    ( void ) xTaskResumeAll();
340037ce:	f7fe ff13 	bl	340025f8 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
340037d2:	68f9      	ldr	r1, [r7, #12]
340037d4:	6878      	ldr	r0, [r7, #4]
340037d6:	f7ff ff9f 	bl	34003718 <prvProcessExpiredTimer>
            else
            {
                ( void ) xTaskResumeAll();
            }
        }
    }
340037da:	e01e      	b.n	3400381a <prvProcessTimerOrBlockTask+0x7a>
                    if( xListWasEmpty != pdFALSE )
340037dc:	683b      	ldr	r3, [r7, #0]
340037de:	2b00      	cmp	r3, #0
340037e0:	d008      	beq.n	340037f4 <prvProcessTimerOrBlockTask+0x54>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
340037e2:	4b10      	ldr	r3, [pc, #64]	@ (34003824 <prvProcessTimerOrBlockTask+0x84>)
340037e4:	681b      	ldr	r3, [r3, #0]
340037e6:	681b      	ldr	r3, [r3, #0]
340037e8:	2b00      	cmp	r3, #0
340037ea:	d101      	bne.n	340037f0 <prvProcessTimerOrBlockTask+0x50>
340037ec:	2301      	movs	r3, #1
340037ee:	e000      	b.n	340037f2 <prvProcessTimerOrBlockTask+0x52>
340037f0:	2300      	movs	r3, #0
340037f2:	603b      	str	r3, [r7, #0]
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
340037f4:	4b0c      	ldr	r3, [pc, #48]	@ (34003828 <prvProcessTimerOrBlockTask+0x88>)
340037f6:	6818      	ldr	r0, [r3, #0]
340037f8:	687a      	ldr	r2, [r7, #4]
340037fa:	68fb      	ldr	r3, [r7, #12]
340037fc:	1ad3      	subs	r3, r2, r3
340037fe:	683a      	ldr	r2, [r7, #0]
34003800:	4619      	mov	r1, r3
34003802:	f7fe fc44 	bl	3400208e <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
34003806:	f7fe fef7 	bl	340025f8 <xTaskResumeAll>
3400380a:	4603      	mov	r3, r0
3400380c:	2b00      	cmp	r3, #0
3400380e:	d104      	bne.n	3400381a <prvProcessTimerOrBlockTask+0x7a>
                        taskYIELD_WITHIN_API();
34003810:	f7fd ff8c 	bl	3400172c <vPortYield>
    }
34003814:	e001      	b.n	3400381a <prvProcessTimerOrBlockTask+0x7a>
                ( void ) xTaskResumeAll();
34003816:	f7fe feef 	bl	340025f8 <xTaskResumeAll>
    }
3400381a:	bf00      	nop
3400381c:	3710      	adds	r7, #16
3400381e:	46bd      	mov	sp, r7
34003820:	bd80      	pop	{r7, pc}
34003822:	bf00      	nop
34003824:	34012ff8 	.word	0x34012ff8
34003828:	34012ffc 	.word	0x34012ffc

3400382c <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
3400382c:	b480      	push	{r7}
3400382e:	b085      	sub	sp, #20
34003830:	af00      	add	r7, sp, #0
34003832:	6078      	str	r0, [r7, #4]
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
34003834:	4b0e      	ldr	r3, [pc, #56]	@ (34003870 <prvGetNextExpireTime+0x44>)
34003836:	681b      	ldr	r3, [r3, #0]
34003838:	681b      	ldr	r3, [r3, #0]
3400383a:	2b00      	cmp	r3, #0
3400383c:	d101      	bne.n	34003842 <prvGetNextExpireTime+0x16>
3400383e:	2201      	movs	r2, #1
34003840:	e000      	b.n	34003844 <prvGetNextExpireTime+0x18>
34003842:	2200      	movs	r2, #0
34003844:	687b      	ldr	r3, [r7, #4]
34003846:	601a      	str	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
34003848:	687b      	ldr	r3, [r7, #4]
3400384a:	681b      	ldr	r3, [r3, #0]
3400384c:	2b00      	cmp	r3, #0
3400384e:	d105      	bne.n	3400385c <prvGetNextExpireTime+0x30>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
34003850:	4b07      	ldr	r3, [pc, #28]	@ (34003870 <prvGetNextExpireTime+0x44>)
34003852:	681b      	ldr	r3, [r3, #0]
34003854:	68db      	ldr	r3, [r3, #12]
34003856:	681b      	ldr	r3, [r3, #0]
34003858:	60fb      	str	r3, [r7, #12]
3400385a:	e001      	b.n	34003860 <prvGetNextExpireTime+0x34>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
3400385c:	2300      	movs	r3, #0
3400385e:	60fb      	str	r3, [r7, #12]
        }

        return xNextExpireTime;
34003860:	68fb      	ldr	r3, [r7, #12]
    }
34003862:	4618      	mov	r0, r3
34003864:	3714      	adds	r7, #20
34003866:	46bd      	mov	sp, r7
34003868:	f85d 7b04 	ldr.w	r7, [sp], #4
3400386c:	4770      	bx	lr
3400386e:	bf00      	nop
34003870:	34012ff4 	.word	0x34012ff4

34003874 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
34003874:	b580      	push	{r7, lr}
34003876:	b084      	sub	sp, #16
34003878:	af00      	add	r7, sp, #0
3400387a:	6078      	str	r0, [r7, #4]
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U;

        xTimeNow = xTaskGetTickCount();
3400387c:	f7fe ffb4 	bl	340027e8 <xTaskGetTickCount>
34003880:	60f8      	str	r0, [r7, #12]

        if( xTimeNow < xLastTime )
34003882:	4b0b      	ldr	r3, [pc, #44]	@ (340038b0 <prvSampleTimeNow+0x3c>)
34003884:	681b      	ldr	r3, [r3, #0]
34003886:	68fa      	ldr	r2, [r7, #12]
34003888:	429a      	cmp	r2, r3
3400388a:	d205      	bcs.n	34003898 <prvSampleTimeNow+0x24>
        {
            prvSwitchTimerLists();
3400388c:	f000 f928 	bl	34003ae0 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
34003890:	687b      	ldr	r3, [r7, #4]
34003892:	2201      	movs	r2, #1
34003894:	601a      	str	r2, [r3, #0]
34003896:	e002      	b.n	3400389e <prvSampleTimeNow+0x2a>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
34003898:	687b      	ldr	r3, [r7, #4]
3400389a:	2200      	movs	r2, #0
3400389c:	601a      	str	r2, [r3, #0]
        }

        xLastTime = xTimeNow;
3400389e:	4a04      	ldr	r2, [pc, #16]	@ (340038b0 <prvSampleTimeNow+0x3c>)
340038a0:	68fb      	ldr	r3, [r7, #12]
340038a2:	6013      	str	r3, [r2, #0]

        return xTimeNow;
340038a4:	68fb      	ldr	r3, [r7, #12]
    }
340038a6:	4618      	mov	r0, r3
340038a8:	3710      	adds	r7, #16
340038aa:	46bd      	mov	sp, r7
340038ac:	bd80      	pop	{r7, pc}
340038ae:	bf00      	nop
340038b0:	34013004 	.word	0x34013004

340038b4 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
340038b4:	b580      	push	{r7, lr}
340038b6:	b086      	sub	sp, #24
340038b8:	af00      	add	r7, sp, #0
340038ba:	60f8      	str	r0, [r7, #12]
340038bc:	60b9      	str	r1, [r7, #8]
340038be:	607a      	str	r2, [r7, #4]
340038c0:	603b      	str	r3, [r7, #0]
        BaseType_t xProcessTimerNow = pdFALSE;
340038c2:	2300      	movs	r3, #0
340038c4:	617b      	str	r3, [r7, #20]

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
340038c6:	68fb      	ldr	r3, [r7, #12]
340038c8:	68ba      	ldr	r2, [r7, #8]
340038ca:	605a      	str	r2, [r3, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
340038cc:	68fb      	ldr	r3, [r7, #12]
340038ce:	68fa      	ldr	r2, [r7, #12]
340038d0:	611a      	str	r2, [r3, #16]

        if( xNextExpiryTime <= xTimeNow )
340038d2:	68ba      	ldr	r2, [r7, #8]
340038d4:	687b      	ldr	r3, [r7, #4]
340038d6:	429a      	cmp	r2, r3
340038d8:	d812      	bhi.n	34003900 <prvInsertTimerInActiveList+0x4c>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
340038da:	687a      	ldr	r2, [r7, #4]
340038dc:	683b      	ldr	r3, [r7, #0]
340038de:	1ad2      	subs	r2, r2, r3
340038e0:	68fb      	ldr	r3, [r7, #12]
340038e2:	699b      	ldr	r3, [r3, #24]
340038e4:	429a      	cmp	r2, r3
340038e6:	d302      	bcc.n	340038ee <prvInsertTimerInActiveList+0x3a>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
340038e8:	2301      	movs	r3, #1
340038ea:	617b      	str	r3, [r7, #20]
340038ec:	e01b      	b.n	34003926 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
340038ee:	4b10      	ldr	r3, [pc, #64]	@ (34003930 <prvInsertTimerInActiveList+0x7c>)
340038f0:	681a      	ldr	r2, [r3, #0]
340038f2:	68fb      	ldr	r3, [r7, #12]
340038f4:	3304      	adds	r3, #4
340038f6:	4619      	mov	r1, r3
340038f8:	4610      	mov	r0, r2
340038fa:	f7fd fe5c 	bl	340015b6 <vListInsert>
340038fe:	e012      	b.n	34003926 <prvInsertTimerInActiveList+0x72>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
34003900:	687a      	ldr	r2, [r7, #4]
34003902:	683b      	ldr	r3, [r7, #0]
34003904:	429a      	cmp	r2, r3
34003906:	d206      	bcs.n	34003916 <prvInsertTimerInActiveList+0x62>
34003908:	68ba      	ldr	r2, [r7, #8]
3400390a:	683b      	ldr	r3, [r7, #0]
3400390c:	429a      	cmp	r2, r3
3400390e:	d302      	bcc.n	34003916 <prvInsertTimerInActiveList+0x62>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
34003910:	2301      	movs	r3, #1
34003912:	617b      	str	r3, [r7, #20]
34003914:	e007      	b.n	34003926 <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
34003916:	4b07      	ldr	r3, [pc, #28]	@ (34003934 <prvInsertTimerInActiveList+0x80>)
34003918:	681a      	ldr	r2, [r3, #0]
3400391a:	68fb      	ldr	r3, [r7, #12]
3400391c:	3304      	adds	r3, #4
3400391e:	4619      	mov	r1, r3
34003920:	4610      	mov	r0, r2
34003922:	f7fd fe48 	bl	340015b6 <vListInsert>
            }
        }

        return xProcessTimerNow;
34003926:	697b      	ldr	r3, [r7, #20]
    }
34003928:	4618      	mov	r0, r3
3400392a:	3718      	adds	r7, #24
3400392c:	46bd      	mov	sp, r7
3400392e:	bd80      	pop	{r7, pc}
34003930:	34012ff8 	.word	0x34012ff8
34003934:	34012ff4 	.word	0x34012ff4

34003938 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
34003938:	b580      	push	{r7, lr}
3400393a:	b088      	sub	sp, #32
3400393c:	af00      	add	r7, sp, #0
        DaemonTaskMessage_t xMessage = { 0 };
3400393e:	1d3b      	adds	r3, r7, #4
34003940:	2200      	movs	r2, #0
34003942:	601a      	str	r2, [r3, #0]
34003944:	605a      	str	r2, [r3, #4]
34003946:	609a      	str	r2, [r3, #8]
34003948:	60da      	str	r2, [r3, #12]
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
3400394a:	e0b7      	b.n	34003abc <prvProcessReceivedCommands+0x184>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
            {
                /* Negative commands are pended function calls rather than timer
                 * commands. */
                if( xMessage.xMessageID < ( BaseType_t ) 0 )
3400394c:	687b      	ldr	r3, [r7, #4]
3400394e:	2b00      	cmp	r3, #0
34003950:	da11      	bge.n	34003976 <prvProcessReceivedCommands+0x3e>
                {
                    const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
34003952:	1d3b      	adds	r3, r7, #4
34003954:	3304      	adds	r3, #4
34003956:	61fb      	str	r3, [r7, #28]

                    /* The timer uses the xCallbackParameters member to request a
                     * callback be executed.  Check the callback is not NULL. */
                    configASSERT( pxCallback );
34003958:	69fb      	ldr	r3, [r7, #28]
3400395a:	2b00      	cmp	r3, #0
3400395c:	d103      	bne.n	34003966 <prvProcessReceivedCommands+0x2e>
3400395e:	f7fe f89d 	bl	34001a9c <ulSetInterruptMask>
34003962:	bf00      	nop
34003964:	e7fd      	b.n	34003962 <prvProcessReceivedCommands+0x2a>

                    /* Call the function. */
                    pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
34003966:	69fb      	ldr	r3, [r7, #28]
34003968:	681b      	ldr	r3, [r3, #0]
3400396a:	69fa      	ldr	r2, [r7, #28]
3400396c:	6850      	ldr	r0, [r2, #4]
3400396e:	69fa      	ldr	r2, [r7, #28]
34003970:	6892      	ldr	r2, [r2, #8]
34003972:	4611      	mov	r1, r2
34003974:	4798      	blx	r3
            }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
34003976:	687b      	ldr	r3, [r7, #4]
34003978:	2b00      	cmp	r3, #0
3400397a:	f2c0 809f 	blt.w	34003abc <prvProcessReceivedCommands+0x184>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
3400397e:	68fb      	ldr	r3, [r7, #12]
34003980:	61bb      	str	r3, [r7, #24]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
34003982:	69bb      	ldr	r3, [r7, #24]
34003984:	695b      	ldr	r3, [r3, #20]
34003986:	2b00      	cmp	r3, #0
34003988:	d004      	beq.n	34003994 <prvProcessReceivedCommands+0x5c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
3400398a:	69bb      	ldr	r3, [r7, #24]
3400398c:	3304      	adds	r3, #4
3400398e:	4618      	mov	r0, r3
34003990:	f7fd fe4a 	bl	34001628 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
34003994:	463b      	mov	r3, r7
34003996:	4618      	mov	r0, r3
34003998:	f7ff ff6c 	bl	34003874 <prvSampleTimeNow>
3400399c:	6178      	str	r0, [r7, #20]

                switch( xMessage.xMessageID )
3400399e:	687b      	ldr	r3, [r7, #4]
340039a0:	3b01      	subs	r3, #1
340039a2:	2b08      	cmp	r3, #8
340039a4:	f200 8087 	bhi.w	34003ab6 <prvProcessReceivedCommands+0x17e>
340039a8:	a201      	add	r2, pc, #4	@ (adr r2, 340039b0 <prvProcessReceivedCommands+0x78>)
340039aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340039ae:	bf00      	nop
340039b0:	340039d5 	.word	0x340039d5
340039b4:	340039d5 	.word	0x340039d5
340039b8:	34003a3d 	.word	0x34003a3d
340039bc:	34003a51 	.word	0x34003a51
340039c0:	34003a8d 	.word	0x34003a8d
340039c4:	340039d5 	.word	0x340039d5
340039c8:	340039d5 	.word	0x340039d5
340039cc:	34003a3d 	.word	0x34003a3d
340039d0:	34003a51 	.word	0x34003a51
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
340039d4:	69bb      	ldr	r3, [r7, #24]
340039d6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
340039da:	f043 0301 	orr.w	r3, r3, #1
340039de:	b2da      	uxtb	r2, r3
340039e0:	69bb      	ldr	r3, [r7, #24]
340039e2:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
340039e6:	68ba      	ldr	r2, [r7, #8]
340039e8:	69bb      	ldr	r3, [r7, #24]
340039ea:	699b      	ldr	r3, [r3, #24]
340039ec:	18d1      	adds	r1, r2, r3
340039ee:	68bb      	ldr	r3, [r7, #8]
340039f0:	697a      	ldr	r2, [r7, #20]
340039f2:	69b8      	ldr	r0, [r7, #24]
340039f4:	f7ff ff5e 	bl	340038b4 <prvInsertTimerInActiveList>
340039f8:	4603      	mov	r3, r0
340039fa:	2b00      	cmp	r3, #0
340039fc:	d05d      	beq.n	34003aba <prvProcessReceivedCommands+0x182>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
340039fe:	69bb      	ldr	r3, [r7, #24]
34003a00:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003a04:	f003 0304 	and.w	r3, r3, #4
34003a08:	2b00      	cmp	r3, #0
34003a0a:	d009      	beq.n	34003a20 <prvProcessReceivedCommands+0xe8>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
34003a0c:	68ba      	ldr	r2, [r7, #8]
34003a0e:	69bb      	ldr	r3, [r7, #24]
34003a10:	699b      	ldr	r3, [r3, #24]
34003a12:	4413      	add	r3, r2
34003a14:	697a      	ldr	r2, [r7, #20]
34003a16:	4619      	mov	r1, r3
34003a18:	69b8      	ldr	r0, [r7, #24]
34003a1a:	f7ff fe5b 	bl	340036d4 <prvReloadTimer>
34003a1e:	e008      	b.n	34003a32 <prvProcessReceivedCommands+0xfa>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
34003a20:	69bb      	ldr	r3, [r7, #24]
34003a22:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003a26:	f023 0301 	bic.w	r3, r3, #1
34003a2a:	b2da      	uxtb	r2, r3
34003a2c:	69bb      	ldr	r3, [r7, #24]
34003a2e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
34003a32:	69bb      	ldr	r3, [r7, #24]
34003a34:	6a1b      	ldr	r3, [r3, #32]
34003a36:	69b8      	ldr	r0, [r7, #24]
34003a38:	4798      	blx	r3
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        break;
34003a3a:	e03e      	b.n	34003aba <prvProcessReceivedCommands+0x182>

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
34003a3c:	69bb      	ldr	r3, [r7, #24]
34003a3e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003a42:	f023 0301 	bic.w	r3, r3, #1
34003a46:	b2da      	uxtb	r2, r3
34003a48:	69bb      	ldr	r3, [r7, #24]
34003a4a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
                        break;
34003a4e:	e035      	b.n	34003abc <prvProcessReceivedCommands+0x184>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
34003a50:	69bb      	ldr	r3, [r7, #24]
34003a52:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003a56:	f043 0301 	orr.w	r3, r3, #1
34003a5a:	b2da      	uxtb	r2, r3
34003a5c:	69bb      	ldr	r3, [r7, #24]
34003a5e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
34003a62:	68ba      	ldr	r2, [r7, #8]
34003a64:	69bb      	ldr	r3, [r7, #24]
34003a66:	619a      	str	r2, [r3, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
34003a68:	69bb      	ldr	r3, [r7, #24]
34003a6a:	699b      	ldr	r3, [r3, #24]
34003a6c:	2b00      	cmp	r3, #0
34003a6e:	d103      	bne.n	34003a78 <prvProcessReceivedCommands+0x140>
34003a70:	f7fe f814 	bl	34001a9c <ulSetInterruptMask>
34003a74:	bf00      	nop
34003a76:	e7fd      	b.n	34003a74 <prvProcessReceivedCommands+0x13c>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
34003a78:	69bb      	ldr	r3, [r7, #24]
34003a7a:	699a      	ldr	r2, [r3, #24]
34003a7c:	697b      	ldr	r3, [r7, #20]
34003a7e:	18d1      	adds	r1, r2, r3
34003a80:	697b      	ldr	r3, [r7, #20]
34003a82:	697a      	ldr	r2, [r7, #20]
34003a84:	69b8      	ldr	r0, [r7, #24]
34003a86:	f7ff ff15 	bl	340038b4 <prvInsertTimerInActiveList>
                        break;
34003a8a:	e017      	b.n	34003abc <prvProcessReceivedCommands+0x184>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                        {
                            /* The timer has already been removed from the active list,
                             * just free up the memory if the memory was dynamically
                             * allocated. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
34003a8c:	69bb      	ldr	r3, [r7, #24]
34003a8e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003a92:	f003 0302 	and.w	r3, r3, #2
34003a96:	2b00      	cmp	r3, #0
34003a98:	d103      	bne.n	34003aa2 <prvProcessReceivedCommands+0x16a>
                            {
                                vPortFree( pxTimer );
34003a9a:	69b8      	ldr	r0, [r7, #24]
34003a9c:	f7ff fcc6 	bl	3400342c <vPortFree>
                             * no need to free the memory - just mark the timer as
                             * "not active". */
                            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
                        }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
34003aa0:	e00c      	b.n	34003abc <prvProcessReceivedCommands+0x184>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
34003aa2:	69bb      	ldr	r3, [r7, #24]
34003aa4:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
34003aa8:	f023 0301 	bic.w	r3, r3, #1
34003aac:	b2da      	uxtb	r2, r3
34003aae:	69bb      	ldr	r3, [r7, #24]
34003ab0:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
                        break;
34003ab4:	e002      	b.n	34003abc <prvProcessReceivedCommands+0x184>

                    default:
                        /* Don't expect to get here. */
                        break;
34003ab6:	bf00      	nop
34003ab8:	e000      	b.n	34003abc <prvProcessReceivedCommands+0x184>
                        break;
34003aba:	bf00      	nop
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
34003abc:	4b07      	ldr	r3, [pc, #28]	@ (34003adc <prvProcessReceivedCommands+0x1a4>)
34003abe:	681b      	ldr	r3, [r3, #0]
34003ac0:	1d39      	adds	r1, r7, #4
34003ac2:	2200      	movs	r2, #0
34003ac4:	4618      	mov	r0, r3
34003ac6:	f7fe f921 	bl	34001d0c <xQueueReceive>
34003aca:	4603      	mov	r3, r0
34003acc:	2b00      	cmp	r3, #0
34003ace:	f47f af3d 	bne.w	3400394c <prvProcessReceivedCommands+0x14>
                }
            }
        }
    }
34003ad2:	bf00      	nop
34003ad4:	bf00      	nop
34003ad6:	3720      	adds	r7, #32
34003ad8:	46bd      	mov	sp, r7
34003ada:	bd80      	pop	{r7, pc}
34003adc:	34012ffc 	.word	0x34012ffc

34003ae0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
34003ae0:	b580      	push	{r7, lr}
34003ae2:	b082      	sub	sp, #8
34003ae4:	af00      	add	r7, sp, #0

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
34003ae6:	e009      	b.n	34003afc <prvSwitchTimerLists+0x1c>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
34003ae8:	4b0e      	ldr	r3, [pc, #56]	@ (34003b24 <prvSwitchTimerLists+0x44>)
34003aea:	681b      	ldr	r3, [r3, #0]
34003aec:	68db      	ldr	r3, [r3, #12]
34003aee:	681b      	ldr	r3, [r3, #0]
34003af0:	603b      	str	r3, [r7, #0]

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
34003af2:	f04f 31ff 	mov.w	r1, #4294967295
34003af6:	6838      	ldr	r0, [r7, #0]
34003af8:	f7ff fe0e 	bl	34003718 <prvProcessExpiredTimer>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
34003afc:	4b09      	ldr	r3, [pc, #36]	@ (34003b24 <prvSwitchTimerLists+0x44>)
34003afe:	681b      	ldr	r3, [r3, #0]
34003b00:	681b      	ldr	r3, [r3, #0]
34003b02:	2b00      	cmp	r3, #0
34003b04:	d1f0      	bne.n	34003ae8 <prvSwitchTimerLists+0x8>
        }

        pxTemp = pxCurrentTimerList;
34003b06:	4b07      	ldr	r3, [pc, #28]	@ (34003b24 <prvSwitchTimerLists+0x44>)
34003b08:	681b      	ldr	r3, [r3, #0]
34003b0a:	607b      	str	r3, [r7, #4]
        pxCurrentTimerList = pxOverflowTimerList;
34003b0c:	4b06      	ldr	r3, [pc, #24]	@ (34003b28 <prvSwitchTimerLists+0x48>)
34003b0e:	681b      	ldr	r3, [r3, #0]
34003b10:	4a04      	ldr	r2, [pc, #16]	@ (34003b24 <prvSwitchTimerLists+0x44>)
34003b12:	6013      	str	r3, [r2, #0]
        pxOverflowTimerList = pxTemp;
34003b14:	4a04      	ldr	r2, [pc, #16]	@ (34003b28 <prvSwitchTimerLists+0x48>)
34003b16:	687b      	ldr	r3, [r7, #4]
34003b18:	6013      	str	r3, [r2, #0]
    }
34003b1a:	bf00      	nop
34003b1c:	3708      	adds	r7, #8
34003b1e:	46bd      	mov	sp, r7
34003b20:	bd80      	pop	{r7, pc}
34003b22:	bf00      	nop
34003b24:	34012ff4 	.word	0x34012ff4
34003b28:	34012ff8 	.word	0x34012ff8

34003b2c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
34003b2c:	b580      	push	{r7, lr}
34003b2e:	af00      	add	r7, sp, #0
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
34003b30:	f7fd fe0e 	bl	34001750 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
34003b34:	4b0d      	ldr	r3, [pc, #52]	@ (34003b6c <prvCheckForValidListAndQueue+0x40>)
34003b36:	681b      	ldr	r3, [r3, #0]
34003b38:	2b00      	cmp	r3, #0
34003b3a:	d113      	bne.n	34003b64 <prvCheckForValidListAndQueue+0x38>
            {
                vListInitialise( &xActiveTimerList1 );
34003b3c:	480c      	ldr	r0, [pc, #48]	@ (34003b70 <prvCheckForValidListAndQueue+0x44>)
34003b3e:	f7fd fd0d 	bl	3400155c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
34003b42:	480c      	ldr	r0, [pc, #48]	@ (34003b74 <prvCheckForValidListAndQueue+0x48>)
34003b44:	f7fd fd0a 	bl	3400155c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
34003b48:	4b0b      	ldr	r3, [pc, #44]	@ (34003b78 <prvCheckForValidListAndQueue+0x4c>)
34003b4a:	4a09      	ldr	r2, [pc, #36]	@ (34003b70 <prvCheckForValidListAndQueue+0x44>)
34003b4c:	601a      	str	r2, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
34003b4e:	4b0b      	ldr	r3, [pc, #44]	@ (34003b7c <prvCheckForValidListAndQueue+0x50>)
34003b50:	4a08      	ldr	r2, [pc, #32]	@ (34003b74 <prvCheckForValidListAndQueue+0x48>)
34003b52:	601a      	str	r2, [r3, #0]

                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                }
                #else
                {
                    xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ) );
34003b54:	2200      	movs	r2, #0
34003b56:	2110      	movs	r1, #16
34003b58:	2005      	movs	r0, #5
34003b5a:	f7fe f86a 	bl	34001c32 <xQueueGenericCreate>
34003b5e:	4603      	mov	r3, r0
34003b60:	4a02      	ldr	r2, [pc, #8]	@ (34003b6c <prvCheckForValidListAndQueue+0x40>)
34003b62:	6013      	str	r3, [r2, #0]
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
34003b64:	f7fd fe06 	bl	34001774 <vPortExitCritical>
    }
34003b68:	bf00      	nop
34003b6a:	bd80      	pop	{r7, pc}
34003b6c:	34012ffc 	.word	0x34012ffc
34003b70:	34012fcc 	.word	0x34012fcc
34003b74:	34012fe0 	.word	0x34012fe0
34003b78:	34012ff4 	.word	0x34012ff4
34003b7c:	34012ff8 	.word	0x34012ff8

34003b80 <memset>:
34003b80:	4402      	add	r2, r0
34003b82:	4603      	mov	r3, r0
34003b84:	4293      	cmp	r3, r2
34003b86:	d100      	bne.n	34003b8a <memset+0xa>
34003b88:	4770      	bx	lr
34003b8a:	f803 1b01 	strb.w	r1, [r3], #1
34003b8e:	e7f9      	b.n	34003b84 <memset+0x4>

34003b90 <__libc_init_array>:
34003b90:	b570      	push	{r4, r5, r6, lr}
34003b92:	4d0d      	ldr	r5, [pc, #52]	@ (34003bc8 <__libc_init_array+0x38>)
34003b94:	2600      	movs	r6, #0
34003b96:	4c0d      	ldr	r4, [pc, #52]	@ (34003bcc <__libc_init_array+0x3c>)
34003b98:	1b64      	subs	r4, r4, r5
34003b9a:	10a4      	asrs	r4, r4, #2
34003b9c:	42a6      	cmp	r6, r4
34003b9e:	d109      	bne.n	34003bb4 <__libc_init_array+0x24>
34003ba0:	4d0b      	ldr	r5, [pc, #44]	@ (34003bd0 <__libc_init_array+0x40>)
34003ba2:	2600      	movs	r6, #0
34003ba4:	4c0b      	ldr	r4, [pc, #44]	@ (34003bd4 <__libc_init_array+0x44>)
34003ba6:	f000 f825 	bl	34003bf4 <_init>
34003baa:	1b64      	subs	r4, r4, r5
34003bac:	10a4      	asrs	r4, r4, #2
34003bae:	42a6      	cmp	r6, r4
34003bb0:	d105      	bne.n	34003bbe <__libc_init_array+0x2e>
34003bb2:	bd70      	pop	{r4, r5, r6, pc}
34003bb4:	f855 3b04 	ldr.w	r3, [r5], #4
34003bb8:	3601      	adds	r6, #1
34003bba:	4798      	blx	r3
34003bbc:	e7ee      	b.n	34003b9c <__libc_init_array+0xc>
34003bbe:	f855 3b04 	ldr.w	r3, [r5], #4
34003bc2:	3601      	adds	r6, #1
34003bc4:	4798      	blx	r3
34003bc6:	e7f2      	b.n	34003bae <__libc_init_array+0x1e>
34003bc8:	34003c28 	.word	0x34003c28
34003bcc:	34003c28 	.word	0x34003c28
34003bd0:	34003c28 	.word	0x34003c28
34003bd4:	34003c2c 	.word	0x34003c2c

34003bd8 <memcpy>:
34003bd8:	440a      	add	r2, r1
34003bda:	1e43      	subs	r3, r0, #1
34003bdc:	4291      	cmp	r1, r2
34003bde:	d100      	bne.n	34003be2 <memcpy+0xa>
34003be0:	4770      	bx	lr
34003be2:	b510      	push	{r4, lr}
34003be4:	f811 4b01 	ldrb.w	r4, [r1], #1
34003be8:	4291      	cmp	r1, r2
34003bea:	f803 4f01 	strb.w	r4, [r3, #1]!
34003bee:	d1f9      	bne.n	34003be4 <memcpy+0xc>
34003bf0:	bd10      	pop	{r4, pc}
	...

34003bf4 <_init>:
34003bf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34003bf6:	bf00      	nop
34003bf8:	bcf8      	pop	{r3, r4, r5, r6, r7}
34003bfa:	bc08      	pop	{r3}
34003bfc:	469e      	mov	lr, r3
34003bfe:	4770      	bx	lr

34003c00 <_fini>:
34003c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34003c02:	bf00      	nop
34003c04:	bcf8      	pop	{r3, r4, r5, r6, r7}
34003c06:	bc08      	pop	{r3}
34003c08:	469e      	mov	lr, r3
34003c0a:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34003c40 <SECURE_SystemCoreClockUpdate>:
34003c40:	e97f e97f 	sg
34003c44:	f7fd b8b4 	b.w	34000db0 <__acle_se_SECURE_SystemCoreClockUpdate>

34003c48 <SECURE_RegisterCallback>:
34003c48:	e97f e97f 	sg
34003c4c:	f7fc be38 	b.w	340008c0 <__acle_se_SECURE_RegisterCallback>
	...
